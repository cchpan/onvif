/* soapStub.h
   Generated by gSOAP 2.8.28 from onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_WSA_2005
#define SOAP_NAMESPACE_OF_tmd	"http://www.onvif.org/ver10/deviceIO/wsdl"
#define SOAP_NAMESPACE_OF_tds	"http://www.onvif.org/ver10/device/wsdl"
#define SOAP_NAMESPACE_OF_tt	"http://www.onvif.org/ver10/schema"
#define SOAP_NAMESPACE_OF_wsnt	"http://docs.oasis-open.org/wsn/b-2"
#define SOAP_NAMESPACE_OF_wsrfbf	"http://docs.oasis-open.org/wsrf/bf-2"
#define SOAP_NAMESPACE_OF_wstop	"http://docs.oasis-open.org/wsn/t-1"
#define SOAP_NAMESPACE_OF_tls	"http://www.onvif.org/ver10/display/wsdl"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20828
# error "GSOAP VERSION 20828 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/* wsa5.h:94 */
#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (22)
/* wsa5:RelationshipType */
enum wsa5__RelationshipType
{
	http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply = 0
};
#endif

/* wsa5.h:102 */
#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (23)
/* wsa5:FaultCodesType */
enum wsa5__FaultCodesType
{
	wsa5__InvalidAddressingHeader = 0,
	wsa5__InvalidAddress = 1,
	wsa5__InvalidEPR = 2,
	wsa5__InvalidCardinality = 3,
	wsa5__MissingAddressInEPR = 4,
	wsa5__DuplicateMessageID = 5,
	wsa5__ActionMismatch = 6,
	wsa5__MessageAddressingHeaderRequired = 7,
	wsa5__DestinationUnreachable = 8,
	wsa5__ActionNotSupported = 9,
	wsa5__EndpointUnavailable = 10
};
#endif

/* wsa5.h:252 */
#ifndef SOAP_TYPE__wsa5__IsReferenceParameter
#define SOAP_TYPE__wsa5__IsReferenceParameter (43)
/* wsa5:IsReferenceParameter */
enum _wsa5__IsReferenceParameter
{
	_wsa5__IsReferenceParameter__false = 0,
	_wsa5__IsReferenceParameter__true = 1
};
#endif

/* onvif.h:2679 */
#ifndef SOAP_TYPE_tmd__SerialPortType
#define SOAP_TYPE_tmd__SerialPortType (872)
/* tmd:SerialPortType */
enum tmd__SerialPortType
{
	tmd__SerialPortType__RS232 = 0,
	tmd__SerialPortType__RS422HalfDuplex = 1,
	tmd__SerialPortType__RS422FullDuplex = 2,
	tmd__SerialPortType__RS485HalfDuplex = 3,
	tmd__SerialPortType__RS485FullDuplex = 4,
	tmd__SerialPortType__Generic = 5
};
#endif

/* onvif.h:2695 */
#ifndef SOAP_TYPE_tmd__ParityBit
#define SOAP_TYPE_tmd__ParityBit (873)
/* tmd:ParityBit */
enum tmd__ParityBit
{
	tmd__ParityBit__None = 0,
	tmd__ParityBit__Even = 1,
	tmd__ParityBit__Odd = 2,
	tmd__ParityBit__Mark = 3,
	tmd__ParityBit__Space = 4,
	tmd__ParityBit__Extended = 5
};
#endif

/* onvif.h:2716 */
#ifndef SOAP_TYPE_tds__AutoGeoModes
#define SOAP_TYPE_tds__AutoGeoModes (874)
/* tds:AutoGeoModes */
enum tds__AutoGeoModes
{
	tds__AutoGeoModes__Location = 0,
	tds__AutoGeoModes__Heading = 1,
	tds__AutoGeoModes__Leveling = 2
};
#endif

/* onvif.h:2735 */
#ifndef SOAP_TYPE_tds__StorageType
#define SOAP_TYPE_tds__StorageType (875)
/* tds:StorageType */
enum tds__StorageType
{
	tds__StorageType__NFS = 0,
	tds__StorageType__CIFS = 1,
	tds__StorageType__CDMI = 2,
	tds__StorageType__FTP = 3
};
#endif

/* onvif.h:2784 */
#ifndef SOAP_TYPE_tt__RotateMode
#define SOAP_TYPE_tt__RotateMode (878)
/* tt:RotateMode */
enum tt__RotateMode
{
	tt__RotateMode__OFF = 0,
	tt__RotateMode__ON = 1,
	tt__RotateMode__AUTO = 2
};
#endif

/* onvif.h:2803 */
#ifndef SOAP_TYPE_tt__SceneOrientationMode
#define SOAP_TYPE_tt__SceneOrientationMode (879)
/* tt:SceneOrientationMode */
enum tt__SceneOrientationMode
{
	tt__SceneOrientationMode__MANUAL = 0,
	tt__SceneOrientationMode__AUTO = 1
};
#endif

/* onvif.h:2815 */
#ifndef SOAP_TYPE_tt__SceneOrientationOption
#define SOAP_TYPE_tt__SceneOrientationOption (880)
/* tt:SceneOrientationOption */
enum tt__SceneOrientationOption
{
	tt__SceneOrientationOption__Below = 0,
	tt__SceneOrientationOption__Horizon = 1,
	tt__SceneOrientationOption__Above = 2
};
#endif

/* onvif.h:2828 */
#ifndef SOAP_TYPE_tt__ViewModes
#define SOAP_TYPE_tt__ViewModes (881)
/* tt:ViewModes */
enum tt__ViewModes
{
	tt__ViewModes__tt_x003aFisheye = 0,
	tt__ViewModes__tt_x003a360Panorama = 1,
	tt__ViewModes__tt_x003a180Panorama = 2,
	tt__ViewModes__tt_x003aQuad = 3,
	tt__ViewModes__tt_x003aOriginal = 4,
	tt__ViewModes__tt_x003aLeftHalf = 5,
	tt__ViewModes__tt_x003aRightHalf = 6,
	tt__ViewModes__tt_x003aDewarp = 7
};
#endif

/* onvif.h:2867 */
#ifndef SOAP_TYPE_tt__VideoEncoding
#define SOAP_TYPE_tt__VideoEncoding (882)
/* tt:VideoEncoding */
enum tt__VideoEncoding
{
	tt__VideoEncoding__JPEG = 0,
	tt__VideoEncoding__MPEG4 = 1,
	tt__VideoEncoding__H264 = 2
};
#endif

/* onvif.h:2877 */
#ifndef SOAP_TYPE_tt__Mpeg4Profile
#define SOAP_TYPE_tt__Mpeg4Profile (883)
/* tt:Mpeg4Profile */
enum tt__Mpeg4Profile
{
	tt__Mpeg4Profile__SP = 0,
	tt__Mpeg4Profile__ASP = 1
};
#endif

/* onvif.h:2886 */
#ifndef SOAP_TYPE_tt__H264Profile
#define SOAP_TYPE_tt__H264Profile (884)
/* tt:H264Profile */
enum tt__H264Profile
{
	tt__H264Profile__Baseline = 0,
	tt__H264Profile__Main = 1,
	tt__H264Profile__Extended = 2,
	tt__H264Profile__High = 3
};
#endif

/* onvif.h:2900 */
#ifndef SOAP_TYPE_tt__VideoEncodingMimeNames
#define SOAP_TYPE_tt__VideoEncodingMimeNames (885)
/* tt:VideoEncodingMimeNames */
enum tt__VideoEncodingMimeNames
{
	tt__VideoEncodingMimeNames__JPEG = 0,
	tt__VideoEncodingMimeNames__MPV4_ES = 1,
	tt__VideoEncodingMimeNames__H264 = 2,
	tt__VideoEncodingMimeNames__H265 = 3
};
#endif

/* onvif.h:2911 */
#ifndef SOAP_TYPE_tt__VideoEncodingProfiles
#define SOAP_TYPE_tt__VideoEncodingProfiles (886)
/* tt:VideoEncodingProfiles */
enum tt__VideoEncodingProfiles
{
	tt__VideoEncodingProfiles__Simple = 0,
	tt__VideoEncodingProfiles__AdvancedSimple = 1,
	tt__VideoEncodingProfiles__Baseline = 2,
	tt__VideoEncodingProfiles__Main = 3,
	tt__VideoEncodingProfiles__Main10 = 4,
	tt__VideoEncodingProfiles__Extended = 5,
	tt__VideoEncodingProfiles__High = 6
};
#endif

/* onvif.h:2925 */
#ifndef SOAP_TYPE_tt__AudioEncoding
#define SOAP_TYPE_tt__AudioEncoding (887)
/* tt:AudioEncoding */
enum tt__AudioEncoding
{
	tt__AudioEncoding__G711 = 0,
	tt__AudioEncoding__G726 = 1,
	tt__AudioEncoding__AAC = 2
};
#endif

/* onvif.h:2938 */
#ifndef SOAP_TYPE_tt__AudioEncodingMimeNames
#define SOAP_TYPE_tt__AudioEncodingMimeNames (888)
/* tt:AudioEncodingMimeNames */
enum tt__AudioEncodingMimeNames
{
	tt__AudioEncodingMimeNames__PCMU = 0,
	tt__AudioEncodingMimeNames__G726 = 1,
	tt__AudioEncodingMimeNames__MP4A_LATM = 2
};
#endif

/* onvif.h:2948 */
#ifndef SOAP_TYPE_tt__MetadataCompressionType
#define SOAP_TYPE_tt__MetadataCompressionType (889)
/* tt:MetadataCompressionType */
enum tt__MetadataCompressionType
{
	tt__MetadataCompressionType__None = 0,
	tt__MetadataCompressionType__GZIP = 1,
	tt__MetadataCompressionType__EXI = 2
};
#endif

/* onvif.h:2958 */
#ifndef SOAP_TYPE_tt__StreamType
#define SOAP_TYPE_tt__StreamType (890)
/* tt:StreamType */
enum tt__StreamType
{
	tt__StreamType__RTP_Unicast = 0,
	tt__StreamType__RTP_Multicast = 1
};
#endif

/* onvif.h:2967 */
#ifndef SOAP_TYPE_tt__TransportProtocol
#define SOAP_TYPE_tt__TransportProtocol (891)
/* tt:TransportProtocol */
enum tt__TransportProtocol
{
	tt__TransportProtocol__UDP = 0,
	tt__TransportProtocol__TCP = 1,
	tt__TransportProtocol__RTSP = 2,
	tt__TransportProtocol__HTTP = 3
};
#endif

/* onvif.h:2981 */
#ifndef SOAP_TYPE_tt__ScopeDefinition
#define SOAP_TYPE_tt__ScopeDefinition (892)
/* tt:ScopeDefinition */
enum tt__ScopeDefinition
{
	tt__ScopeDefinition__Fixed = 0,
	tt__ScopeDefinition__Configurable = 1
};
#endif

/* onvif.h:2990 */
#ifndef SOAP_TYPE_tt__DiscoveryMode
#define SOAP_TYPE_tt__DiscoveryMode (893)
/* tt:DiscoveryMode */
enum tt__DiscoveryMode
{
	tt__DiscoveryMode__Discoverable = 0,
	tt__DiscoveryMode__NonDiscoverable = 1
};
#endif

/* onvif.h:3004 */
#ifndef SOAP_TYPE_tt__Duplex
#define SOAP_TYPE_tt__Duplex (895)
/* tt:Duplex */
enum tt__Duplex
{
	tt__Duplex__Full = 0,
	tt__Duplex__Half = 1
};
#endif

/* onvif.h:3020 */
#ifndef SOAP_TYPE_tt__IPv6DHCPConfiguration
#define SOAP_TYPE_tt__IPv6DHCPConfiguration (897)
/* tt:IPv6DHCPConfiguration */
enum tt__IPv6DHCPConfiguration
{
	tt__IPv6DHCPConfiguration__Auto = 0,
	tt__IPv6DHCPConfiguration__Stateful = 1,
	tt__IPv6DHCPConfiguration__Stateless = 2,
	tt__IPv6DHCPConfiguration__Off = 3
};
#endif

/* onvif.h:3031 */
#ifndef SOAP_TYPE_tt__NetworkProtocolType
#define SOAP_TYPE_tt__NetworkProtocolType (898)
/* tt:NetworkProtocolType */
enum tt__NetworkProtocolType
{
	tt__NetworkProtocolType__HTTP = 0,
	tt__NetworkProtocolType__HTTPS = 1,
	tt__NetworkProtocolType__RTSP = 2
};
#endif

/* onvif.h:3041 */
#ifndef SOAP_TYPE_tt__NetworkHostType
#define SOAP_TYPE_tt__NetworkHostType (899)
/* tt:NetworkHostType */
enum tt__NetworkHostType
{
	tt__NetworkHostType__IPv4 = 0,
	tt__NetworkHostType__IPv6 = 1,
	tt__NetworkHostType__DNS = 2
};
#endif

/* onvif.h:3063 */
#ifndef SOAP_TYPE_tt__IPType
#define SOAP_TYPE_tt__IPType (903)
/* tt:IPType */
enum tt__IPType
{
	tt__IPType__IPv4 = 0,
	tt__IPType__IPv6 = 1
};
#endif

/* onvif.h:3080 */
#ifndef SOAP_TYPE_tt__IPAddressFilterType
#define SOAP_TYPE_tt__IPAddressFilterType (906)
/* tt:IPAddressFilterType */
enum tt__IPAddressFilterType
{
	tt__IPAddressFilterType__Allow = 0,
	tt__IPAddressFilterType__Deny = 1
};
#endif

/* onvif.h:3089 */
#ifndef SOAP_TYPE_tt__DynamicDNSType
#define SOAP_TYPE_tt__DynamicDNSType (907)
/* tt:DynamicDNSType */
enum tt__DynamicDNSType
{
	tt__DynamicDNSType__NoUpdate = 0,
	tt__DynamicDNSType__ClientUpdates = 1,
	tt__DynamicDNSType__ServerUpdates = 2
};
#endif

/* onvif.h:3104 */
#ifndef SOAP_TYPE_tt__Dot11StationMode
#define SOAP_TYPE_tt__Dot11StationMode (909)
/* tt:Dot11StationMode */
enum tt__Dot11StationMode
{
	tt__Dot11StationMode__Ad_hoc = 0,
	tt__Dot11StationMode__Infrastructure = 1,
	tt__Dot11StationMode__Extended = 2
};
#endif

/* onvif.h:3114 */
#ifndef SOAP_TYPE_tt__Dot11SecurityMode
#define SOAP_TYPE_tt__Dot11SecurityMode (910)
/* tt:Dot11SecurityMode */
enum tt__Dot11SecurityMode
{
	tt__Dot11SecurityMode__None = 0,
	tt__Dot11SecurityMode__WEP = 1,
	tt__Dot11SecurityMode__PSK = 2,
	tt__Dot11SecurityMode__Dot1X = 3,
	tt__Dot11SecurityMode__Extended = 4
};
#endif

/* onvif.h:3126 */
#ifndef SOAP_TYPE_tt__Dot11Cipher
#define SOAP_TYPE_tt__Dot11Cipher (911)
/* tt:Dot11Cipher */
enum tt__Dot11Cipher
{
	tt__Dot11Cipher__CCMP = 0,
	tt__Dot11Cipher__TKIP = 1,
	tt__Dot11Cipher__Any = 2,
	tt__Dot11Cipher__Extended = 3
};
#endif

/* onvif.h:3147 */
#ifndef SOAP_TYPE_tt__Dot11SignalStrength
#define SOAP_TYPE_tt__Dot11SignalStrength (914)
/* tt:Dot11SignalStrength */
enum tt__Dot11SignalStrength
{
	tt__Dot11SignalStrength__None = 0,
	tt__Dot11SignalStrength__Very_x0020Bad = 1,
	tt__Dot11SignalStrength__Bad = 2,
	tt__Dot11SignalStrength__Good = 3,
	tt__Dot11SignalStrength__Very_x0020Good = 4,
	tt__Dot11SignalStrength__Extended = 5
};
#endif

/* onvif.h:3160 */
#ifndef SOAP_TYPE_tt__Dot11AuthAndMangementSuite
#define SOAP_TYPE_tt__Dot11AuthAndMangementSuite (915)
/* tt:Dot11AuthAndMangementSuite */
enum tt__Dot11AuthAndMangementSuite
{
	tt__Dot11AuthAndMangementSuite__None = 0,
	tt__Dot11AuthAndMangementSuite__Dot1X = 1,
	tt__Dot11AuthAndMangementSuite__PSK = 2,
	tt__Dot11AuthAndMangementSuite__Extended = 3
};
#endif

/* onvif.h:3171 */
#ifndef SOAP_TYPE_tt__CapabilityCategory
#define SOAP_TYPE_tt__CapabilityCategory (916)
/* tt:CapabilityCategory */
enum tt__CapabilityCategory
{
	tt__CapabilityCategory__All = 0,
	tt__CapabilityCategory__Analytics = 1,
	tt__CapabilityCategory__Device = 2,
	tt__CapabilityCategory__Events = 3,
	tt__CapabilityCategory__Imaging = 4,
	tt__CapabilityCategory__Media = 5,
	tt__CapabilityCategory__PTZ = 6
};
#endif

/* onvif.h:3188 */
#ifndef SOAP_TYPE_tt__SystemLogType
#define SOAP_TYPE_tt__SystemLogType (917)
/* tt:SystemLogType */
enum tt__SystemLogType
{
	tt__SystemLogType__System = 0,
	tt__SystemLogType__Access = 1
};
#endif

/* onvif.h:3206 */
#ifndef SOAP_TYPE_tt__FactoryDefaultType
#define SOAP_TYPE_tt__FactoryDefaultType (918)
/* tt:FactoryDefaultType */
enum tt__FactoryDefaultType
{
	tt__FactoryDefaultType__Hard = 0,
	tt__FactoryDefaultType__Soft = 1
};
#endif

/* onvif.h:3221 */
#ifndef SOAP_TYPE_tt__SetDateTimeType
#define SOAP_TYPE_tt__SetDateTimeType (919)
/* tt:SetDateTimeType */
enum tt__SetDateTimeType
{
	tt__SetDateTimeType__Manual = 0,
	tt__SetDateTimeType__NTP = 1
};
#endif

/* onvif.h:3236 */
#ifndef SOAP_TYPE_tt__Entity
#define SOAP_TYPE_tt__Entity (920)
/* tt:Entity */
enum tt__Entity
{
	tt__Entity__Device = 0,
	tt__Entity__VideoSource = 1,
	tt__Entity__AudioSource = 2
};
#endif

/* onvif.h:3246 */
#ifndef SOAP_TYPE_tt__UserLevel
#define SOAP_TYPE_tt__UserLevel (921)
/* tt:UserLevel */
enum tt__UserLevel
{
	tt__UserLevel__Administrator = 0,
	tt__UserLevel__Operator = 1,
	tt__UserLevel__User = 2,
	tt__UserLevel__Anonymous = 3,
	tt__UserLevel__Extended = 4
};
#endif

/* onvif.h:3258 */
#ifndef SOAP_TYPE_tt__RelayLogicalState
#define SOAP_TYPE_tt__RelayLogicalState (922)
/* tt:RelayLogicalState */
enum tt__RelayLogicalState
{
	tt__RelayLogicalState__active = 0,
	tt__RelayLogicalState__inactive = 1
};
#endif

/* onvif.h:3267 */
#ifndef SOAP_TYPE_tt__RelayIdleState
#define SOAP_TYPE_tt__RelayIdleState (923)
/* tt:RelayIdleState */
enum tt__RelayIdleState
{
	tt__RelayIdleState__closed = 0,
	tt__RelayIdleState__open = 1
};
#endif

/* onvif.h:3276 */
#ifndef SOAP_TYPE_tt__RelayMode
#define SOAP_TYPE_tt__RelayMode (924)
/* tt:RelayMode */
enum tt__RelayMode
{
	tt__RelayMode__Monostable = 0,
	tt__RelayMode__Bistable = 1
};
#endif

/* onvif.h:3285 */
#ifndef SOAP_TYPE_tt__DigitalIdleState
#define SOAP_TYPE_tt__DigitalIdleState (925)
/* tt:DigitalIdleState */
enum tt__DigitalIdleState
{
	tt__DigitalIdleState__closed = 0,
	tt__DigitalIdleState__open = 1
};
#endif

/* onvif.h:3294 */
#ifndef SOAP_TYPE_tt__EFlipMode
#define SOAP_TYPE_tt__EFlipMode (926)
/* tt:EFlipMode */
enum tt__EFlipMode
{
	tt__EFlipMode__OFF = 0,
	tt__EFlipMode__ON = 1,
	tt__EFlipMode__Extended = 2
};
#endif

/* onvif.h:3304 */
#ifndef SOAP_TYPE_tt__ReverseMode
#define SOAP_TYPE_tt__ReverseMode (927)
/* tt:ReverseMode */
enum tt__ReverseMode
{
	tt__ReverseMode__OFF = 0,
	tt__ReverseMode__ON = 1,
	tt__ReverseMode__AUTO = 2,
	tt__ReverseMode__Extended = 3
};
#endif

/* onvif.h:3320 */
#ifndef SOAP_TYPE_tt__PTZPresetTourState
#define SOAP_TYPE_tt__PTZPresetTourState (929)
/* tt:PTZPresetTourState */
enum tt__PTZPresetTourState
{
	tt__PTZPresetTourState__Idle = 0,
	tt__PTZPresetTourState__Touring = 1,
	tt__PTZPresetTourState__Paused = 2,
	tt__PTZPresetTourState__Extended = 3
};
#endif

/* onvif.h:3331 */
#ifndef SOAP_TYPE_tt__PTZPresetTourDirection
#define SOAP_TYPE_tt__PTZPresetTourDirection (930)
/* tt:PTZPresetTourDirection */
enum tt__PTZPresetTourDirection
{
	tt__PTZPresetTourDirection__Forward = 0,
	tt__PTZPresetTourDirection__Backward = 1,
	tt__PTZPresetTourDirection__Extended = 2
};
#endif

/* onvif.h:3341 */
#ifndef SOAP_TYPE_tt__PTZPresetTourOperation
#define SOAP_TYPE_tt__PTZPresetTourOperation (931)
/* tt:PTZPresetTourOperation */
enum tt__PTZPresetTourOperation
{
	tt__PTZPresetTourOperation__Start = 0,
	tt__PTZPresetTourOperation__Stop = 1,
	tt__PTZPresetTourOperation__Pause = 2,
	tt__PTZPresetTourOperation__Extended = 3
};
#endif

/* onvif.h:3352 */
#ifndef SOAP_TYPE_tt__AutoFocusMode
#define SOAP_TYPE_tt__AutoFocusMode (932)
/* tt:AutoFocusMode */
enum tt__AutoFocusMode
{
	tt__AutoFocusMode__AUTO = 0,
	tt__AutoFocusMode__MANUAL = 1
};
#endif

/* onvif.h:3361 */
#ifndef SOAP_TYPE_tt__WideDynamicMode
#define SOAP_TYPE_tt__WideDynamicMode (933)
/* tt:WideDynamicMode */
enum tt__WideDynamicMode
{
	tt__WideDynamicMode__OFF = 0,
	tt__WideDynamicMode__ON = 1
};
#endif

/* onvif.h:3373 */
#ifndef SOAP_TYPE_tt__BacklightCompensationMode
#define SOAP_TYPE_tt__BacklightCompensationMode (934)
/* tt:BacklightCompensationMode */
enum tt__BacklightCompensationMode
{
	tt__BacklightCompensationMode__OFF = 0,
	tt__BacklightCompensationMode__ON = 1
};
#endif

/* onvif.h:3388 */
#ifndef SOAP_TYPE_tt__ExposurePriority
#define SOAP_TYPE_tt__ExposurePriority (935)
/* tt:ExposurePriority */
enum tt__ExposurePriority
{
	tt__ExposurePriority__LowNoise = 0,
	tt__ExposurePriority__FrameRate = 1
};
#endif

/* onvif.h:3397 */
#ifndef SOAP_TYPE_tt__ExposureMode
#define SOAP_TYPE_tt__ExposureMode (936)
/* tt:ExposureMode */
enum tt__ExposureMode
{
	tt__ExposureMode__AUTO = 0,
	tt__ExposureMode__MANUAL = 1
};
#endif

/* onvif.h:3406 */
#ifndef SOAP_TYPE_tt__Enabled
#define SOAP_TYPE_tt__Enabled (937)
/* tt:Enabled */
enum tt__Enabled
{
	tt__Enabled__ENABLED = 0,
	tt__Enabled__DISABLED = 1
};
#endif

/* onvif.h:3415 */
#ifndef SOAP_TYPE_tt__WhiteBalanceMode
#define SOAP_TYPE_tt__WhiteBalanceMode (938)
/* tt:WhiteBalanceMode */
enum tt__WhiteBalanceMode
{
	tt__WhiteBalanceMode__AUTO = 0,
	tt__WhiteBalanceMode__MANUAL = 1
};
#endif

/* onvif.h:3424 */
#ifndef SOAP_TYPE_tt__IrCutFilterMode
#define SOAP_TYPE_tt__IrCutFilterMode (939)
/* tt:IrCutFilterMode */
enum tt__IrCutFilterMode
{
	tt__IrCutFilterMode__ON = 0,
	tt__IrCutFilterMode__OFF = 1,
	tt__IrCutFilterMode__AUTO = 2
};
#endif

/* onvif.h:3434 */
#ifndef SOAP_TYPE_tt__ImageStabilizationMode
#define SOAP_TYPE_tt__ImageStabilizationMode (940)
/* tt:ImageStabilizationMode */
enum tt__ImageStabilizationMode
{
	tt__ImageStabilizationMode__OFF = 0,
	tt__ImageStabilizationMode__ON = 1,
	tt__ImageStabilizationMode__AUTO = 2,
	tt__ImageStabilizationMode__Extended = 3
};
#endif

/* onvif.h:3445 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoBoundaryType
#define SOAP_TYPE_tt__IrCutFilterAutoBoundaryType (941)
/* tt:IrCutFilterAutoBoundaryType */
enum tt__IrCutFilterAutoBoundaryType
{
	tt__IrCutFilterAutoBoundaryType__Common = 0,
	tt__IrCutFilterAutoBoundaryType__ToOn = 1,
	tt__IrCutFilterAutoBoundaryType__ToOff = 2,
	tt__IrCutFilterAutoBoundaryType__Extended = 3
};
#endif

/* onvif.h:3456 */
#ifndef SOAP_TYPE_tt__ToneCompensationMode
#define SOAP_TYPE_tt__ToneCompensationMode (942)
/* tt:ToneCompensationMode */
enum tt__ToneCompensationMode
{
	tt__ToneCompensationMode__OFF = 0,
	tt__ToneCompensationMode__ON = 1,
	tt__ToneCompensationMode__AUTO = 2
};
#endif

/* onvif.h:3466 */
#ifndef SOAP_TYPE_tt__DefoggingMode
#define SOAP_TYPE_tt__DefoggingMode (943)
/* tt:DefoggingMode */
enum tt__DefoggingMode
{
	tt__DefoggingMode__OFF = 0,
	tt__DefoggingMode__ON = 1,
	tt__DefoggingMode__AUTO = 2
};
#endif

/* onvif.h:3480 */
#ifndef SOAP_TYPE_tt__PropertyOperation
#define SOAP_TYPE_tt__PropertyOperation (945)
/* tt:PropertyOperation */
enum tt__PropertyOperation
{
	tt__PropertyOperation__Initialized = 0,
	tt__PropertyOperation__Deleted = 1,
	tt__PropertyOperation__Changed = 2
};
#endif

/* onvif.h:3490 */
#ifndef SOAP_TYPE_tt__Direction
#define SOAP_TYPE_tt__Direction (946)
/* tt:Direction */
enum tt__Direction
{
	tt__Direction__Left = 0,
	tt__Direction__Right = 1,
	tt__Direction__Any = 2
};
#endif

/* onvif.h:3503 */
#ifndef SOAP_TYPE_tt__ReceiverMode
#define SOAP_TYPE_tt__ReceiverMode (947)
/* tt:ReceiverMode */
enum tt__ReceiverMode
{
	tt__ReceiverMode__AutoConnect = 0,
	tt__ReceiverMode__AlwaysConnect = 1,
	tt__ReceiverMode__NeverConnect = 2,
	tt__ReceiverMode__Unknown = 3
};
#endif

/* onvif.h:3529 */
#ifndef SOAP_TYPE_tt__ReceiverState
#define SOAP_TYPE_tt__ReceiverState (948)
/* tt:ReceiverState */
enum tt__ReceiverState
{
	tt__ReceiverState__NotConnected = 0,
	tt__ReceiverState__Connecting = 1,
	tt__ReceiverState__Connected = 2,
	tt__ReceiverState__Unknown = 3
};
#endif

/* onvif.h:3560 */
#ifndef SOAP_TYPE_tt__SearchState
#define SOAP_TYPE_tt__SearchState (951)
/* tt:SearchState */
enum tt__SearchState
{
	tt__SearchState__Queued = 0,
	tt__SearchState__Searching = 1,
	tt__SearchState__Completed = 2,
	tt__SearchState__Unknown = 3
};
#endif

/* onvif.h:3583 */
#ifndef SOAP_TYPE_tt__RecordingStatus
#define SOAP_TYPE_tt__RecordingStatus (952)
/* tt:RecordingStatus */
enum tt__RecordingStatus
{
	tt__RecordingStatus__Initiated = 0,
	tt__RecordingStatus__Recording = 1,
	tt__RecordingStatus__Stopped = 2,
	tt__RecordingStatus__Removing = 3,
	tt__RecordingStatus__Removed = 4,
	tt__RecordingStatus__Unknown = 5
};
#endif

/* onvif.h:3599 */
#ifndef SOAP_TYPE_tt__TrackType
#define SOAP_TYPE_tt__TrackType (953)
/* tt:TrackType */
enum tt__TrackType
{
	tt__TrackType__Video = 0,
	tt__TrackType__Audio = 1,
	tt__TrackType__Metadata = 2,
	tt__TrackType__Extended = 3
};
#endif

/* onvif.h:3621 */
#ifndef SOAP_TYPE_tt__ModeOfOperation
#define SOAP_TYPE_tt__ModeOfOperation (956)
/* tt:ModeOfOperation */
enum tt__ModeOfOperation
{
	tt__ModeOfOperation__Idle = 0,
	tt__ModeOfOperation__Active = 1,
	tt__ModeOfOperation__Unknown = 2
};
#endif

/* onvif.h:3642 */
#ifndef SOAP_TYPE_tt__OSDType
#define SOAP_TYPE_tt__OSDType (958)
/* tt:OSDType */
enum tt__OSDType
{
	tt__OSDType__Text = 0,
	tt__OSDType__Image = 1,
	tt__OSDType__Extended = 2
};
#endif

/* onvif.h:3652 */
#ifndef SOAP_TYPE_tt__MoveStatus
#define SOAP_TYPE_tt__MoveStatus (959)
/* tt:MoveStatus */
enum tt__MoveStatus
{
	tt__MoveStatus__IDLE = 0,
	tt__MoveStatus__MOVING = 1,
	tt__MoveStatus__UNKNOWN = 2
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* custom/duration.h:90 */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (70)
typedef LONG64 xsd__duration;
#endif
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (65)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes, Structs, and Unions                                               *
 *                                                                            *
\******************************************************************************/

struct _xop__Include;	/* xop.h:58 */
struct wsa5__EndpointReferenceType;	/* wsa5.h:63 */
struct wsa5__ReferenceParametersType;	/* wsa5.h:66 */
struct wsa5__MetadataType;	/* wsa5.h:69 */
struct wsa5__ProblemActionType;	/* wsa5.h:84 */
struct wsa5__RelatesToType;	/* wsa5.h:72 */
struct chan__ChannelInstanceType;	/* wsa5.h:258 */
class xsd__anyType;	/* onvif.h:178 */
struct SOAP_ENV__Envelope;	/* onvif.h:181 */
class xsd__base64Binary;	/* onvif.h:187 */
class xsd__hexBinary;	/* onvif.h:198 */
class tmd__Capabilities;	/* onvif.h:232 */
class tmd__RelayOutputOptions;	/* onvif.h:235 */
class tmd__RelayOutputOptionsExtension;	/* onvif.h:238 */
class tmd__Get;	/* onvif.h:241 */
class tmd__GetResponse;	/* onvif.h:244 */
class tmd__DigitalInputConfigurationOptions;	/* onvif.h:247 */
union _tmd__union_SerialData;	/* onvif.h:4014 */
class tmd__SerialData;	/* onvif.h:250 */
class tmd__SerialPortConfiguration;	/* onvif.h:256 */
class tmd__SerialPortConfigurationOptions;	/* onvif.h:259 */
class tmd__ParityBitList;	/* onvif.h:262 */
class _tmd__GetServiceCapabilities;	/* onvif.h:265 */
class _tmd__GetServiceCapabilitiesResponse;	/* onvif.h:268 */
class _tmd__GetRelayOutputOptions;	/* onvif.h:271 */
class _tmd__GetRelayOutputOptionsResponse;	/* onvif.h:274 */
class _tmd__GetVideoOutputs;	/* onvif.h:277 */
class _tmd__GetVideoOutputsResponse;	/* onvif.h:280 */
class _tmd__GetAudioSourceConfiguration;	/* onvif.h:283 */
class _tmd__GetAudioSourceConfigurationResponse;	/* onvif.h:286 */
class _tmd__GetAudioOutputConfiguration;	/* onvif.h:289 */
class _tmd__GetAudioOutputConfigurationResponse;	/* onvif.h:292 */
class _tmd__GetVideoSourceConfiguration;	/* onvif.h:295 */
class _tmd__GetVideoSourceConfigurationResponse;	/* onvif.h:298 */
class _tmd__GetVideoOutputConfiguration;	/* onvif.h:301 */
class _tmd__GetVideoOutputConfigurationResponse;	/* onvif.h:304 */
class _tmd__SetAudioSourceConfiguration;	/* onvif.h:307 */
class _tmd__SetAudioSourceConfigurationResponse;	/* onvif.h:310 */
class _tmd__SetAudioOutputConfiguration;	/* onvif.h:313 */
class _tmd__SetAudioOutputConfigurationResponse;	/* onvif.h:316 */
class _tmd__SetVideoSourceConfiguration;	/* onvif.h:319 */
class _tmd__SetVideoSourceConfigurationResponse;	/* onvif.h:322 */
class _tmd__SetVideoOutputConfiguration;	/* onvif.h:325 */
class _tmd__SetVideoOutputConfigurationResponse;	/* onvif.h:328 */
class _tmd__GetVideoSourceConfigurationOptions;	/* onvif.h:331 */
class _tmd__GetVideoSourceConfigurationOptionsResponse;	/* onvif.h:334 */
class _tmd__GetVideoOutputConfigurationOptions;	/* onvif.h:337 */
class _tmd__GetVideoOutputConfigurationOptionsResponse;	/* onvif.h:340 */
class _tmd__GetAudioSourceConfigurationOptions;	/* onvif.h:343 */
class _tmd__GetAudioSourceConfigurationOptionsResponse;	/* onvif.h:346 */
class _tmd__GetAudioOutputConfigurationOptions;	/* onvif.h:349 */
class _tmd__GetAudioOutputConfigurationOptionsResponse;	/* onvif.h:352 */
class _tmd__SetRelayOutputSettings;	/* onvif.h:355 */
class _tmd__SetRelayOutputSettingsResponse;	/* onvif.h:358 */
class _tmd__GetDigitalInputs;	/* onvif.h:361 */
class _tmd__GetDigitalInputsResponse;	/* onvif.h:364 */
class _tmd__GetDigitalInputConfigurationOptions;	/* onvif.h:367 */
class _tmd__GetDigitalInputConfigurationOptionsResponse;	/* onvif.h:370 */
class _tmd__SetDigitalInputConfigurations;	/* onvif.h:373 */
class _tmd__SetDigitalInputConfigurationsResponse;	/* onvif.h:376 */
class _tmd__GetSerialPorts;	/* onvif.h:379 */
class _tmd__GetSerialPortsResponse;	/* onvif.h:382 */
class _tmd__GetSerialPortConfiguration;	/* onvif.h:385 */
class _tmd__GetSerialPortConfigurationResponse;	/* onvif.h:388 */
class _tmd__SetSerialPortConfiguration;	/* onvif.h:391 */
class _tmd__SetSerialPortConfigurationResponse;	/* onvif.h:394 */
class _tmd__GetSerialPortConfigurationOptions;	/* onvif.h:397 */
class _tmd__GetSerialPortConfigurationOptionsResponse;	/* onvif.h:400 */
class _tmd__SendReceiveSerialCommand;	/* onvif.h:403 */
class _tmd__SendReceiveSerialCommandResponse;	/* onvif.h:406 */
class _tds__Service_Capabilities;	/* onvif.h:5470 */
class tds__Service;	/* onvif.h:409 */
class tds__DeviceServiceCapabilities;	/* onvif.h:412 */
class tds__NetworkCapabilities;	/* onvif.h:415 */
class tds__SecurityCapabilities;	/* onvif.h:418 */
class tds__SystemCapabilities;	/* onvif.h:421 */
class tds__MiscCapabilities;	/* onvif.h:424 */
class _tds__UserCredential_Extension;	/* onvif.h:5878 */
class tds__UserCredential;	/* onvif.h:427 */
class _tds__StorageConfigurationData_Extension;	/* onvif.h:5930 */
class tds__StorageConfigurationData;	/* onvif.h:430 */
class _tds__GetServices;	/* onvif.h:436 */
class _tds__GetServicesResponse;	/* onvif.h:439 */
class _tds__GetServiceCapabilities;	/* onvif.h:442 */
class _tds__GetServiceCapabilitiesResponse;	/* onvif.h:445 */
class _tds__GetDeviceInformation;	/* onvif.h:448 */
class _tds__GetDeviceInformationResponse;	/* onvif.h:451 */
class _tds__SetSystemDateAndTime;	/* onvif.h:454 */
class _tds__SetSystemDateAndTimeResponse;	/* onvif.h:457 */
class _tds__GetSystemDateAndTime;	/* onvif.h:460 */
class _tds__GetSystemDateAndTimeResponse;	/* onvif.h:463 */
class _tds__SetSystemFactoryDefault;	/* onvif.h:466 */
class _tds__SetSystemFactoryDefaultResponse;	/* onvif.h:469 */
class _tds__UpgradeSystemFirmware;	/* onvif.h:472 */
class _tds__UpgradeSystemFirmwareResponse;	/* onvif.h:475 */
class _tds__SystemReboot;	/* onvif.h:478 */
class _tds__SystemRebootResponse;	/* onvif.h:481 */
class _tds__RestoreSystem;	/* onvif.h:484 */
class _tds__RestoreSystemResponse;	/* onvif.h:487 */
class _tds__GetSystemBackup;	/* onvif.h:490 */
class _tds__GetSystemBackupResponse;	/* onvif.h:493 */
class _tds__GetSystemSupportInformation;	/* onvif.h:496 */
class _tds__GetSystemSupportInformationResponse;	/* onvif.h:499 */
class _tds__GetSystemLog;	/* onvif.h:502 */
class _tds__GetSystemLogResponse;	/* onvif.h:505 */
class _tds__GetScopes;	/* onvif.h:508 */
class _tds__GetScopesResponse;	/* onvif.h:511 */
class _tds__SetScopes;	/* onvif.h:514 */
class _tds__SetScopesResponse;	/* onvif.h:517 */
class _tds__AddScopes;	/* onvif.h:520 */
class _tds__AddScopesResponse;	/* onvif.h:523 */
class _tds__RemoveScopes;	/* onvif.h:526 */
class _tds__RemoveScopesResponse;	/* onvif.h:529 */
class _tds__GetDiscoveryMode;	/* onvif.h:532 */
class _tds__GetDiscoveryModeResponse;	/* onvif.h:535 */
class _tds__SetDiscoveryMode;	/* onvif.h:538 */
class _tds__SetDiscoveryModeResponse;	/* onvif.h:541 */
class _tds__GetRemoteDiscoveryMode;	/* onvif.h:544 */
class _tds__GetRemoteDiscoveryModeResponse;	/* onvif.h:547 */
class _tds__SetRemoteDiscoveryMode;	/* onvif.h:550 */
class _tds__SetRemoteDiscoveryModeResponse;	/* onvif.h:553 */
class _tds__GetDPAddresses;	/* onvif.h:556 */
class _tds__GetDPAddressesResponse;	/* onvif.h:559 */
class _tds__SetDPAddresses;	/* onvif.h:562 */
class _tds__SetDPAddressesResponse;	/* onvif.h:565 */
class _tds__GetEndpointReference;	/* onvif.h:568 */
class _tds__GetEndpointReferenceResponse;	/* onvif.h:571 */
class _tds__GetRemoteUser;	/* onvif.h:574 */
class _tds__GetRemoteUserResponse;	/* onvif.h:577 */
class _tds__SetRemoteUser;	/* onvif.h:580 */
class _tds__SetRemoteUserResponse;	/* onvif.h:583 */
class _tds__GetUsers;	/* onvif.h:586 */
class _tds__GetUsersResponse;	/* onvif.h:589 */
class _tds__CreateUsers;	/* onvif.h:592 */
class _tds__CreateUsersResponse;	/* onvif.h:595 */
class _tds__DeleteUsers;	/* onvif.h:598 */
class _tds__DeleteUsersResponse;	/* onvif.h:601 */
class _tds__SetUser;	/* onvif.h:604 */
class _tds__SetUserResponse;	/* onvif.h:607 */
class _tds__GetWsdlUrl;	/* onvif.h:610 */
class _tds__GetWsdlUrlResponse;	/* onvif.h:613 */
class _tds__GetCapabilities;	/* onvif.h:616 */
class _tds__GetCapabilitiesResponse;	/* onvif.h:619 */
class _tds__GetHostname;	/* onvif.h:622 */
class _tds__GetHostnameResponse;	/* onvif.h:625 */
class _tds__SetHostname;	/* onvif.h:628 */
class _tds__SetHostnameResponse;	/* onvif.h:631 */
class _tds__SetHostnameFromDHCP;	/* onvif.h:634 */
class _tds__SetHostnameFromDHCPResponse;	/* onvif.h:637 */
class _tds__GetDNS;	/* onvif.h:640 */
class _tds__GetDNSResponse;	/* onvif.h:643 */
class _tds__SetDNS;	/* onvif.h:646 */
class _tds__SetDNSResponse;	/* onvif.h:649 */
class _tds__GetNTP;	/* onvif.h:652 */
class _tds__GetNTPResponse;	/* onvif.h:655 */
class _tds__SetNTP;	/* onvif.h:658 */
class _tds__SetNTPResponse;	/* onvif.h:661 */
class _tds__GetDynamicDNS;	/* onvif.h:664 */
class _tds__GetDynamicDNSResponse;	/* onvif.h:667 */
class _tds__SetDynamicDNS;	/* onvif.h:670 */
class _tds__SetDynamicDNSResponse;	/* onvif.h:673 */
class _tds__GetNetworkInterfaces;	/* onvif.h:676 */
class _tds__GetNetworkInterfacesResponse;	/* onvif.h:679 */
class _tds__SetNetworkInterfaces;	/* onvif.h:682 */
class _tds__SetNetworkInterfacesResponse;	/* onvif.h:685 */
class _tds__GetNetworkProtocols;	/* onvif.h:688 */
class _tds__GetNetworkProtocolsResponse;	/* onvif.h:691 */
class _tds__SetNetworkProtocols;	/* onvif.h:694 */
class _tds__SetNetworkProtocolsResponse;	/* onvif.h:697 */
class _tds__GetNetworkDefaultGateway;	/* onvif.h:700 */
class _tds__GetNetworkDefaultGatewayResponse;	/* onvif.h:703 */
class _tds__SetNetworkDefaultGateway;	/* onvif.h:706 */
class _tds__SetNetworkDefaultGatewayResponse;	/* onvif.h:709 */
class _tds__GetZeroConfiguration;	/* onvif.h:712 */
class _tds__GetZeroConfigurationResponse;	/* onvif.h:715 */
class _tds__SetZeroConfiguration;	/* onvif.h:718 */
class _tds__SetZeroConfigurationResponse;	/* onvif.h:721 */
class _tds__GetIPAddressFilter;	/* onvif.h:724 */
class _tds__GetIPAddressFilterResponse;	/* onvif.h:727 */
class _tds__SetIPAddressFilter;	/* onvif.h:730 */
class _tds__SetIPAddressFilterResponse;	/* onvif.h:733 */
class _tds__AddIPAddressFilter;	/* onvif.h:736 */
class _tds__AddIPAddressFilterResponse;	/* onvif.h:739 */
class _tds__RemoveIPAddressFilter;	/* onvif.h:742 */
class _tds__RemoveIPAddressFilterResponse;	/* onvif.h:745 */
class _tds__GetAccessPolicy;	/* onvif.h:748 */
class _tds__GetAccessPolicyResponse;	/* onvif.h:751 */
class _tds__SetAccessPolicy;	/* onvif.h:754 */
class _tds__SetAccessPolicyResponse;	/* onvif.h:757 */
class _tds__CreateCertificate;	/* onvif.h:760 */
class _tds__CreateCertificateResponse;	/* onvif.h:763 */
class _tds__GetCertificates;	/* onvif.h:766 */
class _tds__GetCertificatesResponse;	/* onvif.h:769 */
class _tds__GetCertificatesStatus;	/* onvif.h:772 */
class _tds__GetCertificatesStatusResponse;	/* onvif.h:775 */
class _tds__SetCertificatesStatus;	/* onvif.h:778 */
class _tds__SetCertificatesStatusResponse;	/* onvif.h:781 */
class _tds__DeleteCertificates;	/* onvif.h:784 */
class _tds__DeleteCertificatesResponse;	/* onvif.h:787 */
class _tds__GetPkcs10Request;	/* onvif.h:790 */
class _tds__GetPkcs10RequestResponse;	/* onvif.h:793 */
class _tds__LoadCertificates;	/* onvif.h:796 */
class _tds__LoadCertificatesResponse;	/* onvif.h:799 */
class _tds__GetClientCertificateMode;	/* onvif.h:802 */
class _tds__GetClientCertificateModeResponse;	/* onvif.h:805 */
class _tds__SetClientCertificateMode;	/* onvif.h:808 */
class _tds__SetClientCertificateModeResponse;	/* onvif.h:811 */
class _tds__GetCACertificates;	/* onvif.h:814 */
class _tds__GetCACertificatesResponse;	/* onvif.h:817 */
class _tds__LoadCertificateWithPrivateKey;	/* onvif.h:820 */
class _tds__LoadCertificateWithPrivateKeyResponse;	/* onvif.h:823 */
class _tds__GetCertificateInformation;	/* onvif.h:826 */
class _tds__GetCertificateInformationResponse;	/* onvif.h:829 */
class _tds__LoadCACertificates;	/* onvif.h:832 */
class _tds__LoadCACertificatesResponse;	/* onvif.h:835 */
class _tds__CreateDot1XConfiguration;	/* onvif.h:838 */
class _tds__CreateDot1XConfigurationResponse;	/* onvif.h:841 */
class _tds__SetDot1XConfiguration;	/* onvif.h:844 */
class _tds__SetDot1XConfigurationResponse;	/* onvif.h:847 */
class _tds__GetDot1XConfiguration;	/* onvif.h:850 */
class _tds__GetDot1XConfigurationResponse;	/* onvif.h:853 */
class _tds__GetDot1XConfigurations;	/* onvif.h:856 */
class _tds__GetDot1XConfigurationsResponse;	/* onvif.h:859 */
class _tds__DeleteDot1XConfiguration;	/* onvif.h:862 */
class _tds__DeleteDot1XConfigurationResponse;	/* onvif.h:865 */
class _tds__GetRelayOutputs;	/* onvif.h:868 */
class _tds__GetRelayOutputsResponse;	/* onvif.h:871 */
class _tds__SetRelayOutputSettings;	/* onvif.h:874 */
class _tds__SetRelayOutputSettingsResponse;	/* onvif.h:877 */
class _tds__SetRelayOutputState;	/* onvif.h:880 */
class _tds__SetRelayOutputStateResponse;	/* onvif.h:883 */
class _tds__SendAuxiliaryCommand;	/* onvif.h:886 */
class _tds__SendAuxiliaryCommandResponse;	/* onvif.h:889 */
class _tds__GetDot11Capabilities;	/* onvif.h:892 */
class _tds__GetDot11CapabilitiesResponse;	/* onvif.h:895 */
class _tds__GetDot11Status;	/* onvif.h:898 */
class _tds__GetDot11StatusResponse;	/* onvif.h:901 */
class _tds__ScanAvailableDot11Networks;	/* onvif.h:904 */
class _tds__ScanAvailableDot11NetworksResponse;	/* onvif.h:907 */
class _tds__GetSystemUris;	/* onvif.h:910 */
class _tds__GetSystemUrisResponse_Extension;	/* onvif.h:9482 */
class _tds__GetSystemUrisResponse;	/* onvif.h:913 */
class _tds__StartFirmwareUpgrade;	/* onvif.h:916 */
class _tds__StartFirmwareUpgradeResponse;	/* onvif.h:919 */
class _tds__StartSystemRestore;	/* onvif.h:922 */
class _tds__StartSystemRestoreResponse;	/* onvif.h:925 */
class _tds__GetStorageConfigurations;	/* onvif.h:928 */
class _tds__GetStorageConfigurationsResponse;	/* onvif.h:931 */
class _tds__CreateStorageConfiguration;	/* onvif.h:934 */
class _tds__CreateStorageConfigurationResponse;	/* onvif.h:937 */
class _tds__GetStorageConfiguration;	/* onvif.h:940 */
class _tds__GetStorageConfigurationResponse;	/* onvif.h:943 */
class _tds__SetStorageConfiguration;	/* onvif.h:946 */
class _tds__SetStorageConfigurationResponse;	/* onvif.h:949 */
class _tds__DeleteStorageConfiguration;	/* onvif.h:952 */
class _tds__DeleteStorageConfigurationResponse;	/* onvif.h:955 */
class _tds__GetGeoLocation;	/* onvif.h:958 */
class _tds__GetGeoLocationResponse;	/* onvif.h:961 */
class _tds__SetGeoLocation;	/* onvif.h:964 */
class _tds__SetGeoLocationResponse;	/* onvif.h:967 */
class _tds__DeleteGeoLocation;	/* onvif.h:970 */
class _tds__DeleteGeoLocationResponse;	/* onvif.h:973 */
class tt__DeviceEntity;	/* onvif.h:976 */
class tt__IntRectangle;	/* onvif.h:979 */
class tt__IntRectangleRange;	/* onvif.h:982 */
class tt__IntRange;	/* onvif.h:985 */
class tt__FloatRange;	/* onvif.h:988 */
class tt__DurationRange;	/* onvif.h:991 */
class tt__IntList;	/* onvif.h:994 */
class tt__FloatList;	/* onvif.h:997 */
class tt__AnyHolder;	/* onvif.h:1000 */
class tt__VideoSourceExtension;	/* onvif.h:1006 */
class tt__VideoSourceExtension2;	/* onvif.h:1009 */
class tt__Profile;	/* onvif.h:1015 */
class tt__ProfileExtension;	/* onvif.h:1018 */
class tt__ProfileExtension2;	/* onvif.h:1021 */
class tt__ConfigurationEntity;	/* onvif.h:1024 */
class tt__VideoSourceConfigurationExtension;	/* onvif.h:1030 */
class tt__VideoSourceConfigurationExtension2;	/* onvif.h:1033 */
class tt__Rotate;	/* onvif.h:1036 */
class tt__RotateExtension;	/* onvif.h:1039 */
class tt__LensProjection;	/* onvif.h:1042 */
class tt__LensOffset;	/* onvif.h:1045 */
class tt__LensDescription;	/* onvif.h:1048 */
class tt__VideoSourceConfigurationOptions;	/* onvif.h:1051 */
class tt__VideoSourceConfigurationOptionsExtension;	/* onvif.h:1054 */
class tt__VideoSourceConfigurationOptionsExtension2;	/* onvif.h:1057 */
class tt__RotateOptions;	/* onvif.h:1060 */
class tt__RotateOptionsExtension;	/* onvif.h:1063 */
class tt__SceneOrientation;	/* onvif.h:1066 */
class tt__VideoResolution;	/* onvif.h:1072 */
class tt__VideoRateControl;	/* onvif.h:1075 */
class tt__Mpeg4Configuration;	/* onvif.h:1078 */
class tt__H264Configuration;	/* onvif.h:1081 */
class tt__VideoEncoderConfigurationOptions;	/* onvif.h:1084 */
class tt__VideoEncoderOptionsExtension;	/* onvif.h:1087 */
class tt__VideoEncoderOptionsExtension2;	/* onvif.h:1090 */
class tt__JpegOptions;	/* onvif.h:1093 */
class tt__Mpeg4Options;	/* onvif.h:1099 */
class tt__H264Options;	/* onvif.h:1105 */
class tt__VideoResolution2;	/* onvif.h:1114 */
class tt__VideoRateControl2;	/* onvif.h:1117 */
class tt__VideoEncoder2ConfigurationOptions;	/* onvif.h:1120 */
class tt__AudioSourceConfigurationOptions;	/* onvif.h:1126 */
class tt__AudioSourceOptionsExtension;	/* onvif.h:1129 */
class tt__AudioEncoderConfigurationOptions;	/* onvif.h:1135 */
class tt__AudioEncoderConfigurationOption;	/* onvif.h:1138 */
class tt__AudioEncoder2ConfigurationOptions;	/* onvif.h:1144 */
class tt__MetadataConfigurationExtension;	/* onvif.h:1153 */
class tt__PTZFilter;	/* onvif.h:1156 */
class _tt__EventSubscription_SubscriptionPolicy;	/* onvif.h:11582 */
class tt__EventSubscription;	/* onvif.h:1159 */
class tt__MetadataConfigurationOptions;	/* onvif.h:1162 */
class tt__MetadataConfigurationOptionsExtension;	/* onvif.h:1165 */
class tt__MetadataConfigurationOptionsExtension2;	/* onvif.h:1168 */
class tt__PTZStatusFilterOptions;	/* onvif.h:1171 */
class tt__PTZStatusFilterOptionsExtension;	/* onvif.h:1174 */
class tt__VideoOutputExtension;	/* onvif.h:1180 */
class tt__VideoOutputConfigurationOptions;	/* onvif.h:1186 */
class tt__VideoDecoderConfigurationOptions;	/* onvif.h:1189 */
class tt__H264DecOptions;	/* onvif.h:1192 */
class tt__JpegDecOptions;	/* onvif.h:1195 */
class tt__Mpeg4DecOptions;	/* onvif.h:1198 */
class tt__VideoDecoderConfigurationOptionsExtension;	/* onvif.h:1201 */
class tt__AudioOutputConfigurationOptions;	/* onvif.h:1210 */
class tt__AudioDecoderConfigurationOptions;	/* onvif.h:1216 */
class tt__G711DecOptions;	/* onvif.h:1219 */
class tt__AACDecOptions;	/* onvif.h:1222 */
class tt__G726DecOptions;	/* onvif.h:1225 */
class tt__AudioDecoderConfigurationOptionsExtension;	/* onvif.h:1228 */
class tt__MulticastConfiguration;	/* onvif.h:1231 */
class tt__StreamSetup;	/* onvif.h:1234 */
class tt__Transport;	/* onvif.h:1237 */
class tt__MediaUri;	/* onvif.h:1240 */
class tt__Scope;	/* onvif.h:1243 */
class tt__NetworkInterfaceExtension;	/* onvif.h:1249 */
class tt__Dot3Configuration;	/* onvif.h:1252 */
class tt__NetworkInterfaceExtension2;	/* onvif.h:1255 */
class tt__NetworkInterfaceLink;	/* onvif.h:1258 */
class tt__NetworkInterfaceConnectionSetting;	/* onvif.h:1261 */
class tt__NetworkInterfaceInfo;	/* onvif.h:1264 */
class tt__IPv6NetworkInterface;	/* onvif.h:1267 */
class tt__IPv4NetworkInterface;	/* onvif.h:1270 */
class tt__IPv4Configuration;	/* onvif.h:1273 */
class tt__IPv6Configuration;	/* onvif.h:1276 */
class tt__IPv6ConfigurationExtension;	/* onvif.h:1279 */
class tt__NetworkProtocol;	/* onvif.h:1282 */
class tt__NetworkProtocolExtension;	/* onvif.h:1285 */
class tt__NetworkHost;	/* onvif.h:1288 */
class tt__NetworkHostExtension;	/* onvif.h:1291 */
class tt__IPAddress;	/* onvif.h:1294 */
class tt__PrefixedIPv4Address;	/* onvif.h:1297 */
class tt__PrefixedIPv6Address;	/* onvif.h:1300 */
class tt__HostnameInformation;	/* onvif.h:1303 */
class tt__HostnameInformationExtension;	/* onvif.h:1306 */
class tt__DNSInformation;	/* onvif.h:1309 */
class tt__DNSInformationExtension;	/* onvif.h:1312 */
class tt__NTPInformation;	/* onvif.h:1315 */
class tt__NTPInformationExtension;	/* onvif.h:1318 */
class tt__DynamicDNSInformation;	/* onvif.h:1321 */
class tt__DynamicDNSInformationExtension;	/* onvif.h:1324 */
class tt__NetworkInterfaceSetConfiguration;	/* onvif.h:1327 */
class tt__NetworkInterfaceSetConfigurationExtension;	/* onvif.h:1330 */
class tt__IPv6NetworkInterfaceSetConfiguration;	/* onvif.h:1333 */
class tt__IPv4NetworkInterfaceSetConfiguration;	/* onvif.h:1336 */
class tt__NetworkGateway;	/* onvif.h:1339 */
class tt__NetworkZeroConfiguration;	/* onvif.h:1342 */
class tt__NetworkZeroConfigurationExtension;	/* onvif.h:1345 */
class tt__NetworkZeroConfigurationExtension2;	/* onvif.h:1348 */
class tt__IPAddressFilter;	/* onvif.h:1351 */
class tt__IPAddressFilterExtension;	/* onvif.h:1354 */
class tt__Dot11Configuration;	/* onvif.h:1357 */
class tt__Dot11SecurityConfiguration;	/* onvif.h:1360 */
class tt__Dot11SecurityConfigurationExtension;	/* onvif.h:1363 */
class tt__Dot11PSKSet;	/* onvif.h:1366 */
class tt__Dot11PSKSetExtension;	/* onvif.h:1369 */
class tt__NetworkInterfaceSetConfigurationExtension2;	/* onvif.h:1372 */
class tt__Dot11Capabilities;	/* onvif.h:1375 */
class tt__Dot11Status;	/* onvif.h:1378 */
class tt__Dot11AvailableNetworks;	/* onvif.h:1381 */
class tt__Dot11AvailableNetworksExtension;	/* onvif.h:1384 */
class tt__Capabilities;	/* onvif.h:1387 */
class tt__CapabilitiesExtension;	/* onvif.h:1390 */
class tt__CapabilitiesExtension2;	/* onvif.h:1393 */
class tt__AnalyticsCapabilities;	/* onvif.h:1396 */
class tt__DeviceCapabilities;	/* onvif.h:1399 */
class tt__DeviceCapabilitiesExtension;	/* onvif.h:1402 */
class tt__EventCapabilities;	/* onvif.h:1405 */
class tt__IOCapabilities;	/* onvif.h:1408 */
class tt__IOCapabilitiesExtension;	/* onvif.h:1411 */
class tt__IOCapabilitiesExtension2;	/* onvif.h:1414 */
class tt__MediaCapabilities;	/* onvif.h:1417 */
class tt__MediaCapabilitiesExtension;	/* onvif.h:1420 */
class tt__RealTimeStreamingCapabilities;	/* onvif.h:1423 */
class tt__RealTimeStreamingCapabilitiesExtension;	/* onvif.h:1426 */
class tt__ProfileCapabilities;	/* onvif.h:1429 */
class tt__NetworkCapabilities;	/* onvif.h:1432 */
class tt__NetworkCapabilitiesExtension;	/* onvif.h:1435 */
class tt__NetworkCapabilitiesExtension2;	/* onvif.h:1438 */
class tt__SecurityCapabilities;	/* onvif.h:1441 */
class tt__SecurityCapabilitiesExtension;	/* onvif.h:1444 */
class tt__SecurityCapabilitiesExtension2;	/* onvif.h:1447 */
class tt__SystemCapabilities;	/* onvif.h:1450 */
class tt__SystemCapabilitiesExtension;	/* onvif.h:1453 */
class tt__SystemCapabilitiesExtension2;	/* onvif.h:1456 */
class tt__OnvifVersion;	/* onvif.h:1459 */
class tt__ImagingCapabilities;	/* onvif.h:1462 */
class tt__PTZCapabilities;	/* onvif.h:1465 */
class tt__DeviceIOCapabilities;	/* onvif.h:1468 */
class tt__DisplayCapabilities;	/* onvif.h:1471 */
class tt__RecordingCapabilities;	/* onvif.h:1474 */
class tt__SearchCapabilities;	/* onvif.h:1477 */
class tt__ReplayCapabilities;	/* onvif.h:1480 */
class tt__ReceiverCapabilities;	/* onvif.h:1483 */
class tt__AnalyticsDeviceCapabilities;	/* onvif.h:1486 */
class tt__AnalyticsDeviceExtension;	/* onvif.h:1489 */
class tt__SystemLog;	/* onvif.h:1492 */
class tt__SupportInformation;	/* onvif.h:1495 */
class tt__BinaryData;	/* onvif.h:1498 */
class tt__AttachmentData;	/* onvif.h:1501 */
class tt__BackupFile;	/* onvif.h:1504 */
class tt__SystemLogUriList;	/* onvif.h:1507 */
class tt__SystemLogUri;	/* onvif.h:1510 */
class tt__SystemDateTime;	/* onvif.h:1513 */
class tt__SystemDateTimeExtension;	/* onvif.h:1516 */
class tt__DateTime;	/* onvif.h:1519 */
class tt__Date;	/* onvif.h:1522 */
class tt__Time;	/* onvif.h:1525 */
class tt__TimeZone;	/* onvif.h:1528 */
class tt__GeoLocation;	/* onvif.h:1531 */
class tt__GeoOrientation;	/* onvif.h:1534 */
class tt__LocalLocation;	/* onvif.h:1537 */
class tt__LocalOrientation;	/* onvif.h:1540 */
class tt__LocationEntity;	/* onvif.h:1543 */
class tt__RemoteUser;	/* onvif.h:1546 */
class tt__User;	/* onvif.h:1549 */
class tt__UserExtension;	/* onvif.h:1552 */
class tt__CertificateGenerationParameters;	/* onvif.h:1555 */
class tt__CertificateGenerationParametersExtension;	/* onvif.h:1558 */
class tt__Certificate;	/* onvif.h:1561 */
class tt__CertificateStatus;	/* onvif.h:1564 */
class tt__CertificateWithPrivateKey;	/* onvif.h:1567 */
class tt__CertificateInformation;	/* onvif.h:1570 */
class tt__CertificateInformationExtension;	/* onvif.h:1576 */
class tt__Dot1XConfiguration;	/* onvif.h:1579 */
class tt__Dot1XConfigurationExtension;	/* onvif.h:1582 */
class tt__EAPMethodConfiguration;	/* onvif.h:1585 */
class tt__EapMethodExtension;	/* onvif.h:1588 */
class tt__TLSConfiguration;	/* onvif.h:1591 */
class tt__GenericEapPwdConfigurationExtension;	/* onvif.h:1594 */
class tt__RelayOutputSettings;	/* onvif.h:1597 */
class tt__PTZNodeExtension;	/* onvif.h:1609 */
class tt__PTZNodeExtension2;	/* onvif.h:1612 */
class tt__PTZPresetTourSupported;	/* onvif.h:1615 */
class tt__PTZPresetTourSupportedExtension;	/* onvif.h:1618 */
class tt__PTZConfigurationExtension;	/* onvif.h:1624 */
class tt__PTZConfigurationExtension2;	/* onvif.h:1627 */
class tt__PTControlDirection;	/* onvif.h:1630 */
class tt__PTControlDirectionExtension;	/* onvif.h:1633 */
class tt__EFlip;	/* onvif.h:1636 */
class tt__Reverse;	/* onvif.h:1639 */
class tt__PTZConfigurationOptions;	/* onvif.h:1642 */
class tt__PTZConfigurationOptions2;	/* onvif.h:1645 */
class tt__PTControlDirectionOptions;	/* onvif.h:1648 */
class tt__PTControlDirectionOptionsExtension;	/* onvif.h:1651 */
class tt__EFlipOptions;	/* onvif.h:1654 */
class tt__EFlipOptionsExtension;	/* onvif.h:1657 */
class tt__ReverseOptions;	/* onvif.h:1660 */
class tt__ReverseOptionsExtension;	/* onvif.h:1663 */
class tt__PanTiltLimits;	/* onvif.h:1666 */
class tt__ZoomLimits;	/* onvif.h:1669 */
class tt__PTZSpaces;	/* onvif.h:1672 */
class tt__PTZSpacesExtension;	/* onvif.h:1675 */
class tt__Space2DDescription;	/* onvif.h:1678 */
class tt__Space1DDescription;	/* onvif.h:1681 */
class tt__PTZSpeed;	/* onvif.h:1684 */
class tt__PTZPreset;	/* onvif.h:1687 */
class tt__PresetTour;	/* onvif.h:1690 */
class tt__PTZPresetTourExtension;	/* onvif.h:1693 */
class tt__PTZPresetTourSpot;	/* onvif.h:1696 */
class tt__PTZPresetTourSpotExtension;	/* onvif.h:1699 */
union _tt__union_PTZPresetTourPresetDetail;	/* onvif.h:17357 */
class tt__PTZPresetTourPresetDetail;	/* onvif.h:1702 */
class tt__PTZPresetTourTypeExtension;	/* onvif.h:1705 */
class tt__PTZPresetTourStatus;	/* onvif.h:1708 */
class tt__PTZPresetTourStatusExtension;	/* onvif.h:1711 */
class tt__PTZPresetTourStartingCondition;	/* onvif.h:1714 */
class tt__PTZPresetTourStartingConditionExtension;	/* onvif.h:1717 */
class tt__PTZPresetTourOptions;	/* onvif.h:1720 */
class tt__PTZPresetTourSpotOptions;	/* onvif.h:1723 */
class tt__PTZPresetTourPresetDetailOptions;	/* onvif.h:1726 */
class tt__PTZPresetTourPresetDetailOptionsExtension;	/* onvif.h:1729 */
class tt__PTZPresetTourStartingConditionOptions;	/* onvif.h:1732 */
class tt__PTZPresetTourStartingConditionOptionsExtension;	/* onvif.h:1735 */
class tt__ImagingStatus;	/* onvif.h:1738 */
class tt__FocusStatus;	/* onvif.h:1741 */
class tt__FocusConfiguration;	/* onvif.h:1744 */
class tt__ImagingSettings;	/* onvif.h:1747 */
class tt__ImagingSettingsExtension;	/* onvif.h:1750 */
class tt__Exposure;	/* onvif.h:1753 */
class tt__WideDynamicRange;	/* onvif.h:1756 */
class tt__BacklightCompensation;	/* onvif.h:1759 */
class tt__ImagingOptions;	/* onvif.h:1762 */
class tt__WideDynamicRangeOptions;	/* onvif.h:1765 */
class tt__BacklightCompensationOptions;	/* onvif.h:1768 */
class tt__FocusOptions;	/* onvif.h:1771 */
class tt__ExposureOptions;	/* onvif.h:1774 */
class tt__WhiteBalanceOptions;	/* onvif.h:1777 */
class tt__FocusMove;	/* onvif.h:1780 */
class tt__AbsoluteFocus;	/* onvif.h:1783 */
class tt__RelativeFocus;	/* onvif.h:1786 */
class tt__ContinuousFocus;	/* onvif.h:1789 */
class tt__MoveOptions;	/* onvif.h:1792 */
class tt__AbsoluteFocusOptions;	/* onvif.h:1795 */
class tt__RelativeFocusOptions;	/* onvif.h:1798 */
class tt__ContinuousFocusOptions;	/* onvif.h:1801 */
class tt__WhiteBalance;	/* onvif.h:1804 */
class tt__ImagingStatus20;	/* onvif.h:1807 */
class tt__ImagingStatus20Extension;	/* onvif.h:1810 */
class tt__FocusStatus20;	/* onvif.h:1813 */
class tt__FocusStatus20Extension;	/* onvif.h:1816 */
class tt__ImagingSettings20;	/* onvif.h:1819 */
class tt__ImagingSettingsExtension20;	/* onvif.h:1822 */
class tt__ImagingSettingsExtension202;	/* onvif.h:1825 */
class tt__ImagingSettingsExtension203;	/* onvif.h:1828 */
class tt__ImagingSettingsExtension204;	/* onvif.h:1831 */
class tt__ImageStabilization;	/* onvif.h:1834 */
class tt__ImageStabilizationExtension;	/* onvif.h:1837 */
class tt__IrCutFilterAutoAdjustment;	/* onvif.h:1840 */
class tt__IrCutFilterAutoAdjustmentExtension;	/* onvif.h:1843 */
class tt__WideDynamicRange20;	/* onvif.h:1846 */
class tt__BacklightCompensation20;	/* onvif.h:1849 */
class tt__Exposure20;	/* onvif.h:1852 */
class tt__ToneCompensation;	/* onvif.h:1855 */
class tt__ToneCompensationExtension;	/* onvif.h:1858 */
class tt__Defogging;	/* onvif.h:1861 */
class tt__DefoggingExtension;	/* onvif.h:1864 */
class tt__NoiseReduction;	/* onvif.h:1867 */
class tt__ImagingOptions20;	/* onvif.h:1870 */
class tt__ImagingOptions20Extension;	/* onvif.h:1873 */
class tt__ImagingOptions20Extension2;	/* onvif.h:1876 */
class tt__ImagingOptions20Extension3;	/* onvif.h:1879 */
class tt__ImagingOptions20Extension4;	/* onvif.h:1882 */
class tt__ImageStabilizationOptions;	/* onvif.h:1885 */
class tt__ImageStabilizationOptionsExtension;	/* onvif.h:1888 */
class tt__IrCutFilterAutoAdjustmentOptions;	/* onvif.h:1891 */
class tt__IrCutFilterAutoAdjustmentOptionsExtension;	/* onvif.h:1894 */
class tt__WideDynamicRangeOptions20;	/* onvif.h:1897 */
class tt__BacklightCompensationOptions20;	/* onvif.h:1900 */
class tt__ExposureOptions20;	/* onvif.h:1903 */
class tt__MoveOptions20;	/* onvif.h:1906 */
class tt__RelativeFocusOptions20;	/* onvif.h:1909 */
class tt__WhiteBalance20;	/* onvif.h:1912 */
class tt__WhiteBalance20Extension;	/* onvif.h:1915 */
class tt__FocusConfiguration20;	/* onvif.h:1918 */
class tt__FocusConfiguration20Extension;	/* onvif.h:1921 */
class tt__WhiteBalanceOptions20;	/* onvif.h:1924 */
class tt__WhiteBalanceOptions20Extension;	/* onvif.h:1927 */
class tt__FocusOptions20;	/* onvif.h:1930 */
class tt__FocusOptions20Extension;	/* onvif.h:1933 */
class tt__ToneCompensationOptions;	/* onvif.h:1936 */
class tt__DefoggingOptions;	/* onvif.h:1939 */
class tt__NoiseReductionOptions;	/* onvif.h:1942 */
class tt__MessageExtension;	/* onvif.h:1945 */
class _tt__ItemList_SimpleItem;	/* onvif.h:20178 */
class _tt__ItemList_ElementItem;	/* onvif.h:20206 */
class tt__ItemList;	/* onvif.h:1948 */
class tt__ItemListExtension;	/* onvif.h:1951 */
class tt__MessageDescription;	/* onvif.h:1954 */
class tt__MessageDescriptionExtension;	/* onvif.h:1957 */
class _tt__ItemListDescription_SimpleItemDescription;	/* onvif.h:20359 */
class _tt__ItemListDescription_ElementItemDescription;	/* onvif.h:20384 */
class tt__ItemListDescription;	/* onvif.h:1960 */
class tt__ItemListDescriptionExtension;	/* onvif.h:1963 */
class tt__Polyline;	/* onvif.h:1966 */
class tt__AnalyticsEngineConfiguration;	/* onvif.h:1969 */
class tt__AnalyticsEngineConfigurationExtension;	/* onvif.h:1972 */
class tt__RuleEngineConfiguration;	/* onvif.h:1975 */
class tt__RuleEngineConfigurationExtension;	/* onvif.h:1978 */
class tt__Config;	/* onvif.h:1981 */
class _tt__ConfigDescription_Messages;	/* onvif.h:20626 */
class tt__ConfigDescription;	/* onvif.h:1984 */
class tt__ConfigDescriptionExtension;	/* onvif.h:1987 */
class tt__SupportedRules;	/* onvif.h:1990 */
class tt__SupportedRulesExtension;	/* onvif.h:1993 */
class tt__SupportedAnalyticsModules;	/* onvif.h:1996 */
class tt__SupportedAnalyticsModulesExtension;	/* onvif.h:1999 */
class tt__PolygonConfiguration;	/* onvif.h:2002 */
class tt__PolylineArray;	/* onvif.h:2005 */
class tt__PolylineArrayExtension;	/* onvif.h:2008 */
class tt__PolylineArrayConfiguration;	/* onvif.h:2011 */
class tt__MotionExpression;	/* onvif.h:2014 */
class tt__MotionExpressionConfiguration;	/* onvif.h:2017 */
class tt__CellLayout;	/* onvif.h:2020 */
class tt__PaneConfiguration;	/* onvif.h:2023 */
class tt__PaneLayout;	/* onvif.h:2026 */
class tt__Layout;	/* onvif.h:2029 */
class tt__LayoutExtension;	/* onvif.h:2032 */
class tt__CodingCapabilities;	/* onvif.h:2035 */
class tt__LayoutOptions;	/* onvif.h:2038 */
class tt__LayoutOptionsExtension;	/* onvif.h:2041 */
class tt__PaneLayoutOptions;	/* onvif.h:2044 */
class tt__PaneOptionExtension;	/* onvif.h:2047 */
class tt__Receiver;	/* onvif.h:2050 */
class tt__ReceiverConfiguration;	/* onvif.h:2053 */
class tt__ReceiverStateInformation;	/* onvif.h:2056 */
class tt__SourceReference;	/* onvif.h:2059 */
class tt__DateTimeRange;	/* onvif.h:2062 */
class tt__RecordingSummary;	/* onvif.h:2065 */
class tt__SearchScope;	/* onvif.h:2068 */
class tt__SearchScopeExtension;	/* onvif.h:2071 */
class tt__PTZPositionFilter;	/* onvif.h:2077 */
class tt__MetadataFilter;	/* onvif.h:2080 */
class tt__FindRecordingResultList;	/* onvif.h:2083 */
class tt__FindEventResultList;	/* onvif.h:2086 */
class tt__FindEventResult;	/* onvif.h:2089 */
class tt__FindPTZPositionResultList;	/* onvif.h:2092 */
class tt__FindPTZPositionResult;	/* onvif.h:2095 */
class tt__FindMetadataResultList;	/* onvif.h:2098 */
class tt__FindMetadataResult;	/* onvif.h:2101 */
class tt__RecordingInformation;	/* onvif.h:2104 */
class tt__RecordingSourceInformation;	/* onvif.h:2107 */
class tt__TrackInformation;	/* onvif.h:2110 */
class tt__MediaAttributes;	/* onvif.h:2113 */
class tt__TrackAttributes;	/* onvif.h:2116 */
class tt__TrackAttributesExtension;	/* onvif.h:2119 */
class tt__VideoAttributes;	/* onvif.h:2122 */
class tt__AudioAttributes;	/* onvif.h:2125 */
class tt__MetadataAttributes;	/* onvif.h:2128 */
class tt__RecordingConfiguration;	/* onvif.h:2131 */
class tt__TrackConfiguration;	/* onvif.h:2134 */
class tt__GetRecordingsResponseItem;	/* onvif.h:2137 */
class tt__GetTracksResponseList;	/* onvif.h:2140 */
class tt__GetTracksResponseItem;	/* onvif.h:2143 */
class tt__RecordingJobConfiguration;	/* onvif.h:2146 */
class tt__RecordingJobConfigurationExtension;	/* onvif.h:2149 */
class tt__RecordingJobSource;	/* onvif.h:2152 */
class tt__RecordingJobSourceExtension;	/* onvif.h:2155 */
class tt__RecordingJobTrack;	/* onvif.h:2158 */
class tt__RecordingJobStateInformation;	/* onvif.h:2161 */
class tt__RecordingJobStateInformationExtension;	/* onvif.h:2164 */
class tt__RecordingJobStateSource;	/* onvif.h:2167 */
class tt__RecordingJobStateTracks;	/* onvif.h:2170 */
class tt__RecordingJobStateTrack;	/* onvif.h:2173 */
class tt__GetRecordingJobsResponseItem;	/* onvif.h:2176 */
class tt__ReplayConfiguration;	/* onvif.h:2179 */
class tt__AnalyticsDeviceEngineConfiguration;	/* onvif.h:2185 */
class tt__AnalyticsDeviceEngineConfigurationExtension;	/* onvif.h:2188 */
class tt__EngineConfiguration;	/* onvif.h:2191 */
class tt__AnalyticsEngineInputInfo;	/* onvif.h:2194 */
class tt__AnalyticsEngineInputInfoExtension;	/* onvif.h:2197 */
class tt__SourceIdentification;	/* onvif.h:2203 */
class tt__SourceIdentificationExtension;	/* onvif.h:2206 */
class tt__MetadataInput;	/* onvif.h:2209 */
class tt__MetadataInputExtension;	/* onvif.h:2212 */
class tt__AnalyticsStateInformation;	/* onvif.h:2218 */
class tt__AnalyticsState;	/* onvif.h:2221 */
class tt__ActionEngineEventPayload;	/* onvif.h:2224 */
class tt__ActionEngineEventPayloadExtension;	/* onvif.h:2227 */
class tt__AudioClassCandidate;	/* onvif.h:2230 */
class tt__AudioClassDescriptor;	/* onvif.h:2233 */
class tt__AudioClassDescriptorExtension;	/* onvif.h:2236 */
class tt__ActiveConnection;	/* onvif.h:2239 */
class tt__ProfileStatus;	/* onvif.h:2242 */
class tt__ProfileStatusExtension;	/* onvif.h:2245 */
class tt__OSDPosConfiguration;	/* onvif.h:2251 */
class tt__OSDPosConfigurationExtension;	/* onvif.h:2254 */
class tt__OSDColor;	/* onvif.h:2257 */
class tt__OSDTextConfiguration;	/* onvif.h:2260 */
class tt__OSDTextConfigurationExtension;	/* onvif.h:2263 */
class tt__OSDImgConfiguration;	/* onvif.h:2266 */
class tt__OSDImgConfigurationExtension;	/* onvif.h:2269 */
class tt__ColorspaceRange;	/* onvif.h:2272 */
union _tt__union_ColorOptions;	/* onvif.h:23986 */
class tt__ColorOptions;	/* onvif.h:2275 */
class tt__OSDColorOptions;	/* onvif.h:2278 */
class tt__OSDColorOptionsExtension;	/* onvif.h:2281 */
class tt__OSDTextOptions;	/* onvif.h:2284 */
class tt__OSDTextOptionsExtension;	/* onvif.h:2287 */
class tt__OSDImgOptions;	/* onvif.h:2290 */
class tt__OSDImgOptionsExtension;	/* onvif.h:2293 */
class tt__OSDConfigurationExtension;	/* onvif.h:2299 */
class tt__MaximumNumberOfOSDs;	/* onvif.h:2302 */
class tt__OSDConfigurationOptions;	/* onvif.h:2305 */
class tt__OSDConfigurationOptionsExtension;	/* onvif.h:2308 */
class tt__FileProgress;	/* onvif.h:2311 */
class tt__ArrayOfFileProgress;	/* onvif.h:2314 */
class tt__ArrayOfFileProgressExtension;	/* onvif.h:2317 */
class tt__StorageReferencePath;	/* onvif.h:2320 */
class tt__StorageReferencePathExtension;	/* onvif.h:2323 */
class tt__Vector2D;	/* onvif.h:2326 */
class tt__Vector1D;	/* onvif.h:2329 */
class tt__PTZVector;	/* onvif.h:2332 */
class tt__PTZStatus;	/* onvif.h:2335 */
class tt__PTZMoveStatus;	/* onvif.h:2338 */
class tt__Vector;	/* onvif.h:2341 */
class tt__Rectangle;	/* onvif.h:2344 */
class tt__Polygon;	/* onvif.h:2347 */
class tt__Color;	/* onvif.h:2350 */
class tt__ColorCovariance;	/* onvif.h:2353 */
class tt__Transformation;	/* onvif.h:2356 */
class tt__TransformationExtension;	/* onvif.h:2359 */
class _tt__Message;	/* onvif.h:2362 */
class wsnt__QueryExpressionType;	/* onvif.h:2365 */
class wsnt__TopicExpressionType;	/* onvif.h:2368 */
class wsnt__FilterType;	/* onvif.h:2371 */
class wsnt__SubscriptionPolicyType;	/* onvif.h:2374 */
class _wsnt__NotificationMessageHolderType_Message;	/* onvif.h:25056 */
class wsnt__NotificationMessageHolderType;	/* onvif.h:2377 */
class _wsnt__NotificationProducerRP;	/* onvif.h:2440 */
class _wsnt__SubscriptionManagerRP;	/* onvif.h:2443 */
class _wsnt__Notify;	/* onvif.h:2446 */
class _wsnt__UseRaw;	/* onvif.h:2449 */
class _wsnt__Subscribe_SubscriptionPolicy;	/* onvif.h:25200 */
class _wsnt__Subscribe;	/* onvif.h:2452 */
class _wsnt__SubscribeResponse;	/* onvif.h:2455 */
class _wsnt__GetCurrentMessage;	/* onvif.h:2458 */
class _wsnt__GetCurrentMessageResponse;	/* onvif.h:2461 */
class _wsnt__GetMessages;	/* onvif.h:2464 */
class _wsnt__GetMessagesResponse;	/* onvif.h:2467 */
class _wsnt__DestroyPullPoint;	/* onvif.h:2470 */
class _wsnt__DestroyPullPointResponse;	/* onvif.h:2473 */
class _wsnt__CreatePullPoint;	/* onvif.h:2476 */
class _wsnt__CreatePullPointResponse;	/* onvif.h:2479 */
class _wsnt__Renew;	/* onvif.h:2482 */
class _wsnt__RenewResponse;	/* onvif.h:2485 */
class _wsnt__Unsubscribe;	/* onvif.h:2488 */
class _wsnt__UnsubscribeResponse;	/* onvif.h:2491 */
class _wsnt__PauseSubscription;	/* onvif.h:2494 */
class _wsnt__PauseSubscriptionResponse;	/* onvif.h:2497 */
class _wsnt__ResumeSubscription;	/* onvif.h:2500 */
class _wsnt__ResumeSubscriptionResponse;	/* onvif.h:2503 */
class _wsrfbf__BaseFaultType_ErrorCode;	/* onvif.h:25736 */
class _wsrfbf__BaseFaultType_Description;	/* onvif.h:25757 */
class _wsrfbf__BaseFaultType_FaultCause;	/* onvif.h:25774 */
class wsrfbf__BaseFaultType;	/* onvif.h:2506 */
class wstop__Documentation;	/* onvif.h:2509 */
class wstop__ExtensibleDocumented;	/* onvif.h:2512 */
class wstop__QueryExpressionType;	/* onvif.h:2515 */
class tls__Capabilities;	/* onvif.h:2527 */
class _tls__GetServiceCapabilities;	/* onvif.h:2530 */
class _tls__GetServiceCapabilitiesResponse;	/* onvif.h:2533 */
class _tls__GetLayout;	/* onvif.h:2536 */
class _tls__GetLayoutResponse;	/* onvif.h:2539 */
class _tls__SetLayout;	/* onvif.h:2542 */
class _tls__SetLayoutResponse;	/* onvif.h:2545 */
class _tls__GetDisplayOptions;	/* onvif.h:2548 */
class _tls__GetDisplayOptionsResponse;	/* onvif.h:2551 */
class _tls__GetPaneConfigurations;	/* onvif.h:2554 */
class _tls__GetPaneConfigurationsResponse;	/* onvif.h:2557 */
class _tls__GetPaneConfiguration;	/* onvif.h:2560 */
class _tls__GetPaneConfigurationResponse;	/* onvif.h:2563 */
class _tls__SetPaneConfigurations;	/* onvif.h:2566 */
class _tls__SetPaneConfigurationsResponse;	/* onvif.h:2569 */
class _tls__SetPaneConfiguration;	/* onvif.h:2572 */
class _tls__SetPaneConfigurationResponse;	/* onvif.h:2575 */
class _tls__CreatePaneConfiguration;	/* onvif.h:2578 */
class _tls__CreatePaneConfigurationResponse;	/* onvif.h:2581 */
class _tls__DeletePaneConfiguration;	/* onvif.h:2584 */
class _tls__DeletePaneConfigurationResponse;	/* onvif.h:2587 */
class tmd__SerialPort;	/* onvif.h:253 */
class tds__StorageConfiguration;	/* onvif.h:433 */
class tt__VideoSource;	/* onvif.h:1003 */
class tt__AudioSource;	/* onvif.h:1012 */
class tt__VideoSourceConfiguration;	/* onvif.h:1027 */
class tt__VideoEncoderConfiguration;	/* onvif.h:1069 */
class tt__JpegOptions2;	/* onvif.h:1096 */
class tt__Mpeg4Options2;	/* onvif.h:1102 */
class tt__H264Options2;	/* onvif.h:1108 */
class tt__VideoEncoder2Configuration;	/* onvif.h:1111 */
class tt__AudioSourceConfiguration;	/* onvif.h:1123 */
class tt__AudioEncoderConfiguration;	/* onvif.h:1132 */
class tt__AudioEncoder2Configuration;	/* onvif.h:1141 */
class tt__VideoAnalyticsConfiguration;	/* onvif.h:1147 */
class tt__MetadataConfiguration;	/* onvif.h:1150 */
class tt__VideoOutput;	/* onvif.h:1177 */
class tt__VideoOutputConfiguration;	/* onvif.h:1183 */
class tt__AudioOutput;	/* onvif.h:1204 */
class tt__AudioOutputConfiguration;	/* onvif.h:1207 */
class tt__AudioDecoderConfiguration;	/* onvif.h:1213 */
class tt__NetworkInterface;	/* onvif.h:1246 */
class tt__CertificateUsage;	/* onvif.h:1573 */
class tt__RelayOutput;	/* onvif.h:1600 */
class tt__DigitalInput;	/* onvif.h:1603 */
class tt__PTZNode;	/* onvif.h:1606 */
class tt__PTZConfiguration;	/* onvif.h:1621 */
class tt__EventFilter;	/* onvif.h:2074 */
class tt__AnalyticsEngine;	/* onvif.h:2182 */
class tt__AnalyticsEngineInput;	/* onvif.h:2200 */
class tt__AnalyticsEngineControl;	/* onvif.h:2215 */
class tt__OSDConfiguration;	/* onvif.h:2296 */
class wsnt__SubscribeCreationFailedFaultType;	/* onvif.h:2380 */
class wsnt__InvalidFilterFaultType;	/* onvif.h:2383 */
class wsnt__TopicExpressionDialectUnknownFaultType;	/* onvif.h:2386 */
class wsnt__InvalidTopicExpressionFaultType;	/* onvif.h:2389 */
class wsnt__TopicNotSupportedFaultType;	/* onvif.h:2392 */
class wsnt__MultipleTopicsSpecifiedFaultType;	/* onvif.h:2395 */
class wsnt__InvalidProducerPropertiesExpressionFaultType;	/* onvif.h:2398 */
class wsnt__InvalidMessageContentExpressionFaultType;	/* onvif.h:2401 */
class wsnt__UnrecognizedPolicyRequestFaultType;	/* onvif.h:2404 */
class wsnt__UnsupportedPolicyRequestFaultType;	/* onvif.h:2407 */
class wsnt__NotifyMessageNotSupportedFaultType;	/* onvif.h:2410 */
class wsnt__UnacceptableInitialTerminationTimeFaultType;	/* onvif.h:2413 */
class wsnt__NoCurrentMessageOnTopicFaultType;	/* onvif.h:2416 */
class wsnt__UnableToGetMessagesFaultType;	/* onvif.h:2419 */
class wsnt__UnableToDestroyPullPointFaultType;	/* onvif.h:2422 */
class wsnt__UnableToCreatePullPointFaultType;	/* onvif.h:2425 */
class wsnt__UnacceptableTerminationTimeFaultType;	/* onvif.h:2428 */
class wsnt__UnableToDestroySubscriptionFaultType;	/* onvif.h:2431 */
class wsnt__PauseFailedFaultType;	/* onvif.h:2434 */
class wsnt__ResumeFailedFaultType;	/* onvif.h:2437 */
class _wstop__TopicNamespaceType_Topic;	/* onvif.h:30039 */
class wstop__TopicNamespaceType;	/* onvif.h:2518 */
class wstop__TopicType;	/* onvif.h:2521 */
class wstop__TopicSetType;	/* onvif.h:2524 */
class tt__OSDReference;	/* onvif.h:2248 */
struct __tds__GetServices;	/* onvif.h:30894 */
struct __tds__GetServiceCapabilities;	/* onvif.h:30962 */
struct __tds__GetDeviceInformation;	/* onvif.h:31029 */
struct __tds__SetSystemDateAndTime;	/* onvif.h:31101 */
struct __tds__GetSystemDateAndTime;	/* onvif.h:31173 */
struct __tds__SetSystemFactoryDefault;	/* onvif.h:31240 */
struct __tds__UpgradeSystemFirmware;	/* onvif.h:31313 */
struct __tds__SystemReboot;	/* onvif.h:31380 */
struct __tds__RestoreSystem;	/* onvif.h:31455 */
struct __tds__GetSystemBackup;	/* onvif.h:31529 */
struct __tds__GetSystemLog;	/* onvif.h:31597 */
struct __tds__GetSystemSupportInformation;	/* onvif.h:31664 */
struct __tds__GetScopes;	/* onvif.h:31735 */
struct __tds__SetScopes;	/* onvif.h:31810 */
struct __tds__AddScopes;	/* onvif.h:31881 */
struct __tds__RemoveScopes;	/* onvif.h:31954 */
struct __tds__GetDiscoveryMode;	/* onvif.h:32025 */
struct __tds__SetDiscoveryMode;	/* onvif.h:32097 */
struct __tds__GetRemoteDiscoveryMode;	/* onvif.h:32170 */
struct __tds__SetRemoteDiscoveryMode;	/* onvif.h:32243 */
struct __tds__GetDPAddresses;	/* onvif.h:32314 */
struct __tds__GetEndpointReference;	/* onvif.h:32387 */
struct __tds__GetRemoteUser;	/* onvif.h:32458 */
struct __tds__SetRemoteUser;	/* onvif.h:32528 */
struct __tds__GetUsers;	/* onvif.h:32599 */
struct __tds__CreateUsers;	/* onvif.h:32672 */
struct __tds__DeleteUsers;	/* onvif.h:32746 */
struct __tds__SetUser;	/* onvif.h:32818 */
struct __tds__GetWsdlUrl;	/* onvif.h:32892 */
struct __tds__GetCapabilities;	/* onvif.h:32968 */
struct __tds__SetDPAddresses;	/* onvif.h:33040 */
struct __tds__GetHostname;	/* onvif.h:33110 */
struct __tds__SetHostname;	/* onvif.h:33179 */
struct __tds__SetHostnameFromDHCP;	/* onvif.h:33246 */
struct __tds__GetDNS;	/* onvif.h:33315 */
struct __tds__SetDNS;	/* onvif.h:33384 */
struct __tds__GetNTP;	/* onvif.h:33454 */
struct __tds__SetNTP;	/* onvif.h:33524 */
struct __tds__GetDynamicDNS;	/* onvif.h:33595 */
struct __tds__SetDynamicDNS;	/* onvif.h:33666 */
struct __tds__GetNetworkInterfaces;	/* onvif.h:33737 */
struct __tds__SetNetworkInterfaces;	/* onvif.h:33808 */
struct __tds__GetNetworkProtocols;	/* onvif.h:33878 */
struct __tds__SetNetworkProtocols;	/* onvif.h:33948 */
struct __tds__GetNetworkDefaultGateway;	/* onvif.h:34018 */
struct __tds__SetNetworkDefaultGateway;	/* onvif.h:34087 */
struct __tds__GetZeroConfiguration;	/* onvif.h:34159 */
struct __tds__SetZeroConfiguration;	/* onvif.h:34227 */
struct __tds__GetIPAddressFilter;	/* onvif.h:34298 */
struct __tds__SetIPAddressFilter;	/* onvif.h:34371 */
struct __tds__AddIPAddressFilter;	/* onvif.h:34443 */
struct __tds__RemoveIPAddressFilter;	/* onvif.h:34515 */
struct __tds__GetAccessPolicy;	/* onvif.h:34596 */
struct __tds__SetAccessPolicy;	/* onvif.h:34668 */
struct __tds__CreateCertificate;	/* onvif.h:34739 */
struct __tds__GetCertificates;	/* onvif.h:34818 */
struct __tds__GetCertificatesStatus;	/* onvif.h:34888 */
struct __tds__SetCertificatesStatus;	/* onvif.h:34960 */
struct __tds__DeleteCertificates;	/* onvif.h:35035 */
struct __tds__GetPkcs10Request;	/* onvif.h:35112 */
struct __tds__LoadCertificates;	/* onvif.h:35193 */
struct __tds__GetClientCertificateMode;	/* onvif.h:35263 */
struct __tds__SetClientCertificateMode;	/* onvif.h:35333 */
struct __tds__GetRelayOutputs;	/* onvif.h:35400 */
struct __tds__SetRelayOutputSettings;	/* onvif.h:35468 */
struct __tds__SetRelayOutputState;	/* onvif.h:35536 */
struct __tds__SendAuxiliaryCommand;	/* onvif.h:35606 */
struct __tds__GetCACertificates;	/* onvif.h:35684 */
struct __tds__LoadCertificateWithPrivateKey;	/* onvif.h:35761 */
struct __tds__GetCertificateInformation;	/* onvif.h:35836 */
struct __tds__LoadCACertificates;	/* onvif.h:35908 */
struct __tds__CreateDot1XConfiguration;	/* onvif.h:35983 */
struct __tds__SetDot1XConfiguration;	/* onvif.h:36054 */
struct __tds__GetDot1XConfiguration;	/* onvif.h:36123 */
struct __tds__GetDot1XConfigurations;	/* onvif.h:36195 */
struct __tds__DeleteDot1XConfiguration;	/* onvif.h:36267 */
struct __tds__GetDot11Capabilities;	/* onvif.h:36335 */
struct __tds__GetDot11Status;	/* onvif.h:36404 */
struct __tds__ScanAvailableDot11Networks;	/* onvif.h:36473 */
struct __tds__GetSystemUris;	/* onvif.h:36542 */
struct __tds__StartFirmwareUpgrade;	/* onvif.h:36619 */
struct __tds__StartSystemRestore;	/* onvif.h:36696 */
struct __tds__GetStorageConfigurations;	/* onvif.h:36766 */
struct __tds__CreateStorageConfiguration;	/* onvif.h:36837 */
struct __tds__GetStorageConfiguration;	/* onvif.h:36907 */
struct __tds__SetStorageConfiguration;	/* onvif.h:36976 */
struct __tds__DeleteStorageConfiguration;	/* onvif.h:37046 */
struct __tds__GetGeoLocation;	/* onvif.h:37116 */
struct __tds__SetGeoLocation;	/* onvif.h:37186 */
struct __tds__DeleteGeoLocation;	/* onvif.h:37255 */
struct __tls__GetServiceCapabilities;	/* onvif.h:37341 */
struct __tls__GetLayout;	/* onvif.h:37412 */
struct __tls__SetLayout;	/* onvif.h:37484 */
struct __tls__GetDisplayOptions;	/* onvif.h:37555 */
struct __tls__GetPaneConfigurations;	/* onvif.h:37630 */
struct __tls__GetPaneConfiguration;	/* onvif.h:37697 */
struct __tls__SetPaneConfigurations;	/* onvif.h:37767 */
struct __tls__SetPaneConfiguration;	/* onvif.h:37834 */
struct __tls__CreatePaneConfiguration;	/* onvif.h:37902 */
struct __tls__DeletePaneConfiguration;	/* onvif.h:37970 */
struct __tmd__GetServiceCapabilities;	/* onvif.h:38056 */
struct __tmd__GetRelayOutputOptions;	/* onvif.h:38124 */
struct __tmd__GetAudioSources;	/* onvif.h:38193 */
struct __tmd__GetAudioOutputs;	/* onvif.h:38262 */
struct __tmd__GetVideoSources;	/* onvif.h:38331 */
struct __tmd__GetVideoOutputs;	/* onvif.h:38400 */
struct __tmd__GetVideoSourceConfiguration;	/* onvif.h:38468 */
struct __tmd__GetVideoOutputConfiguration;	/* onvif.h:38536 */
struct __tmd__GetAudioSourceConfiguration;	/* onvif.h:38604 */
struct __tmd__GetAudioOutputConfiguration;	/* onvif.h:38673 */
struct __tmd__SetVideoSourceConfiguration;	/* onvif.h:38741 */
struct __tmd__SetVideoOutputConfiguration;	/* onvif.h:38809 */
struct __tmd__SetAudioSourceConfiguration;	/* onvif.h:38877 */
struct __tmd__SetAudioOutputConfiguration;	/* onvif.h:38945 */
struct __tmd__GetVideoSourceConfigurationOptions;	/* onvif.h:39013 */
struct __tmd__GetVideoOutputConfigurationOptions;	/* onvif.h:39082 */
struct __tmd__GetAudioSourceConfigurationOptions;	/* onvif.h:39150 */
struct __tmd__GetAudioOutputConfigurationOptions;	/* onvif.h:39218 */
struct __tmd__GetRelayOutputs;	/* onvif.h:39285 */
struct __tmd__SetRelayOutputSettings;	/* onvif.h:39353 */
struct __tmd__SetRelayOutputState;	/* onvif.h:39420 */
struct __tmd__GetDigitalInputs;	/* onvif.h:39487 */
struct __tmd__GetDigitalInputConfigurationOptions;	/* onvif.h:39554 */
struct __tmd__SetDigitalInputConfigurations;	/* onvif.h:39621 */
struct __tmd__GetSerialPorts;	/* onvif.h:39687 */
struct __tmd__GetSerialPortConfiguration;	/* onvif.h:39753 */
struct __tmd__SetSerialPortConfiguration;	/* onvif.h:39819 */
struct __tmd__GetSerialPortConfigurationOptions;	/* onvif.h:39885 */
struct __tmd__SendReceiveSerialCommand;	/* onvif.h:39951 */

/* xop.h:58 */
#ifndef SOAP_TYPE__xop__Include
#define SOAP_TYPE__xop__Include (11)
/* base64Binary schema type: */
struct _xop__Include
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of XSD type xsd:string */
	char *type;	/* optional element of XSD type xsd:string */
	char *options;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 11; } /* = unique type id SOAP_TYPE__xop__Include */
	         _xop__Include();
	friend SOAP_FMAC1 _xop__Include * SOAP_FMAC2 soap_instantiate__xop__Include(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:63 */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (15)
/* wsa5:EndpointReferenceType complex type: */
struct wsa5__EndpointReferenceType
{
public:
	char *Address;	/* required element of XSD type xsd:string */
	struct wsa5__ReferenceParametersType *ReferenceParameters;	/* optional element of XSD type wsa5:ReferenceParametersType */
	struct wsa5__MetadataType *Metadata;	/* optional element of XSD type wsa5:MetadataType */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 15; } /* = unique type id SOAP_TYPE_wsa5__EndpointReferenceType */
	         wsa5__EndpointReferenceType();
	friend SOAP_FMAC1 wsa5__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:66 */
#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (16)
/* wsa5:ReferenceParametersType complex type: */
struct wsa5__ReferenceParametersType
{
public:
	int *chan__ChannelInstance;	/* optional element of XSD type xsd:int */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 16; } /* = unique type id SOAP_TYPE_wsa5__ReferenceParametersType */
	         wsa5__ReferenceParametersType();
	friend SOAP_FMAC1 wsa5__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa5__ReferenceParametersType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:69 */
#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (17)
/* wsa5:MetadataType complex type: */
struct wsa5__MetadataType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 17; } /* = unique type id SOAP_TYPE_wsa5__MetadataType */
	         wsa5__MetadataType();
	friend SOAP_FMAC1 wsa5__MetadataType * SOAP_FMAC2 soap_instantiate_wsa5__MetadataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:84 */
#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (19)
/* wsa5:ProblemActionType complex type: */
struct wsa5__ProblemActionType
{
public:
	char *Action;	/* optional element of XSD type xsd:string */
	char *SoapAction;	/* optional element of XSD type xsd:string */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 19; } /* = unique type id SOAP_TYPE_wsa5__ProblemActionType */
	         wsa5__ProblemActionType();
	friend SOAP_FMAC1 wsa5__ProblemActionType * SOAP_FMAC2 soap_instantiate_wsa5__ProblemActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:72 */
#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (18)
/* wsa5:RelatesToType simple type: */
struct wsa5__RelatesToType
{
public:
	char *__item;	/* mixed XML content */
	char *RelationshipType;	/* optional attribute of XSD type wsa5:RelationshipTypeOpenEnum */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 18; } /* = unique type id SOAP_TYPE_wsa5__RelatesToType */
	         wsa5__RelatesToType();
	friend SOAP_FMAC1 wsa5__RelatesToType * SOAP_FMAC2 soap_instantiate_wsa5__RelatesToType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:258 */
#ifndef SOAP_TYPE_chan__ChannelInstanceType
#define SOAP_TYPE_chan__ChannelInstanceType (44)
/* chan:ChannelInstanceType simple type: */
struct chan__ChannelInstanceType
{
public:
	int __item;	/* mixed XML content */
	enum _wsa5__IsReferenceParameter wsa5__IsReferenceParameter;	/* optional attribute of XSD type wsa5:IsReferenceParameter */
public:
	int soap_type() const { return 44; } /* = unique type id SOAP_TYPE_chan__ChannelInstanceType */
	         chan__ChannelInstanceType();
	friend SOAP_FMAC1 chan__ChannelInstanceType * SOAP_FMAC2 soap_instantiate_chan__ChannelInstanceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:264 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (45)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	char *wsa5__MessageID;	/* optional element of XSD type wsa5:MessageID */
	struct wsa5__RelatesToType *wsa5__RelatesTo;	/* optional element of XSD type wsa5:RelatesTo */
	struct wsa5__EndpointReferenceType *wsa5__From;	/* optional element of XSD type wsa5:From */
	struct wsa5__EndpointReferenceType *wsa5__ReplyTo;	/* mustUnderstand */
	struct wsa5__EndpointReferenceType *wsa5__FaultTo;	/* mustUnderstand */
	char *wsa5__To;	/* mustUnderstand */
	char *wsa5__Action;	/* mustUnderstand */
	struct chan__ChannelInstanceType *chan__ChannelInstance;	/* optional element of XSD type chan:ChannelInstanceType */
public:
	int soap_type() const { return 45; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
	         SOAP_ENV__Header();
	friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:281 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (51)
/* SOAP-ENV:Detail complex type: */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below)
	   WARNING: do not create a cyclic data structure graph throught this element unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
	void *fault;	/* transient (not serialized) */
public:
	int soap_type() const { return 51; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
	         SOAP_ENV__Detail();
	friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:282 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (53)
/* Type SOAP_ENV__Code is a recursive data type (in)directly referencing itself through its (base) class members */
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of XSD type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of XSD type SOAP-ENV:Code */
public:
	int soap_type() const { return 53; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
	         SOAP_ENV__Code();
	friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:283 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (55)
/* SOAP-ENV:Reason complex type: */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 55; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
	         SOAP_ENV__Reason();
	friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:288 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (59)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of XSD type xsd:QName */
	char *faultstring;	/* optional element of XSD type xsd:string */
	char *faultactor;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of XSD type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of XSD type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of XSD type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of XSD type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of XSD type SOAP-ENV:Detail */
public:
	int soap_type() const { return 59; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
	         SOAP_ENV__Fault();
	friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* onvif.h:178 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (60)
/* xsd:anyType simple type: */
class SOAP_CMAC xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__anyType (60)
	virtual int soap_type(void) const { return 60; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
	virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW(xsd__anyType); }
	         xsd__anyType() { xsd__anyType::soap_default(NULL); }
	virtual ~xsd__anyType() { }
	friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:181 */
#ifndef SOAP_TYPE_SOAP_ENV__Envelope
#define SOAP_TYPE_SOAP_ENV__Envelope (62)
/* SOAP-ENV:Envelope complex type: */
struct SOAP_ENV__Envelope
{
public:
	struct SOAP_ENV__Header *SOAP_ENV__Header;	/* optional element of XSD type SOAP-ENV:Header */
	char *SOAP_ENV__Body;	/* optional element of XSD type xsd:anyType */
public:
	int soap_type() const { return 62; } /* = unique type id SOAP_TYPE_SOAP_ENV__Envelope */
	         SOAP_ENV__Envelope();
	friend SOAP_FMAC1 SOAP_ENV__Envelope * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Envelope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:187 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (66)
/* base64Binary schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of XSD type xsd:string */
	char *type;	/* optional element of XSD type xsd:string */
	char *options;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__base64Binary (66)
	virtual int soap_type(void) const { return 66; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
	virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary); }
	         xsd__base64Binary() { xsd__base64Binary::soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
	friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:198 */
#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (71)
/* hexBinary schema type: */
class SOAP_CMAC xsd__hexBinary
{
public:
	unsigned char *__ptr;
	int __size;
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__hexBinary (71)
	virtual int soap_type(void) const { return 71; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__hexBinary, default initialized and not managed by a soap context
	virtual xsd__hexBinary *soap_alloc(void) const { return SOAP_NEW(xsd__hexBinary); }
	         xsd__hexBinary() { xsd__hexBinary::soap_default(NULL); }
	virtual ~xsd__hexBinary() { }
	friend SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 soap_instantiate_xsd__hexBinary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:232 */
#ifndef SOAP_TYPE_tmd__Capabilities
#define SOAP_TYPE_tmd__Capabilities (79)
/* tmd:Capabilities complex type: */
class SOAP_CMAC tmd__Capabilities
{
public:
	int VideoSources;	/* optional attribute of XSD type xsd:int */
	int VideoOutputs;	/* optional attribute of XSD type xsd:int */
	int AudioSources;	/* optional attribute of XSD type xsd:int */
	int AudioOutputs;	/* optional attribute of XSD type xsd:int */
	int RelayOutputs;	/* optional attribute of XSD type xsd:int */
	int SerialPorts;	/* optional attribute of XSD type xsd:int */
	int DigitalInputs;	/* optional attribute of XSD type xsd:int */
	bool DigitalInputOptions;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__Capabilities (79)
	virtual int soap_type(void) const { return 79; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__Capabilities, default initialized and not managed by a soap context
	virtual tmd__Capabilities *soap_alloc(void) const { return SOAP_NEW(tmd__Capabilities); }
	         tmd__Capabilities() { tmd__Capabilities::soap_default(NULL); }
	virtual ~tmd__Capabilities() { }
	friend SOAP_FMAC1 tmd__Capabilities * SOAP_FMAC2 soap_instantiate_tmd__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:235 */
#ifndef SOAP_TYPE_tmd__RelayOutputOptions
#define SOAP_TYPE_tmd__RelayOutputOptions (80)
/* tmd:RelayOutputOptions complex type: */
class SOAP_CMAC tmd__RelayOutputOptions
{
public:
	std::vector<enum tt__RelayMode> Mode;	/* required element of XSD type tt:RelayMode */
	std::string *DelayTimes;	/* optional element of XSD type tmd:DelayTimes */
	bool *Discrete;	/* optional element of XSD type xsd:boolean */
	tmd__RelayOutputOptionsExtension *Extension;	/* optional element of XSD type tmd:RelayOutputOptionsExtension */
	std::string token;	/* required attribute of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__RelayOutputOptions (80)
	virtual int soap_type(void) const { return 80; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__RelayOutputOptions, default initialized and not managed by a soap context
	virtual tmd__RelayOutputOptions *soap_alloc(void) const { return SOAP_NEW(tmd__RelayOutputOptions); }
	         tmd__RelayOutputOptions() { tmd__RelayOutputOptions::soap_default(NULL); }
	virtual ~tmd__RelayOutputOptions() { }
	friend SOAP_FMAC1 tmd__RelayOutputOptions * SOAP_FMAC2 soap_instantiate_tmd__RelayOutputOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:238 */
#ifndef SOAP_TYPE_tmd__RelayOutputOptionsExtension
#define SOAP_TYPE_tmd__RelayOutputOptionsExtension (81)
/* tmd:RelayOutputOptionsExtension complex type: */
class SOAP_CMAC tmd__RelayOutputOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__RelayOutputOptionsExtension (81)
	virtual int soap_type(void) const { return 81; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__RelayOutputOptionsExtension, default initialized and not managed by a soap context
	virtual tmd__RelayOutputOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tmd__RelayOutputOptionsExtension); }
	         tmd__RelayOutputOptionsExtension() { tmd__RelayOutputOptionsExtension::soap_default(NULL); }
	virtual ~tmd__RelayOutputOptionsExtension() { }
	friend SOAP_FMAC1 tmd__RelayOutputOptionsExtension * SOAP_FMAC2 soap_instantiate_tmd__RelayOutputOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:241 */
#ifndef SOAP_TYPE_tmd__Get
#define SOAP_TYPE_tmd__Get (82)
/* tmd:Get complex type: */
class SOAP_CMAC tmd__Get
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__Get (82)
	virtual int soap_type(void) const { return 82; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__Get, default initialized and not managed by a soap context
	virtual tmd__Get *soap_alloc(void) const { return SOAP_NEW(tmd__Get); }
	         tmd__Get() { tmd__Get::soap_default(NULL); }
	virtual ~tmd__Get() { }
	friend SOAP_FMAC1 tmd__Get * SOAP_FMAC2 soap_instantiate_tmd__Get(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:244 */
#ifndef SOAP_TYPE_tmd__GetResponse
#define SOAP_TYPE_tmd__GetResponse (83)
/* tmd:GetResponse complex type: */
class SOAP_CMAC tmd__GetResponse
{
public:
	std::vector<std::string> Token;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__GetResponse (83)
	virtual int soap_type(void) const { return 83; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__GetResponse, default initialized and not managed by a soap context
	virtual tmd__GetResponse *soap_alloc(void) const { return SOAP_NEW(tmd__GetResponse); }
	         tmd__GetResponse() { tmd__GetResponse::soap_default(NULL); }
	virtual ~tmd__GetResponse() { }
	friend SOAP_FMAC1 tmd__GetResponse * SOAP_FMAC2 soap_instantiate_tmd__GetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:247 */
#ifndef SOAP_TYPE_tmd__DigitalInputConfigurationOptions
#define SOAP_TYPE_tmd__DigitalInputConfigurationOptions (84)
/* tmd:DigitalInputConfigurationOptions complex type: */
class SOAP_CMAC tmd__DigitalInputConfigurationOptions
{
public:
	std::vector<enum tt__DigitalIdleState> IdleState;	/* required element of XSD type tt:DigitalIdleState */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__DigitalInputConfigurationOptions (84)
	virtual int soap_type(void) const { return 84; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__DigitalInputConfigurationOptions, default initialized and not managed by a soap context
	virtual tmd__DigitalInputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tmd__DigitalInputConfigurationOptions); }
	         tmd__DigitalInputConfigurationOptions() { tmd__DigitalInputConfigurationOptions::soap_default(NULL); }
	virtual ~tmd__DigitalInputConfigurationOptions() { }
	friend SOAP_FMAC1 tmd__DigitalInputConfigurationOptions * SOAP_FMAC2 soap_instantiate_tmd__DigitalInputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4014 */
#ifndef SOAP_TYPE__tmd__union_SerialData
#define SOAP_TYPE__tmd__union_SerialData (977)
/* xsd:choice complex type: */
union _tmd__union_SerialData
{
#define SOAP_UNION__tmd__union_SerialData_Binary	(1)
	xsd__base64Binary *Binary;
#define SOAP_UNION__tmd__union_SerialData_String	(2)
	std::string *String;
};
#endif

/* onvif.h:250 */
#ifndef SOAP_TYPE_tmd__SerialData
#define SOAP_TYPE_tmd__SerialData (85)
/* Choice: */
class SOAP_CMAC tmd__SerialData
{
public:
	int __union_SerialData;	/* union discriminant (of union defined below) */
	union _tmd__union_SerialData union_SerialData;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__SerialData (85)
	virtual int soap_type(void) const { return 85; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__SerialData, default initialized and not managed by a soap context
	virtual tmd__SerialData *soap_alloc(void) const { return SOAP_NEW(tmd__SerialData); }
	         tmd__SerialData() { tmd__SerialData::soap_default(NULL); }
	virtual ~tmd__SerialData() { }
	friend SOAP_FMAC1 tmd__SerialData * SOAP_FMAC2 soap_instantiate_tmd__SerialData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:256 */
#ifndef SOAP_TYPE_tmd__SerialPortConfiguration
#define SOAP_TYPE_tmd__SerialPortConfiguration (87)
/* tmd:SerialPortConfiguration complex type: */
class SOAP_CMAC tmd__SerialPortConfiguration
{
public:
	int BaudRate;	/* required element of XSD type xsd:int */
	enum tmd__ParityBit ParityBit;	/* required element of XSD type tmd:ParityBit */
	int CharacterLength;	/* required element of XSD type xsd:int */
	float StopBit;	/* required element of XSD type xsd:float */
	std::string token;	/* required attribute of XSD type tt:ReferenceToken */
	enum tmd__SerialPortType type;	/* required attribute of XSD type tmd:SerialPortType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__SerialPortConfiguration (87)
	virtual int soap_type(void) const { return 87; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__SerialPortConfiguration, default initialized and not managed by a soap context
	virtual tmd__SerialPortConfiguration *soap_alloc(void) const { return SOAP_NEW(tmd__SerialPortConfiguration); }
	         tmd__SerialPortConfiguration() { tmd__SerialPortConfiguration::soap_default(NULL); }
	virtual ~tmd__SerialPortConfiguration() { }
	friend SOAP_FMAC1 tmd__SerialPortConfiguration * SOAP_FMAC2 soap_instantiate_tmd__SerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:259 */
#ifndef SOAP_TYPE_tmd__SerialPortConfigurationOptions
#define SOAP_TYPE_tmd__SerialPortConfigurationOptions (88)
/* tmd:SerialPortConfigurationOptions complex type: */
class SOAP_CMAC tmd__SerialPortConfigurationOptions
{
public:
	tt__IntList *BaudRateList;	/* required element of XSD type tt:IntList */
	tmd__ParityBitList *ParityBitList;	/* required element of XSD type tmd:ParityBitList */
	tt__IntList *CharacterLengthList;	/* required element of XSD type tt:IntList */
	tt__FloatList *StopBitList;	/* required element of XSD type tt:FloatList */
	std::string token;	/* required attribute of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__SerialPortConfigurationOptions (88)
	virtual int soap_type(void) const { return 88; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__SerialPortConfigurationOptions, default initialized and not managed by a soap context
	virtual tmd__SerialPortConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tmd__SerialPortConfigurationOptions); }
	         tmd__SerialPortConfigurationOptions() { tmd__SerialPortConfigurationOptions::soap_default(NULL); }
	virtual ~tmd__SerialPortConfigurationOptions() { }
	friend SOAP_FMAC1 tmd__SerialPortConfigurationOptions * SOAP_FMAC2 soap_instantiate_tmd__SerialPortConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:262 */
#ifndef SOAP_TYPE_tmd__ParityBitList
#define SOAP_TYPE_tmd__ParityBitList (89)
/* tmd:ParityBitList complex type: */
class SOAP_CMAC tmd__ParityBitList
{
public:
	std::vector<enum tmd__ParityBit> Items;	/* optional element of XSD type tmd:ParityBit */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__ParityBitList (89)
	virtual int soap_type(void) const { return 89; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__ParityBitList, default initialized and not managed by a soap context
	virtual tmd__ParityBitList *soap_alloc(void) const { return SOAP_NEW(tmd__ParityBitList); }
	         tmd__ParityBitList() { tmd__ParityBitList::soap_default(NULL); }
	virtual ~tmd__ParityBitList() { }
	friend SOAP_FMAC1 tmd__ParityBitList * SOAP_FMAC2 soap_instantiate_tmd__ParityBitList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:265 */
#ifndef SOAP_TYPE__tmd__GetServiceCapabilities
#define SOAP_TYPE__tmd__GetServiceCapabilities (90)
/* tmd:GetServiceCapabilities complex type: */
class SOAP_CMAC _tmd__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetServiceCapabilities (90)
	virtual int soap_type(void) const { return 90; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _tmd__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_tmd__GetServiceCapabilities); }
	         _tmd__GetServiceCapabilities() { _tmd__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tmd__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _tmd__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tmd__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:268 */
#ifndef SOAP_TYPE__tmd__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tmd__GetServiceCapabilitiesResponse (91)
/* tmd:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _tmd__GetServiceCapabilitiesResponse
{
public:
	tmd__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tmd:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetServiceCapabilitiesResponse (91)
	virtual int soap_type(void) const { return 91; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tmd__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetServiceCapabilitiesResponse); }
	         _tmd__GetServiceCapabilitiesResponse() { _tmd__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tmd__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _tmd__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tmd__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:271 */
#ifndef SOAP_TYPE__tmd__GetRelayOutputOptions
#define SOAP_TYPE__tmd__GetRelayOutputOptions (92)
/* tmd:GetRelayOutputOptions complex type: */
class SOAP_CMAC _tmd__GetRelayOutputOptions
{
public:
	std::string *RelayOutputToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetRelayOutputOptions (92)
	virtual int soap_type(void) const { return 92; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetRelayOutputOptions, default initialized and not managed by a soap context
	virtual _tmd__GetRelayOutputOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetRelayOutputOptions); }
	         _tmd__GetRelayOutputOptions() { _tmd__GetRelayOutputOptions::soap_default(NULL); }
	virtual ~_tmd__GetRelayOutputOptions() { }
	friend SOAP_FMAC1 _tmd__GetRelayOutputOptions * SOAP_FMAC2 soap_instantiate__tmd__GetRelayOutputOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:274 */
#ifndef SOAP_TYPE__tmd__GetRelayOutputOptionsResponse
#define SOAP_TYPE__tmd__GetRelayOutputOptionsResponse (93)
/* tmd:GetRelayOutputOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetRelayOutputOptionsResponse
{
public:
	std::vector<tmd__RelayOutputOptions *> RelayOutputOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tmd:RelayOutputOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetRelayOutputOptionsResponse (93)
	virtual int soap_type(void) const { return 93; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetRelayOutputOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetRelayOutputOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetRelayOutputOptionsResponse); }
	         _tmd__GetRelayOutputOptionsResponse() { _tmd__GetRelayOutputOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetRelayOutputOptionsResponse() { }
	friend SOAP_FMAC1 _tmd__GetRelayOutputOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetRelayOutputOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:277 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputs
#define SOAP_TYPE__tmd__GetVideoOutputs (94)
/* tmd:GetVideoOutputs complex type: */
class SOAP_CMAC _tmd__GetVideoOutputs
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoOutputs (94)
	virtual int soap_type(void) const { return 94; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoOutputs, default initialized and not managed by a soap context
	virtual _tmd__GetVideoOutputs *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoOutputs); }
	         _tmd__GetVideoOutputs() { _tmd__GetVideoOutputs::soap_default(NULL); }
	virtual ~_tmd__GetVideoOutputs() { }
	friend SOAP_FMAC1 _tmd__GetVideoOutputs * SOAP_FMAC2 soap_instantiate__tmd__GetVideoOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:280 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputsResponse
#define SOAP_TYPE__tmd__GetVideoOutputsResponse (95)
/* tmd:GetVideoOutputsResponse complex type: */
class SOAP_CMAC _tmd__GetVideoOutputsResponse
{
public:
	std::vector<tt__VideoOutput *> VideoOutputs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:VideoOutput */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoOutputsResponse (95)
	virtual int soap_type(void) const { return 95; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoOutputsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetVideoOutputsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoOutputsResponse); }
	         _tmd__GetVideoOutputsResponse() { _tmd__GetVideoOutputsResponse::soap_default(NULL); }
	virtual ~_tmd__GetVideoOutputsResponse() { }
	friend SOAP_FMAC1 _tmd__GetVideoOutputsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetVideoOutputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:283 */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfiguration
#define SOAP_TYPE__tmd__GetAudioSourceConfiguration (96)
/* tmd:GetAudioSourceConfiguration complex type: */
class SOAP_CMAC _tmd__GetAudioSourceConfiguration
{
public:
	std::string AudioSourceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioSourceConfiguration (96)
	virtual int soap_type(void) const { return 96; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioSourceConfiguration, default initialized and not managed by a soap context
	virtual _tmd__GetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioSourceConfiguration); }
	         _tmd__GetAudioSourceConfiguration() { _tmd__GetAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_tmd__GetAudioSourceConfiguration() { }
	friend SOAP_FMAC1 _tmd__GetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__tmd__GetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:286 */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse
#define SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse (97)
/* tmd:GetAudioSourceConfigurationResponse complex type: */
class SOAP_CMAC _tmd__GetAudioSourceConfigurationResponse
{
public:
	tt__AudioSourceConfiguration *AudioSourceConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioSourceConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse (97)
	virtual int soap_type(void) const { return 97; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__GetAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioSourceConfigurationResponse); }
	         _tmd__GetAudioSourceConfigurationResponse() { _tmd__GetAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__GetAudioSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__GetAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__GetAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:289 */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfiguration
#define SOAP_TYPE__tmd__GetAudioOutputConfiguration (98)
/* tmd:GetAudioOutputConfiguration complex type: */
class SOAP_CMAC _tmd__GetAudioOutputConfiguration
{
public:
	std::string AudioOutputToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioOutputConfiguration (98)
	virtual int soap_type(void) const { return 98; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioOutputConfiguration, default initialized and not managed by a soap context
	virtual _tmd__GetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioOutputConfiguration); }
	         _tmd__GetAudioOutputConfiguration() { _tmd__GetAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_tmd__GetAudioOutputConfiguration() { }
	friend SOAP_FMAC1 _tmd__GetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__tmd__GetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:292 */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse
#define SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse (99)
/* tmd:GetAudioOutputConfigurationResponse complex type: */
class SOAP_CMAC _tmd__GetAudioOutputConfigurationResponse
{
public:
	tt__AudioOutputConfiguration *AudioOutputConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioOutputConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse (99)
	virtual int soap_type(void) const { return 99; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__GetAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioOutputConfigurationResponse); }
	         _tmd__GetAudioOutputConfigurationResponse() { _tmd__GetAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__GetAudioOutputConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__GetAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__GetAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:295 */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfiguration
#define SOAP_TYPE__tmd__GetVideoSourceConfiguration (100)
/* tmd:GetVideoSourceConfiguration complex type: */
class SOAP_CMAC _tmd__GetVideoSourceConfiguration
{
public:
	std::string VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoSourceConfiguration (100)
	virtual int soap_type(void) const { return 100; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoSourceConfiguration, default initialized and not managed by a soap context
	virtual _tmd__GetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoSourceConfiguration); }
	         _tmd__GetVideoSourceConfiguration() { _tmd__GetVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_tmd__GetVideoSourceConfiguration() { }
	friend SOAP_FMAC1 _tmd__GetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__tmd__GetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:298 */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse
#define SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse (101)
/* tmd:GetVideoSourceConfigurationResponse complex type: */
class SOAP_CMAC _tmd__GetVideoSourceConfigurationResponse
{
public:
	tt__VideoSourceConfiguration *VideoSourceConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoSourceConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse (101)
	virtual int soap_type(void) const { return 101; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__GetVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoSourceConfigurationResponse); }
	         _tmd__GetVideoSourceConfigurationResponse() { _tmd__GetVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__GetVideoSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__GetVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__GetVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:301 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfiguration
#define SOAP_TYPE__tmd__GetVideoOutputConfiguration (102)
/* tmd:GetVideoOutputConfiguration complex type: */
class SOAP_CMAC _tmd__GetVideoOutputConfiguration
{
public:
	std::string VideoOutputToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoOutputConfiguration (102)
	virtual int soap_type(void) const { return 102; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoOutputConfiguration, default initialized and not managed by a soap context
	virtual _tmd__GetVideoOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoOutputConfiguration); }
	         _tmd__GetVideoOutputConfiguration() { _tmd__GetVideoOutputConfiguration::soap_default(NULL); }
	virtual ~_tmd__GetVideoOutputConfiguration() { }
	friend SOAP_FMAC1 _tmd__GetVideoOutputConfiguration * SOAP_FMAC2 soap_instantiate__tmd__GetVideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:304 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse
#define SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse (103)
/* tmd:GetVideoOutputConfigurationResponse complex type: */
class SOAP_CMAC _tmd__GetVideoOutputConfigurationResponse
{
public:
	tt__VideoOutputConfiguration *VideoOutputConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoOutputConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse (103)
	virtual int soap_type(void) const { return 103; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__GetVideoOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoOutputConfigurationResponse); }
	         _tmd__GetVideoOutputConfigurationResponse() { _tmd__GetVideoOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__GetVideoOutputConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__GetVideoOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__GetVideoOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:307 */
#ifndef SOAP_TYPE__tmd__SetAudioSourceConfiguration
#define SOAP_TYPE__tmd__SetAudioSourceConfiguration (104)
/* tmd:SetAudioSourceConfiguration complex type: */
class SOAP_CMAC _tmd__SetAudioSourceConfiguration
{
public:
	tt__AudioSourceConfiguration *Configuration;	/* required element of XSD type tt:AudioSourceConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetAudioSourceConfiguration (104)
	virtual int soap_type(void) const { return 104; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetAudioSourceConfiguration, default initialized and not managed by a soap context
	virtual _tmd__SetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__SetAudioSourceConfiguration); }
	         _tmd__SetAudioSourceConfiguration() { _tmd__SetAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_tmd__SetAudioSourceConfiguration() { }
	friend SOAP_FMAC1 _tmd__SetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__tmd__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:310 */
#ifndef SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse
#define SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse (105)
/* tmd:SetAudioSourceConfigurationResponse complex type: */
class SOAP_CMAC _tmd__SetAudioSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse (105)
	virtual int soap_type(void) const { return 105; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetAudioSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__SetAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetAudioSourceConfigurationResponse); }
	         _tmd__SetAudioSourceConfigurationResponse() { _tmd__SetAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__SetAudioSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__SetAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__SetAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:313 */
#ifndef SOAP_TYPE__tmd__SetAudioOutputConfiguration
#define SOAP_TYPE__tmd__SetAudioOutputConfiguration (106)
/* tmd:SetAudioOutputConfiguration complex type: */
class SOAP_CMAC _tmd__SetAudioOutputConfiguration
{
public:
	tt__AudioOutputConfiguration *Configuration;	/* required element of XSD type tt:AudioOutputConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetAudioOutputConfiguration (106)
	virtual int soap_type(void) const { return 106; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetAudioOutputConfiguration, default initialized and not managed by a soap context
	virtual _tmd__SetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__SetAudioOutputConfiguration); }
	         _tmd__SetAudioOutputConfiguration() { _tmd__SetAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_tmd__SetAudioOutputConfiguration() { }
	friend SOAP_FMAC1 _tmd__SetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__tmd__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:316 */
#ifndef SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse
#define SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse (107)
/* tmd:SetAudioOutputConfigurationResponse complex type: */
class SOAP_CMAC _tmd__SetAudioOutputConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse (107)
	virtual int soap_type(void) const { return 107; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetAudioOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__SetAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetAudioOutputConfigurationResponse); }
	         _tmd__SetAudioOutputConfigurationResponse() { _tmd__SetAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__SetAudioOutputConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__SetAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__SetAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:319 */
#ifndef SOAP_TYPE__tmd__SetVideoSourceConfiguration
#define SOAP_TYPE__tmd__SetVideoSourceConfiguration (108)
/* tmd:SetVideoSourceConfiguration complex type: */
class SOAP_CMAC _tmd__SetVideoSourceConfiguration
{
public:
	tt__VideoSourceConfiguration *Configuration;	/* required element of XSD type tt:VideoSourceConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetVideoSourceConfiguration (108)
	virtual int soap_type(void) const { return 108; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetVideoSourceConfiguration, default initialized and not managed by a soap context
	virtual _tmd__SetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__SetVideoSourceConfiguration); }
	         _tmd__SetVideoSourceConfiguration() { _tmd__SetVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_tmd__SetVideoSourceConfiguration() { }
	friend SOAP_FMAC1 _tmd__SetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__tmd__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:322 */
#ifndef SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse
#define SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse (109)
/* tmd:SetVideoSourceConfigurationResponse complex type: */
class SOAP_CMAC _tmd__SetVideoSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse (109)
	virtual int soap_type(void) const { return 109; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetVideoSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__SetVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetVideoSourceConfigurationResponse); }
	         _tmd__SetVideoSourceConfigurationResponse() { _tmd__SetVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__SetVideoSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__SetVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__SetVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:325 */
#ifndef SOAP_TYPE__tmd__SetVideoOutputConfiguration
#define SOAP_TYPE__tmd__SetVideoOutputConfiguration (110)
/* tmd:SetVideoOutputConfiguration complex type: */
class SOAP_CMAC _tmd__SetVideoOutputConfiguration
{
public:
	tt__VideoOutputConfiguration *Configuration;	/* required element of XSD type tt:VideoOutputConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetVideoOutputConfiguration (110)
	virtual int soap_type(void) const { return 110; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetVideoOutputConfiguration, default initialized and not managed by a soap context
	virtual _tmd__SetVideoOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__SetVideoOutputConfiguration); }
	         _tmd__SetVideoOutputConfiguration() { _tmd__SetVideoOutputConfiguration::soap_default(NULL); }
	virtual ~_tmd__SetVideoOutputConfiguration() { }
	friend SOAP_FMAC1 _tmd__SetVideoOutputConfiguration * SOAP_FMAC2 soap_instantiate__tmd__SetVideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:328 */
#ifndef SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse
#define SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse (111)
/* tmd:SetVideoOutputConfigurationResponse complex type: */
class SOAP_CMAC _tmd__SetVideoOutputConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse (111)
	virtual int soap_type(void) const { return 111; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetVideoOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__SetVideoOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetVideoOutputConfigurationResponse); }
	         _tmd__SetVideoOutputConfigurationResponse() { _tmd__SetVideoOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__SetVideoOutputConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__SetVideoOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__SetVideoOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:331 */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions
#define SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions (112)
/* tmd:GetVideoSourceConfigurationOptions complex type: */
class SOAP_CMAC _tmd__GetVideoSourceConfigurationOptions
{
public:
	std::string VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions (112)
	virtual int soap_type(void) const { return 112; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual _tmd__GetVideoSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoSourceConfigurationOptions); }
	         _tmd__GetVideoSourceConfigurationOptions() { _tmd__GetVideoSourceConfigurationOptions::soap_default(NULL); }
	virtual ~_tmd__GetVideoSourceConfigurationOptions() { }
	friend SOAP_FMAC1 _tmd__GetVideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate__tmd__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:334 */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse (113)
/* tmd:GetVideoSourceConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetVideoSourceConfigurationOptionsResponse
{
public:
	tt__VideoSourceConfigurationOptions *VideoSourceConfigurationOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoSourceConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse (113)
	virtual int soap_type(void) const { return 113; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetVideoSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoSourceConfigurationOptionsResponse); }
	         _tmd__GetVideoSourceConfigurationOptionsResponse() { _tmd__GetVideoSourceConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetVideoSourceConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _tmd__GetVideoSourceConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetVideoSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:337 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions
#define SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions (114)
/* tmd:GetVideoOutputConfigurationOptions complex type: */
class SOAP_CMAC _tmd__GetVideoOutputConfigurationOptions
{
public:
	std::string VideoOutputToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions (114)
	virtual int soap_type(void) const { return 114; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoOutputConfigurationOptions, default initialized and not managed by a soap context
	virtual _tmd__GetVideoOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoOutputConfigurationOptions); }
	         _tmd__GetVideoOutputConfigurationOptions() { _tmd__GetVideoOutputConfigurationOptions::soap_default(NULL); }
	virtual ~_tmd__GetVideoOutputConfigurationOptions() { }
	friend SOAP_FMAC1 _tmd__GetVideoOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate__tmd__GetVideoOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:340 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse (115)
/* tmd:GetVideoOutputConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetVideoOutputConfigurationOptionsResponse
{
public:
	tt__VideoOutputConfigurationOptions *VideoOutputConfigurationOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoOutputConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse (115)
	virtual int soap_type(void) const { return 115; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoOutputConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetVideoOutputConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoOutputConfigurationOptionsResponse); }
	         _tmd__GetVideoOutputConfigurationOptionsResponse() { _tmd__GetVideoOutputConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetVideoOutputConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _tmd__GetVideoOutputConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetVideoOutputConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:343 */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions
#define SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions (116)
/* tmd:GetAudioSourceConfigurationOptions complex type: */
class SOAP_CMAC _tmd__GetAudioSourceConfigurationOptions
{
public:
	std::string AudioSourceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions (116)
	virtual int soap_type(void) const { return 116; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual _tmd__GetAudioSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioSourceConfigurationOptions); }
	         _tmd__GetAudioSourceConfigurationOptions() { _tmd__GetAudioSourceConfigurationOptions::soap_default(NULL); }
	virtual ~_tmd__GetAudioSourceConfigurationOptions() { }
	friend SOAP_FMAC1 _tmd__GetAudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate__tmd__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:346 */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse (117)
/* tmd:GetAudioSourceConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetAudioSourceConfigurationOptionsResponse
{
public:
	tt__AudioSourceConfigurationOptions *AudioSourceOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioSourceConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse (117)
	virtual int soap_type(void) const { return 117; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetAudioSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioSourceConfigurationOptionsResponse); }
	         _tmd__GetAudioSourceConfigurationOptionsResponse() { _tmd__GetAudioSourceConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetAudioSourceConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _tmd__GetAudioSourceConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetAudioSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:349 */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions
#define SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions (118)
/* tmd:GetAudioOutputConfigurationOptions complex type: */
class SOAP_CMAC _tmd__GetAudioOutputConfigurationOptions
{
public:
	std::string AudioOutputToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions (118)
	virtual int soap_type(void) const { return 118; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioOutputConfigurationOptions, default initialized and not managed by a soap context
	virtual _tmd__GetAudioOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioOutputConfigurationOptions); }
	         _tmd__GetAudioOutputConfigurationOptions() { _tmd__GetAudioOutputConfigurationOptions::soap_default(NULL); }
	virtual ~_tmd__GetAudioOutputConfigurationOptions() { }
	friend SOAP_FMAC1 _tmd__GetAudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate__tmd__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:352 */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse (119)
/* tmd:GetAudioOutputConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetAudioOutputConfigurationOptionsResponse
{
public:
	tt__AudioOutputConfigurationOptions *AudioOutputOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioOutputConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse (119)
	virtual int soap_type(void) const { return 119; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioOutputConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetAudioOutputConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioOutputConfigurationOptionsResponse); }
	         _tmd__GetAudioOutputConfigurationOptionsResponse() { _tmd__GetAudioOutputConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetAudioOutputConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _tmd__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetAudioOutputConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:355 */
#ifndef SOAP_TYPE__tmd__SetRelayOutputSettings
#define SOAP_TYPE__tmd__SetRelayOutputSettings (120)
/* tmd:SetRelayOutputSettings complex type: */
class SOAP_CMAC _tmd__SetRelayOutputSettings
{
public:
	tt__RelayOutput *RelayOutput;	/* required element of XSD type tt:RelayOutput */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetRelayOutputSettings (120)
	virtual int soap_type(void) const { return 120; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetRelayOutputSettings, default initialized and not managed by a soap context
	virtual _tmd__SetRelayOutputSettings *soap_alloc(void) const { return SOAP_NEW(_tmd__SetRelayOutputSettings); }
	         _tmd__SetRelayOutputSettings() { _tmd__SetRelayOutputSettings::soap_default(NULL); }
	virtual ~_tmd__SetRelayOutputSettings() { }
	friend SOAP_FMAC1 _tmd__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate__tmd__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:358 */
#ifndef SOAP_TYPE__tmd__SetRelayOutputSettingsResponse
#define SOAP_TYPE__tmd__SetRelayOutputSettingsResponse (121)
/* tmd:SetRelayOutputSettingsResponse complex type: */
class SOAP_CMAC _tmd__SetRelayOutputSettingsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetRelayOutputSettingsResponse (121)
	virtual int soap_type(void) const { return 121; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetRelayOutputSettingsResponse, default initialized and not managed by a soap context
	virtual _tmd__SetRelayOutputSettingsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetRelayOutputSettingsResponse); }
	         _tmd__SetRelayOutputSettingsResponse() { _tmd__SetRelayOutputSettingsResponse::soap_default(NULL); }
	virtual ~_tmd__SetRelayOutputSettingsResponse() { }
	friend SOAP_FMAC1 _tmd__SetRelayOutputSettingsResponse * SOAP_FMAC2 soap_instantiate__tmd__SetRelayOutputSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:361 */
#ifndef SOAP_TYPE__tmd__GetDigitalInputs
#define SOAP_TYPE__tmd__GetDigitalInputs (122)
/* tmd:GetDigitalInputs complex type: */
class SOAP_CMAC _tmd__GetDigitalInputs
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetDigitalInputs (122)
	virtual int soap_type(void) const { return 122; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetDigitalInputs, default initialized and not managed by a soap context
	virtual _tmd__GetDigitalInputs *soap_alloc(void) const { return SOAP_NEW(_tmd__GetDigitalInputs); }
	         _tmd__GetDigitalInputs() { _tmd__GetDigitalInputs::soap_default(NULL); }
	virtual ~_tmd__GetDigitalInputs() { }
	friend SOAP_FMAC1 _tmd__GetDigitalInputs * SOAP_FMAC2 soap_instantiate__tmd__GetDigitalInputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:364 */
#ifndef SOAP_TYPE__tmd__GetDigitalInputsResponse
#define SOAP_TYPE__tmd__GetDigitalInputsResponse (123)
/* tmd:GetDigitalInputsResponse complex type: */
class SOAP_CMAC _tmd__GetDigitalInputsResponse
{
public:
	std::vector<tt__DigitalInput *> DigitalInputs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:DigitalInput */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetDigitalInputsResponse (123)
	virtual int soap_type(void) const { return 123; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetDigitalInputsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetDigitalInputsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetDigitalInputsResponse); }
	         _tmd__GetDigitalInputsResponse() { _tmd__GetDigitalInputsResponse::soap_default(NULL); }
	virtual ~_tmd__GetDigitalInputsResponse() { }
	friend SOAP_FMAC1 _tmd__GetDigitalInputsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetDigitalInputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:367 */
#ifndef SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions
#define SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions (124)
/* tmd:GetDigitalInputConfigurationOptions complex type: */
class SOAP_CMAC _tmd__GetDigitalInputConfigurationOptions
{
public:
	std::string *Token;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions (124)
	virtual int soap_type(void) const { return 124; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetDigitalInputConfigurationOptions, default initialized and not managed by a soap context
	virtual _tmd__GetDigitalInputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetDigitalInputConfigurationOptions); }
	         _tmd__GetDigitalInputConfigurationOptions() { _tmd__GetDigitalInputConfigurationOptions::soap_default(NULL); }
	virtual ~_tmd__GetDigitalInputConfigurationOptions() { }
	friend SOAP_FMAC1 _tmd__GetDigitalInputConfigurationOptions * SOAP_FMAC2 soap_instantiate__tmd__GetDigitalInputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:370 */
#ifndef SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse (125)
/* tmd:GetDigitalInputConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetDigitalInputConfigurationOptionsResponse
{
public:
	tmd__DigitalInputConfigurationOptions *DigitalInputOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tmd:DigitalInputConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse (125)
	virtual int soap_type(void) const { return 125; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetDigitalInputConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetDigitalInputConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetDigitalInputConfigurationOptionsResponse); }
	         _tmd__GetDigitalInputConfigurationOptionsResponse() { _tmd__GetDigitalInputConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetDigitalInputConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _tmd__GetDigitalInputConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetDigitalInputConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:373 */
#ifndef SOAP_TYPE__tmd__SetDigitalInputConfigurations
#define SOAP_TYPE__tmd__SetDigitalInputConfigurations (126)
/* tmd:SetDigitalInputConfigurations complex type: */
class SOAP_CMAC _tmd__SetDigitalInputConfigurations
{
public:
	std::vector<tt__DigitalInput *> DigitalInputs;	/* required element of XSD type tt:DigitalInput */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetDigitalInputConfigurations (126)
	virtual int soap_type(void) const { return 126; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetDigitalInputConfigurations, default initialized and not managed by a soap context
	virtual _tmd__SetDigitalInputConfigurations *soap_alloc(void) const { return SOAP_NEW(_tmd__SetDigitalInputConfigurations); }
	         _tmd__SetDigitalInputConfigurations() { _tmd__SetDigitalInputConfigurations::soap_default(NULL); }
	virtual ~_tmd__SetDigitalInputConfigurations() { }
	friend SOAP_FMAC1 _tmd__SetDigitalInputConfigurations * SOAP_FMAC2 soap_instantiate__tmd__SetDigitalInputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:376 */
#ifndef SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse
#define SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse (127)
/* tmd:SetDigitalInputConfigurationsResponse complex type: */
class SOAP_CMAC _tmd__SetDigitalInputConfigurationsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse (127)
	virtual int soap_type(void) const { return 127; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetDigitalInputConfigurationsResponse, default initialized and not managed by a soap context
	virtual _tmd__SetDigitalInputConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetDigitalInputConfigurationsResponse); }
	         _tmd__SetDigitalInputConfigurationsResponse() { _tmd__SetDigitalInputConfigurationsResponse::soap_default(NULL); }
	virtual ~_tmd__SetDigitalInputConfigurationsResponse() { }
	friend SOAP_FMAC1 _tmd__SetDigitalInputConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tmd__SetDigitalInputConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:379 */
#ifndef SOAP_TYPE__tmd__GetSerialPorts
#define SOAP_TYPE__tmd__GetSerialPorts (128)
/* tmd:GetSerialPorts complex type: */
class SOAP_CMAC _tmd__GetSerialPorts
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetSerialPorts (128)
	virtual int soap_type(void) const { return 128; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetSerialPorts, default initialized and not managed by a soap context
	virtual _tmd__GetSerialPorts *soap_alloc(void) const { return SOAP_NEW(_tmd__GetSerialPorts); }
	         _tmd__GetSerialPorts() { _tmd__GetSerialPorts::soap_default(NULL); }
	virtual ~_tmd__GetSerialPorts() { }
	friend SOAP_FMAC1 _tmd__GetSerialPorts * SOAP_FMAC2 soap_instantiate__tmd__GetSerialPorts(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:382 */
#ifndef SOAP_TYPE__tmd__GetSerialPortsResponse
#define SOAP_TYPE__tmd__GetSerialPortsResponse (129)
/* tmd:GetSerialPortsResponse complex type: */
class SOAP_CMAC _tmd__GetSerialPortsResponse
{
public:
	std::vector<tmd__SerialPort *> SerialPort;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tmd:SerialPort */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetSerialPortsResponse (129)
	virtual int soap_type(void) const { return 129; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetSerialPortsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetSerialPortsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetSerialPortsResponse); }
	         _tmd__GetSerialPortsResponse() { _tmd__GetSerialPortsResponse::soap_default(NULL); }
	virtual ~_tmd__GetSerialPortsResponse() { }
	friend SOAP_FMAC1 _tmd__GetSerialPortsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetSerialPortsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:385 */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfiguration
#define SOAP_TYPE__tmd__GetSerialPortConfiguration (130)
/* tmd:GetSerialPortConfiguration complex type: */
class SOAP_CMAC _tmd__GetSerialPortConfiguration
{
public:
	std::string SerialPortToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetSerialPortConfiguration (130)
	virtual int soap_type(void) const { return 130; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetSerialPortConfiguration, default initialized and not managed by a soap context
	virtual _tmd__GetSerialPortConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__GetSerialPortConfiguration); }
	         _tmd__GetSerialPortConfiguration() { _tmd__GetSerialPortConfiguration::soap_default(NULL); }
	virtual ~_tmd__GetSerialPortConfiguration() { }
	friend SOAP_FMAC1 _tmd__GetSerialPortConfiguration * SOAP_FMAC2 soap_instantiate__tmd__GetSerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:388 */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfigurationResponse
#define SOAP_TYPE__tmd__GetSerialPortConfigurationResponse (131)
/* tmd:GetSerialPortConfigurationResponse complex type: */
class SOAP_CMAC _tmd__GetSerialPortConfigurationResponse
{
public:
	tmd__SerialPortConfiguration *SerialPortConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tmd:SerialPortConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetSerialPortConfigurationResponse (131)
	virtual int soap_type(void) const { return 131; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetSerialPortConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__GetSerialPortConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetSerialPortConfigurationResponse); }
	         _tmd__GetSerialPortConfigurationResponse() { _tmd__GetSerialPortConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__GetSerialPortConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__GetSerialPortConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__GetSerialPortConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:391 */
#ifndef SOAP_TYPE__tmd__SetSerialPortConfiguration
#define SOAP_TYPE__tmd__SetSerialPortConfiguration (132)
/* tmd:SetSerialPortConfiguration complex type: */
class SOAP_CMAC _tmd__SetSerialPortConfiguration
{
public:
	tmd__SerialPortConfiguration *SerialPortConfiguration;	/* required element of XSD type tmd:SerialPortConfiguration */
	bool ForcePersistance;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetSerialPortConfiguration (132)
	virtual int soap_type(void) const { return 132; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetSerialPortConfiguration, default initialized and not managed by a soap context
	virtual _tmd__SetSerialPortConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__SetSerialPortConfiguration); }
	         _tmd__SetSerialPortConfiguration() { _tmd__SetSerialPortConfiguration::soap_default(NULL); }
	virtual ~_tmd__SetSerialPortConfiguration() { }
	friend SOAP_FMAC1 _tmd__SetSerialPortConfiguration * SOAP_FMAC2 soap_instantiate__tmd__SetSerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:394 */
#ifndef SOAP_TYPE__tmd__SetSerialPortConfigurationResponse
#define SOAP_TYPE__tmd__SetSerialPortConfigurationResponse (133)
/* tmd:SetSerialPortConfigurationResponse complex type: */
class SOAP_CMAC _tmd__SetSerialPortConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetSerialPortConfigurationResponse (133)
	virtual int soap_type(void) const { return 133; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetSerialPortConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__SetSerialPortConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetSerialPortConfigurationResponse); }
	         _tmd__SetSerialPortConfigurationResponse() { _tmd__SetSerialPortConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__SetSerialPortConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__SetSerialPortConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__SetSerialPortConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:397 */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfigurationOptions
#define SOAP_TYPE__tmd__GetSerialPortConfigurationOptions (134)
/* tmd:GetSerialPortConfigurationOptions complex type: */
class SOAP_CMAC _tmd__GetSerialPortConfigurationOptions
{
public:
	std::string SerialPortToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetSerialPortConfigurationOptions (134)
	virtual int soap_type(void) const { return 134; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetSerialPortConfigurationOptions, default initialized and not managed by a soap context
	virtual _tmd__GetSerialPortConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetSerialPortConfigurationOptions); }
	         _tmd__GetSerialPortConfigurationOptions() { _tmd__GetSerialPortConfigurationOptions::soap_default(NULL); }
	virtual ~_tmd__GetSerialPortConfigurationOptions() { }
	friend SOAP_FMAC1 _tmd__GetSerialPortConfigurationOptions * SOAP_FMAC2 soap_instantiate__tmd__GetSerialPortConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:400 */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse (135)
/* tmd:GetSerialPortConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetSerialPortConfigurationOptionsResponse
{
public:
	tmd__SerialPortConfigurationOptions *SerialPortOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tmd:SerialPortConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse (135)
	virtual int soap_type(void) const { return 135; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetSerialPortConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetSerialPortConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetSerialPortConfigurationOptionsResponse); }
	         _tmd__GetSerialPortConfigurationOptionsResponse() { _tmd__GetSerialPortConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetSerialPortConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _tmd__GetSerialPortConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetSerialPortConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:403 */
#ifndef SOAP_TYPE__tmd__SendReceiveSerialCommand
#define SOAP_TYPE__tmd__SendReceiveSerialCommand (136)
/* tmd:SendReceiveSerialCommand complex type: */
class SOAP_CMAC _tmd__SendReceiveSerialCommand
{
public:
	std::string *Token;	/* optional element of XSD type tt:ReferenceToken */
	tmd__SerialData *SerialData;	/* optional element of XSD type tmd:SerialData */
	LONG64 *TimeOut;	/* optional element of XSD type xsd:duration */
	std::string *DataLength;	/* optional element of XSD type xsd:integer */
	std::string *Delimiter;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SendReceiveSerialCommand (136)
	virtual int soap_type(void) const { return 136; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SendReceiveSerialCommand, default initialized and not managed by a soap context
	virtual _tmd__SendReceiveSerialCommand *soap_alloc(void) const { return SOAP_NEW(_tmd__SendReceiveSerialCommand); }
	         _tmd__SendReceiveSerialCommand() { _tmd__SendReceiveSerialCommand::soap_default(NULL); }
	virtual ~_tmd__SendReceiveSerialCommand() { }
	friend SOAP_FMAC1 _tmd__SendReceiveSerialCommand * SOAP_FMAC2 soap_instantiate__tmd__SendReceiveSerialCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:406 */
#ifndef SOAP_TYPE__tmd__SendReceiveSerialCommandResponse
#define SOAP_TYPE__tmd__SendReceiveSerialCommandResponse (137)
/* tmd:SendReceiveSerialCommandResponse complex type: */
class SOAP_CMAC _tmd__SendReceiveSerialCommandResponse
{
public:
	tmd__SerialData *SerialData;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tmd:SerialData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SendReceiveSerialCommandResponse (137)
	virtual int soap_type(void) const { return 137; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SendReceiveSerialCommandResponse, default initialized and not managed by a soap context
	virtual _tmd__SendReceiveSerialCommandResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SendReceiveSerialCommandResponse); }
	         _tmd__SendReceiveSerialCommandResponse() { _tmd__SendReceiveSerialCommandResponse::soap_default(NULL); }
	virtual ~_tmd__SendReceiveSerialCommandResponse() { }
	friend SOAP_FMAC1 _tmd__SendReceiveSerialCommandResponse * SOAP_FMAC2 soap_instantiate__tmd__SendReceiveSerialCommandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5470 */
#ifndef SOAP_TYPE__tds__Service_Capabilities
#define SOAP_TYPE__tds__Service_Capabilities (1008)
/* tds:Service-Capabilities complex type: */
class SOAP_CMAC _tds__Service_Capabilities
{
public:
	/// Return the unique type ID value SOAP_TYPE__tds__Service_Capabilities (1008)
	virtual int soap_type(void) const { return 1008; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__Service_Capabilities, default initialized and not managed by a soap context
	virtual _tds__Service_Capabilities *soap_alloc(void) const { return SOAP_NEW(_tds__Service_Capabilities); }
	         _tds__Service_Capabilities() { _tds__Service_Capabilities::soap_default(NULL); }
	virtual ~_tds__Service_Capabilities() { }
	friend SOAP_FMAC1 _tds__Service_Capabilities * SOAP_FMAC2 soap_instantiate__tds__Service_Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:409 */
#ifndef SOAP_TYPE_tds__Service
#define SOAP_TYPE_tds__Service (138)
/* tds:Service complex type: */
class SOAP_CMAC tds__Service
{
public:
	std::string Namespace;	/* required element of XSD type xsd:anyURI */
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	_tds__Service_Capabilities *Capabilities;	/* optional element of XSD type tds:Service-Capabilities */
	tt__OnvifVersion *Version;	/* required element of XSD type tt:OnvifVersion */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__Service (138)
	virtual int soap_type(void) const { return 138; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__Service, default initialized and not managed by a soap context
	virtual tds__Service *soap_alloc(void) const { return SOAP_NEW(tds__Service); }
	         tds__Service() { tds__Service::soap_default(NULL); }
	virtual ~tds__Service() { }
	friend SOAP_FMAC1 tds__Service * SOAP_FMAC2 soap_instantiate_tds__Service(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:412 */
#ifndef SOAP_TYPE_tds__DeviceServiceCapabilities
#define SOAP_TYPE_tds__DeviceServiceCapabilities (139)
/* tds:DeviceServiceCapabilities complex type: */
class SOAP_CMAC tds__DeviceServiceCapabilities
{
public:
	tds__NetworkCapabilities *Network;	/* required element of XSD type tds:NetworkCapabilities */
	tds__SecurityCapabilities *Security;	/* required element of XSD type tds:SecurityCapabilities */
	tds__SystemCapabilities *System;	/* required element of XSD type tds:SystemCapabilities */
	tds__MiscCapabilities *Misc;	/* optional element of XSD type tds:MiscCapabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__DeviceServiceCapabilities (139)
	virtual int soap_type(void) const { return 139; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__DeviceServiceCapabilities, default initialized and not managed by a soap context
	virtual tds__DeviceServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__DeviceServiceCapabilities); }
	         tds__DeviceServiceCapabilities() { tds__DeviceServiceCapabilities::soap_default(NULL); }
	virtual ~tds__DeviceServiceCapabilities() { }
	friend SOAP_FMAC1 tds__DeviceServiceCapabilities * SOAP_FMAC2 soap_instantiate_tds__DeviceServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:415 */
#ifndef SOAP_TYPE_tds__NetworkCapabilities
#define SOAP_TYPE_tds__NetworkCapabilities (140)
/* tds:NetworkCapabilities complex type: */
class SOAP_CMAC tds__NetworkCapabilities
{
public:
	bool *IPFilter;	/* optional attribute of XSD type xsd:boolean */
	bool *ZeroConfiguration;	/* optional attribute of XSD type xsd:boolean */
	bool *IPVersion6;	/* optional attribute of XSD type xsd:boolean */
	bool *DynDNS;	/* optional attribute of XSD type xsd:boolean */
	bool *Dot11Configuration;	/* optional attribute of XSD type xsd:boolean */
	int *Dot1XConfigurations;	/* optional attribute of XSD type xsd:int */
	bool *HostnameFromDHCP;	/* optional attribute of XSD type xsd:boolean */
	int *NTP;	/* optional attribute of XSD type xsd:int */
	bool *DHCPv6;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__NetworkCapabilities (140)
	virtual int soap_type(void) const { return 140; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__NetworkCapabilities, default initialized and not managed by a soap context
	virtual tds__NetworkCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__NetworkCapabilities); }
	         tds__NetworkCapabilities() { tds__NetworkCapabilities::soap_default(NULL); }
	virtual ~tds__NetworkCapabilities() { }
	friend SOAP_FMAC1 tds__NetworkCapabilities * SOAP_FMAC2 soap_instantiate_tds__NetworkCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:418 */
#ifndef SOAP_TYPE_tds__SecurityCapabilities
#define SOAP_TYPE_tds__SecurityCapabilities (141)
/* tds:SecurityCapabilities complex type: */
class SOAP_CMAC tds__SecurityCapabilities
{
public:
	bool *TLS1_x002e0;	/* optional attribute of XSD type xsd:boolean */
	bool *TLS1_x002e1;	/* optional attribute of XSD type xsd:boolean */
	bool *TLS1_x002e2;	/* optional attribute of XSD type xsd:boolean */
	bool *OnboardKeyGeneration;	/* optional attribute of XSD type xsd:boolean */
	bool *AccessPolicyConfig;	/* optional attribute of XSD type xsd:boolean */
	bool *DefaultAccessPolicy;	/* optional attribute of XSD type xsd:boolean */
	bool *Dot1X;	/* optional attribute of XSD type xsd:boolean */
	bool *RemoteUserHandling;	/* optional attribute of XSD type xsd:boolean */
	bool *X_x002e509Token;	/* optional attribute of XSD type xsd:boolean */
	bool *SAMLToken;	/* optional attribute of XSD type xsd:boolean */
	bool *KerberosToken;	/* optional attribute of XSD type xsd:boolean */
	bool *UsernameToken;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpDigest;	/* optional attribute of XSD type xsd:boolean */
	bool *RELToken;	/* optional attribute of XSD type xsd:boolean */
	std::string *SupportedEAPMethods;	/* optional attribute of XSD type tds:EAPMethodTypes */
	int *MaxUsers;	/* optional attribute of XSD type xsd:int */
	int *MaxUserNameLength;	/* optional attribute of XSD type xsd:int */
	int *MaxPasswordLength;	/* optional attribute of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__SecurityCapabilities (141)
	virtual int soap_type(void) const { return 141; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__SecurityCapabilities, default initialized and not managed by a soap context
	virtual tds__SecurityCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__SecurityCapabilities); }
	         tds__SecurityCapabilities() { tds__SecurityCapabilities::soap_default(NULL); }
	virtual ~tds__SecurityCapabilities() { }
	friend SOAP_FMAC1 tds__SecurityCapabilities * SOAP_FMAC2 soap_instantiate_tds__SecurityCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:421 */
#ifndef SOAP_TYPE_tds__SystemCapabilities
#define SOAP_TYPE_tds__SystemCapabilities (142)
/* tds:SystemCapabilities complex type: */
class SOAP_CMAC tds__SystemCapabilities
{
public:
	bool *DiscoveryResolve;	/* optional attribute of XSD type xsd:boolean */
	bool *DiscoveryBye;	/* optional attribute of XSD type xsd:boolean */
	bool *RemoteDiscovery;	/* optional attribute of XSD type xsd:boolean */
	bool *SystemBackup;	/* optional attribute of XSD type xsd:boolean */
	bool *SystemLogging;	/* optional attribute of XSD type xsd:boolean */
	bool *FirmwareUpgrade;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpFirmwareUpgrade;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpSystemBackup;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpSystemLogging;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpSupportInformation;	/* optional attribute of XSD type xsd:boolean */
	bool *StorageConfiguration;	/* optional attribute of XSD type xsd:boolean */
	int *MaxStorageConfigurations;	/* optional attribute of XSD type xsd:int */
	int *GeoLocationEntries;	/* optional attribute of XSD type xsd:int */
	std::string *AutoGeo;	/* optional attribute of XSD type tt:StringAttrList */
	std::string *StorageTypesSupported;	/* optional attribute of XSD type tt:StringAttrList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__SystemCapabilities (142)
	virtual int soap_type(void) const { return 142; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__SystemCapabilities, default initialized and not managed by a soap context
	virtual tds__SystemCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__SystemCapabilities); }
	         tds__SystemCapabilities() { tds__SystemCapabilities::soap_default(NULL); }
	virtual ~tds__SystemCapabilities() { }
	friend SOAP_FMAC1 tds__SystemCapabilities * SOAP_FMAC2 soap_instantiate_tds__SystemCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:424 */
#ifndef SOAP_TYPE_tds__MiscCapabilities
#define SOAP_TYPE_tds__MiscCapabilities (143)
/* tds:MiscCapabilities complex type: */
class SOAP_CMAC tds__MiscCapabilities
{
public:
	std::string *AuxiliaryCommands;	/* optional attribute of XSD type tt:StringAttrList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__MiscCapabilities (143)
	virtual int soap_type(void) const { return 143; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__MiscCapabilities, default initialized and not managed by a soap context
	virtual tds__MiscCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__MiscCapabilities); }
	         tds__MiscCapabilities() { tds__MiscCapabilities::soap_default(NULL); }
	virtual ~tds__MiscCapabilities() { }
	friend SOAP_FMAC1 tds__MiscCapabilities * SOAP_FMAC2 soap_instantiate_tds__MiscCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5878 */
#ifndef SOAP_TYPE__tds__UserCredential_Extension
#define SOAP_TYPE__tds__UserCredential_Extension (1017)
/* tds:UserCredential-Extension complex type: */
class SOAP_CMAC _tds__UserCredential_Extension
{
public:
	/// Return the unique type ID value SOAP_TYPE__tds__UserCredential_Extension (1017)
	virtual int soap_type(void) const { return 1017; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__UserCredential_Extension, default initialized and not managed by a soap context
	virtual _tds__UserCredential_Extension *soap_alloc(void) const { return SOAP_NEW(_tds__UserCredential_Extension); }
	         _tds__UserCredential_Extension() { _tds__UserCredential_Extension::soap_default(NULL); }
	virtual ~_tds__UserCredential_Extension() { }
	friend SOAP_FMAC1 _tds__UserCredential_Extension * SOAP_FMAC2 soap_instantiate__tds__UserCredential_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:427 */
#ifndef SOAP_TYPE_tds__UserCredential
#define SOAP_TYPE_tds__UserCredential (144)
/* tds:UserCredential complex type: */
class SOAP_CMAC tds__UserCredential
{
public:
	std::string UserName;	/* required element of XSD type xsd:string */
	std::string *Password;	/* optional element of XSD type xsd:string */
	_tds__UserCredential_Extension *Extension;	/* optional element of XSD type tds:UserCredential-Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__UserCredential (144)
	virtual int soap_type(void) const { return 144; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__UserCredential, default initialized and not managed by a soap context
	virtual tds__UserCredential *soap_alloc(void) const { return SOAP_NEW(tds__UserCredential); }
	         tds__UserCredential() { tds__UserCredential::soap_default(NULL); }
	virtual ~tds__UserCredential() { }
	friend SOAP_FMAC1 tds__UserCredential * SOAP_FMAC2 soap_instantiate_tds__UserCredential(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5930 */
#ifndef SOAP_TYPE__tds__StorageConfigurationData_Extension
#define SOAP_TYPE__tds__StorageConfigurationData_Extension (1021)
/* tds:StorageConfigurationData-Extension complex type: */
class SOAP_CMAC _tds__StorageConfigurationData_Extension
{
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StorageConfigurationData_Extension (1021)
	virtual int soap_type(void) const { return 1021; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StorageConfigurationData_Extension, default initialized and not managed by a soap context
	virtual _tds__StorageConfigurationData_Extension *soap_alloc(void) const { return SOAP_NEW(_tds__StorageConfigurationData_Extension); }
	         _tds__StorageConfigurationData_Extension() { _tds__StorageConfigurationData_Extension::soap_default(NULL); }
	virtual ~_tds__StorageConfigurationData_Extension() { }
	friend SOAP_FMAC1 _tds__StorageConfigurationData_Extension * SOAP_FMAC2 soap_instantiate__tds__StorageConfigurationData_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:430 */
#ifndef SOAP_TYPE_tds__StorageConfigurationData
#define SOAP_TYPE_tds__StorageConfigurationData (145)
/* tds:StorageConfigurationData complex type: */
class SOAP_CMAC tds__StorageConfigurationData
{
public:
	std::string *LocalPath;	/* optional element of XSD type xsd:anyURI */
	std::string *StorageUri;	/* optional element of XSD type xsd:anyURI */
	tds__UserCredential *User;	/* optional element of XSD type tds:UserCredential */
	_tds__StorageConfigurationData_Extension *Extension;	/* optional element of XSD type tds:StorageConfigurationData-Extension */
	std::string type;	/* required attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__StorageConfigurationData (145)
	virtual int soap_type(void) const { return 145; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__StorageConfigurationData, default initialized and not managed by a soap context
	virtual tds__StorageConfigurationData *soap_alloc(void) const { return SOAP_NEW(tds__StorageConfigurationData); }
	         tds__StorageConfigurationData() { tds__StorageConfigurationData::soap_default(NULL); }
	virtual ~tds__StorageConfigurationData() { }
	friend SOAP_FMAC1 tds__StorageConfigurationData * SOAP_FMAC2 soap_instantiate_tds__StorageConfigurationData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:436 */
#ifndef SOAP_TYPE__tds__GetServices
#define SOAP_TYPE__tds__GetServices (147)
/* tds:GetServices complex type: */
class SOAP_CMAC _tds__GetServices
{
public:
	bool IncludeCapability;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetServices (147)
	virtual int soap_type(void) const { return 147; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetServices, default initialized and not managed by a soap context
	virtual _tds__GetServices *soap_alloc(void) const { return SOAP_NEW(_tds__GetServices); }
	         _tds__GetServices() { _tds__GetServices::soap_default(NULL); }
	virtual ~_tds__GetServices() { }
	friend SOAP_FMAC1 _tds__GetServices * SOAP_FMAC2 soap_instantiate__tds__GetServices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:439 */
#ifndef SOAP_TYPE__tds__GetServicesResponse
#define SOAP_TYPE__tds__GetServicesResponse (148)
/* tds:GetServicesResponse complex type: */
class SOAP_CMAC _tds__GetServicesResponse
{
public:
	std::vector<tds__Service *> Service;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tds:Service */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetServicesResponse (148)
	virtual int soap_type(void) const { return 148; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetServicesResponse, default initialized and not managed by a soap context
	virtual _tds__GetServicesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetServicesResponse); }
	         _tds__GetServicesResponse() { _tds__GetServicesResponse::soap_default(NULL); }
	virtual ~_tds__GetServicesResponse() { }
	friend SOAP_FMAC1 _tds__GetServicesResponse * SOAP_FMAC2 soap_instantiate__tds__GetServicesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:442 */
#ifndef SOAP_TYPE__tds__GetServiceCapabilities
#define SOAP_TYPE__tds__GetServiceCapabilities (149)
/* tds:GetServiceCapabilities complex type: */
class SOAP_CMAC _tds__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetServiceCapabilities (149)
	virtual int soap_type(void) const { return 149; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _tds__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_tds__GetServiceCapabilities); }
	         _tds__GetServiceCapabilities() { _tds__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tds__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _tds__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tds__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:445 */
#ifndef SOAP_TYPE__tds__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tds__GetServiceCapabilitiesResponse (150)
/* tds:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _tds__GetServiceCapabilitiesResponse
{
public:
	tds__DeviceServiceCapabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tds:DeviceServiceCapabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetServiceCapabilitiesResponse (150)
	virtual int soap_type(void) const { return 150; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tds__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetServiceCapabilitiesResponse); }
	         _tds__GetServiceCapabilitiesResponse() { _tds__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tds__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _tds__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:448 */
#ifndef SOAP_TYPE__tds__GetDeviceInformation
#define SOAP_TYPE__tds__GetDeviceInformation (151)
/* tds:GetDeviceInformation complex type: */
class SOAP_CMAC _tds__GetDeviceInformation
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDeviceInformation (151)
	virtual int soap_type(void) const { return 151; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDeviceInformation, default initialized and not managed by a soap context
	virtual _tds__GetDeviceInformation *soap_alloc(void) const { return SOAP_NEW(_tds__GetDeviceInformation); }
	         _tds__GetDeviceInformation() { _tds__GetDeviceInformation::soap_default(NULL); }
	virtual ~_tds__GetDeviceInformation() { }
	friend SOAP_FMAC1 _tds__GetDeviceInformation * SOAP_FMAC2 soap_instantiate__tds__GetDeviceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:451 */
#ifndef SOAP_TYPE__tds__GetDeviceInformationResponse
#define SOAP_TYPE__tds__GetDeviceInformationResponse (152)
/* tds:GetDeviceInformationResponse complex type: */
class SOAP_CMAC _tds__GetDeviceInformationResponse
{
public:
	std::string Manufacturer;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:string */
	std::string Model;	/* required element of XSD type xsd:string */
	std::string FirmwareVersion;	/* required element of XSD type xsd:string */
	std::string SerialNumber;	/* required element of XSD type xsd:string */
	std::string HardwareId;	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDeviceInformationResponse (152)
	virtual int soap_type(void) const { return 152; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDeviceInformationResponse, default initialized and not managed by a soap context
	virtual _tds__GetDeviceInformationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDeviceInformationResponse); }
	         _tds__GetDeviceInformationResponse() { _tds__GetDeviceInformationResponse::soap_default(NULL); }
	virtual ~_tds__GetDeviceInformationResponse() { }
	friend SOAP_FMAC1 _tds__GetDeviceInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetDeviceInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:454 */
#ifndef SOAP_TYPE__tds__SetSystemDateAndTime
#define SOAP_TYPE__tds__SetSystemDateAndTime (153)
/* tds:SetSystemDateAndTime complex type: */
class SOAP_CMAC _tds__SetSystemDateAndTime
{
public:
	enum tt__SetDateTimeType DateTimeType;	/* required element of XSD type tt:SetDateTimeType */
	bool DaylightSavings;	/* required element of XSD type xsd:boolean */
	tt__TimeZone *TimeZone;	/* optional element of XSD type tt:TimeZone */
	tt__DateTime *UTCDateTime;	/* optional element of XSD type tt:DateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetSystemDateAndTime (153)
	virtual int soap_type(void) const { return 153; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetSystemDateAndTime, default initialized and not managed by a soap context
	virtual _tds__SetSystemDateAndTime *soap_alloc(void) const { return SOAP_NEW(_tds__SetSystemDateAndTime); }
	         _tds__SetSystemDateAndTime() { _tds__SetSystemDateAndTime::soap_default(NULL); }
	virtual ~_tds__SetSystemDateAndTime() { }
	friend SOAP_FMAC1 _tds__SetSystemDateAndTime * SOAP_FMAC2 soap_instantiate__tds__SetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:457 */
#ifndef SOAP_TYPE__tds__SetSystemDateAndTimeResponse
#define SOAP_TYPE__tds__SetSystemDateAndTimeResponse (154)
/* tds:SetSystemDateAndTimeResponse complex type: */
class SOAP_CMAC _tds__SetSystemDateAndTimeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetSystemDateAndTimeResponse (154)
	virtual int soap_type(void) const { return 154; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetSystemDateAndTimeResponse, default initialized and not managed by a soap context
	virtual _tds__SetSystemDateAndTimeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetSystemDateAndTimeResponse); }
	         _tds__SetSystemDateAndTimeResponse() { _tds__SetSystemDateAndTimeResponse::soap_default(NULL); }
	virtual ~_tds__SetSystemDateAndTimeResponse() { }
	friend SOAP_FMAC1 _tds__SetSystemDateAndTimeResponse * SOAP_FMAC2 soap_instantiate__tds__SetSystemDateAndTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:460 */
#ifndef SOAP_TYPE__tds__GetSystemDateAndTime
#define SOAP_TYPE__tds__GetSystemDateAndTime (155)
/* tds:GetSystemDateAndTime complex type: */
class SOAP_CMAC _tds__GetSystemDateAndTime
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemDateAndTime (155)
	virtual int soap_type(void) const { return 155; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemDateAndTime, default initialized and not managed by a soap context
	virtual _tds__GetSystemDateAndTime *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemDateAndTime); }
	         _tds__GetSystemDateAndTime() { _tds__GetSystemDateAndTime::soap_default(NULL); }
	virtual ~_tds__GetSystemDateAndTime() { }
	friend SOAP_FMAC1 _tds__GetSystemDateAndTime * SOAP_FMAC2 soap_instantiate__tds__GetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:463 */
#ifndef SOAP_TYPE__tds__GetSystemDateAndTimeResponse
#define SOAP_TYPE__tds__GetSystemDateAndTimeResponse (156)
/* tds:GetSystemDateAndTimeResponse complex type: */
class SOAP_CMAC _tds__GetSystemDateAndTimeResponse
{
public:
	tt__SystemDateTime *SystemDateAndTime;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:SystemDateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemDateAndTimeResponse (156)
	virtual int soap_type(void) const { return 156; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemDateAndTimeResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemDateAndTimeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemDateAndTimeResponse); }
	         _tds__GetSystemDateAndTimeResponse() { _tds__GetSystemDateAndTimeResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemDateAndTimeResponse() { }
	friend SOAP_FMAC1 _tds__GetSystemDateAndTimeResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemDateAndTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:466 */
#ifndef SOAP_TYPE__tds__SetSystemFactoryDefault
#define SOAP_TYPE__tds__SetSystemFactoryDefault (157)
/* tds:SetSystemFactoryDefault complex type: */
class SOAP_CMAC _tds__SetSystemFactoryDefault
{
public:
	enum tt__FactoryDefaultType FactoryDefault;	/* required element of XSD type tt:FactoryDefaultType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetSystemFactoryDefault (157)
	virtual int soap_type(void) const { return 157; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetSystemFactoryDefault, default initialized and not managed by a soap context
	virtual _tds__SetSystemFactoryDefault *soap_alloc(void) const { return SOAP_NEW(_tds__SetSystemFactoryDefault); }
	         _tds__SetSystemFactoryDefault() { _tds__SetSystemFactoryDefault::soap_default(NULL); }
	virtual ~_tds__SetSystemFactoryDefault() { }
	friend SOAP_FMAC1 _tds__SetSystemFactoryDefault * SOAP_FMAC2 soap_instantiate__tds__SetSystemFactoryDefault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:469 */
#ifndef SOAP_TYPE__tds__SetSystemFactoryDefaultResponse
#define SOAP_TYPE__tds__SetSystemFactoryDefaultResponse (158)
/* tds:SetSystemFactoryDefaultResponse complex type: */
class SOAP_CMAC _tds__SetSystemFactoryDefaultResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetSystemFactoryDefaultResponse (158)
	virtual int soap_type(void) const { return 158; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetSystemFactoryDefaultResponse, default initialized and not managed by a soap context
	virtual _tds__SetSystemFactoryDefaultResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetSystemFactoryDefaultResponse); }
	         _tds__SetSystemFactoryDefaultResponse() { _tds__SetSystemFactoryDefaultResponse::soap_default(NULL); }
	virtual ~_tds__SetSystemFactoryDefaultResponse() { }
	friend SOAP_FMAC1 _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC2 soap_instantiate__tds__SetSystemFactoryDefaultResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:472 */
#ifndef SOAP_TYPE__tds__UpgradeSystemFirmware
#define SOAP_TYPE__tds__UpgradeSystemFirmware (159)
/* tds:UpgradeSystemFirmware complex type: */
class SOAP_CMAC _tds__UpgradeSystemFirmware
{
public:
	tt__AttachmentData *Firmware;	/* required element of XSD type tt:AttachmentData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__UpgradeSystemFirmware (159)
	virtual int soap_type(void) const { return 159; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__UpgradeSystemFirmware, default initialized and not managed by a soap context
	virtual _tds__UpgradeSystemFirmware *soap_alloc(void) const { return SOAP_NEW(_tds__UpgradeSystemFirmware); }
	         _tds__UpgradeSystemFirmware() { _tds__UpgradeSystemFirmware::soap_default(NULL); }
	virtual ~_tds__UpgradeSystemFirmware() { }
	friend SOAP_FMAC1 _tds__UpgradeSystemFirmware * SOAP_FMAC2 soap_instantiate__tds__UpgradeSystemFirmware(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:475 */
#ifndef SOAP_TYPE__tds__UpgradeSystemFirmwareResponse
#define SOAP_TYPE__tds__UpgradeSystemFirmwareResponse (160)
/* tds:UpgradeSystemFirmwareResponse complex type: */
class SOAP_CMAC _tds__UpgradeSystemFirmwareResponse
{
public:
	std::string *Message;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__UpgradeSystemFirmwareResponse (160)
	virtual int soap_type(void) const { return 160; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__UpgradeSystemFirmwareResponse, default initialized and not managed by a soap context
	virtual _tds__UpgradeSystemFirmwareResponse *soap_alloc(void) const { return SOAP_NEW(_tds__UpgradeSystemFirmwareResponse); }
	         _tds__UpgradeSystemFirmwareResponse() { _tds__UpgradeSystemFirmwareResponse::soap_default(NULL); }
	virtual ~_tds__UpgradeSystemFirmwareResponse() { }
	friend SOAP_FMAC1 _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC2 soap_instantiate__tds__UpgradeSystemFirmwareResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:478 */
#ifndef SOAP_TYPE__tds__SystemReboot
#define SOAP_TYPE__tds__SystemReboot (161)
/* tds:SystemReboot complex type: */
class SOAP_CMAC _tds__SystemReboot
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SystemReboot (161)
	virtual int soap_type(void) const { return 161; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SystemReboot, default initialized and not managed by a soap context
	virtual _tds__SystemReboot *soap_alloc(void) const { return SOAP_NEW(_tds__SystemReboot); }
	         _tds__SystemReboot() { _tds__SystemReboot::soap_default(NULL); }
	virtual ~_tds__SystemReboot() { }
	friend SOAP_FMAC1 _tds__SystemReboot * SOAP_FMAC2 soap_instantiate__tds__SystemReboot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:481 */
#ifndef SOAP_TYPE__tds__SystemRebootResponse
#define SOAP_TYPE__tds__SystemRebootResponse (162)
/* tds:SystemRebootResponse complex type: */
class SOAP_CMAC _tds__SystemRebootResponse
{
public:
	std::string Message;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SystemRebootResponse (162)
	virtual int soap_type(void) const { return 162; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SystemRebootResponse, default initialized and not managed by a soap context
	virtual _tds__SystemRebootResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SystemRebootResponse); }
	         _tds__SystemRebootResponse() { _tds__SystemRebootResponse::soap_default(NULL); }
	virtual ~_tds__SystemRebootResponse() { }
	friend SOAP_FMAC1 _tds__SystemRebootResponse * SOAP_FMAC2 soap_instantiate__tds__SystemRebootResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:484 */
#ifndef SOAP_TYPE__tds__RestoreSystem
#define SOAP_TYPE__tds__RestoreSystem (163)
/* tds:RestoreSystem complex type: */
class SOAP_CMAC _tds__RestoreSystem
{
public:
	std::vector<tt__BackupFile *> BackupFiles;	/* required element of XSD type tt:BackupFile */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RestoreSystem (163)
	virtual int soap_type(void) const { return 163; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RestoreSystem, default initialized and not managed by a soap context
	virtual _tds__RestoreSystem *soap_alloc(void) const { return SOAP_NEW(_tds__RestoreSystem); }
	         _tds__RestoreSystem() { _tds__RestoreSystem::soap_default(NULL); }
	virtual ~_tds__RestoreSystem() { }
	friend SOAP_FMAC1 _tds__RestoreSystem * SOAP_FMAC2 soap_instantiate__tds__RestoreSystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:487 */
#ifndef SOAP_TYPE__tds__RestoreSystemResponse
#define SOAP_TYPE__tds__RestoreSystemResponse (164)
/* tds:RestoreSystemResponse complex type: */
class SOAP_CMAC _tds__RestoreSystemResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RestoreSystemResponse (164)
	virtual int soap_type(void) const { return 164; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RestoreSystemResponse, default initialized and not managed by a soap context
	virtual _tds__RestoreSystemResponse *soap_alloc(void) const { return SOAP_NEW(_tds__RestoreSystemResponse); }
	         _tds__RestoreSystemResponse() { _tds__RestoreSystemResponse::soap_default(NULL); }
	virtual ~_tds__RestoreSystemResponse() { }
	friend SOAP_FMAC1 _tds__RestoreSystemResponse * SOAP_FMAC2 soap_instantiate__tds__RestoreSystemResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:490 */
#ifndef SOAP_TYPE__tds__GetSystemBackup
#define SOAP_TYPE__tds__GetSystemBackup (165)
/* tds:GetSystemBackup complex type: */
class SOAP_CMAC _tds__GetSystemBackup
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemBackup (165)
	virtual int soap_type(void) const { return 165; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemBackup, default initialized and not managed by a soap context
	virtual _tds__GetSystemBackup *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemBackup); }
	         _tds__GetSystemBackup() { _tds__GetSystemBackup::soap_default(NULL); }
	virtual ~_tds__GetSystemBackup() { }
	friend SOAP_FMAC1 _tds__GetSystemBackup * SOAP_FMAC2 soap_instantiate__tds__GetSystemBackup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:493 */
#ifndef SOAP_TYPE__tds__GetSystemBackupResponse
#define SOAP_TYPE__tds__GetSystemBackupResponse (166)
/* tds:GetSystemBackupResponse complex type: */
class SOAP_CMAC _tds__GetSystemBackupResponse
{
public:
	std::vector<tt__BackupFile *> BackupFiles;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:BackupFile */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemBackupResponse (166)
	virtual int soap_type(void) const { return 166; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemBackupResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemBackupResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemBackupResponse); }
	         _tds__GetSystemBackupResponse() { _tds__GetSystemBackupResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemBackupResponse() { }
	friend SOAP_FMAC1 _tds__GetSystemBackupResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemBackupResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:496 */
#ifndef SOAP_TYPE__tds__GetSystemSupportInformation
#define SOAP_TYPE__tds__GetSystemSupportInformation (167)
/* tds:GetSystemSupportInformation complex type: */
class SOAP_CMAC _tds__GetSystemSupportInformation
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemSupportInformation (167)
	virtual int soap_type(void) const { return 167; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemSupportInformation, default initialized and not managed by a soap context
	virtual _tds__GetSystemSupportInformation *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemSupportInformation); }
	         _tds__GetSystemSupportInformation() { _tds__GetSystemSupportInformation::soap_default(NULL); }
	virtual ~_tds__GetSystemSupportInformation() { }
	friend SOAP_FMAC1 _tds__GetSystemSupportInformation * SOAP_FMAC2 soap_instantiate__tds__GetSystemSupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:499 */
#ifndef SOAP_TYPE__tds__GetSystemSupportInformationResponse
#define SOAP_TYPE__tds__GetSystemSupportInformationResponse (168)
/* tds:GetSystemSupportInformationResponse complex type: */
class SOAP_CMAC _tds__GetSystemSupportInformationResponse
{
public:
	tt__SupportInformation *SupportInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:SupportInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemSupportInformationResponse (168)
	virtual int soap_type(void) const { return 168; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemSupportInformationResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemSupportInformationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemSupportInformationResponse); }
	         _tds__GetSystemSupportInformationResponse() { _tds__GetSystemSupportInformationResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemSupportInformationResponse() { }
	friend SOAP_FMAC1 _tds__GetSystemSupportInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemSupportInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:502 */
#ifndef SOAP_TYPE__tds__GetSystemLog
#define SOAP_TYPE__tds__GetSystemLog (169)
/* tds:GetSystemLog complex type: */
class SOAP_CMAC _tds__GetSystemLog
{
public:
	enum tt__SystemLogType LogType;	/* required element of XSD type tt:SystemLogType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemLog (169)
	virtual int soap_type(void) const { return 169; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemLog, default initialized and not managed by a soap context
	virtual _tds__GetSystemLog *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemLog); }
	         _tds__GetSystemLog() { _tds__GetSystemLog::soap_default(NULL); }
	virtual ~_tds__GetSystemLog() { }
	friend SOAP_FMAC1 _tds__GetSystemLog * SOAP_FMAC2 soap_instantiate__tds__GetSystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:505 */
#ifndef SOAP_TYPE__tds__GetSystemLogResponse
#define SOAP_TYPE__tds__GetSystemLogResponse (170)
/* tds:GetSystemLogResponse complex type: */
class SOAP_CMAC _tds__GetSystemLogResponse
{
public:
	tt__SystemLog *SystemLog;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:SystemLog */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemLogResponse (170)
	virtual int soap_type(void) const { return 170; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemLogResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemLogResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemLogResponse); }
	         _tds__GetSystemLogResponse() { _tds__GetSystemLogResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemLogResponse() { }
	friend SOAP_FMAC1 _tds__GetSystemLogResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemLogResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:508 */
#ifndef SOAP_TYPE__tds__GetScopes
#define SOAP_TYPE__tds__GetScopes (171)
/* tds:GetScopes complex type: */
class SOAP_CMAC _tds__GetScopes
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetScopes (171)
	virtual int soap_type(void) const { return 171; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetScopes, default initialized and not managed by a soap context
	virtual _tds__GetScopes *soap_alloc(void) const { return SOAP_NEW(_tds__GetScopes); }
	         _tds__GetScopes() { _tds__GetScopes::soap_default(NULL); }
	virtual ~_tds__GetScopes() { }
	friend SOAP_FMAC1 _tds__GetScopes * SOAP_FMAC2 soap_instantiate__tds__GetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:511 */
#ifndef SOAP_TYPE__tds__GetScopesResponse
#define SOAP_TYPE__tds__GetScopesResponse (172)
/* tds:GetScopesResponse complex type: */
class SOAP_CMAC _tds__GetScopesResponse
{
public:
	std::vector<tt__Scope *> Scopes;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Scope */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetScopesResponse (172)
	virtual int soap_type(void) const { return 172; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetScopesResponse, default initialized and not managed by a soap context
	virtual _tds__GetScopesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetScopesResponse); }
	         _tds__GetScopesResponse() { _tds__GetScopesResponse::soap_default(NULL); }
	virtual ~_tds__GetScopesResponse() { }
	friend SOAP_FMAC1 _tds__GetScopesResponse * SOAP_FMAC2 soap_instantiate__tds__GetScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:514 */
#ifndef SOAP_TYPE__tds__SetScopes
#define SOAP_TYPE__tds__SetScopes (173)
/* tds:SetScopes complex type: */
class SOAP_CMAC _tds__SetScopes
{
public:
	std::vector<std::string> Scopes;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetScopes (173)
	virtual int soap_type(void) const { return 173; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetScopes, default initialized and not managed by a soap context
	virtual _tds__SetScopes *soap_alloc(void) const { return SOAP_NEW(_tds__SetScopes); }
	         _tds__SetScopes() { _tds__SetScopes::soap_default(NULL); }
	virtual ~_tds__SetScopes() { }
	friend SOAP_FMAC1 _tds__SetScopes * SOAP_FMAC2 soap_instantiate__tds__SetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:517 */
#ifndef SOAP_TYPE__tds__SetScopesResponse
#define SOAP_TYPE__tds__SetScopesResponse (174)
/* tds:SetScopesResponse complex type: */
class SOAP_CMAC _tds__SetScopesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetScopesResponse (174)
	virtual int soap_type(void) const { return 174; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetScopesResponse, default initialized and not managed by a soap context
	virtual _tds__SetScopesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetScopesResponse); }
	         _tds__SetScopesResponse() { _tds__SetScopesResponse::soap_default(NULL); }
	virtual ~_tds__SetScopesResponse() { }
	friend SOAP_FMAC1 _tds__SetScopesResponse * SOAP_FMAC2 soap_instantiate__tds__SetScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:520 */
#ifndef SOAP_TYPE__tds__AddScopes
#define SOAP_TYPE__tds__AddScopes (175)
/* tds:AddScopes complex type: */
class SOAP_CMAC _tds__AddScopes
{
public:
	std::vector<std::string> ScopeItem;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__AddScopes (175)
	virtual int soap_type(void) const { return 175; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__AddScopes, default initialized and not managed by a soap context
	virtual _tds__AddScopes *soap_alloc(void) const { return SOAP_NEW(_tds__AddScopes); }
	         _tds__AddScopes() { _tds__AddScopes::soap_default(NULL); }
	virtual ~_tds__AddScopes() { }
	friend SOAP_FMAC1 _tds__AddScopes * SOAP_FMAC2 soap_instantiate__tds__AddScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:523 */
#ifndef SOAP_TYPE__tds__AddScopesResponse
#define SOAP_TYPE__tds__AddScopesResponse (176)
/* tds:AddScopesResponse complex type: */
class SOAP_CMAC _tds__AddScopesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__AddScopesResponse (176)
	virtual int soap_type(void) const { return 176; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__AddScopesResponse, default initialized and not managed by a soap context
	virtual _tds__AddScopesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__AddScopesResponse); }
	         _tds__AddScopesResponse() { _tds__AddScopesResponse::soap_default(NULL); }
	virtual ~_tds__AddScopesResponse() { }
	friend SOAP_FMAC1 _tds__AddScopesResponse * SOAP_FMAC2 soap_instantiate__tds__AddScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:526 */
#ifndef SOAP_TYPE__tds__RemoveScopes
#define SOAP_TYPE__tds__RemoveScopes (177)
/* tds:RemoveScopes complex type: */
class SOAP_CMAC _tds__RemoveScopes
{
public:
	std::vector<std::string> ScopeItem;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RemoveScopes (177)
	virtual int soap_type(void) const { return 177; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RemoveScopes, default initialized and not managed by a soap context
	virtual _tds__RemoveScopes *soap_alloc(void) const { return SOAP_NEW(_tds__RemoveScopes); }
	         _tds__RemoveScopes() { _tds__RemoveScopes::soap_default(NULL); }
	virtual ~_tds__RemoveScopes() { }
	friend SOAP_FMAC1 _tds__RemoveScopes * SOAP_FMAC2 soap_instantiate__tds__RemoveScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:529 */
#ifndef SOAP_TYPE__tds__RemoveScopesResponse
#define SOAP_TYPE__tds__RemoveScopesResponse (178)
/* tds:RemoveScopesResponse complex type: */
class SOAP_CMAC _tds__RemoveScopesResponse
{
public:
	std::vector<std::string> ScopeItem;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RemoveScopesResponse (178)
	virtual int soap_type(void) const { return 178; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RemoveScopesResponse, default initialized and not managed by a soap context
	virtual _tds__RemoveScopesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__RemoveScopesResponse); }
	         _tds__RemoveScopesResponse() { _tds__RemoveScopesResponse::soap_default(NULL); }
	virtual ~_tds__RemoveScopesResponse() { }
	friend SOAP_FMAC1 _tds__RemoveScopesResponse * SOAP_FMAC2 soap_instantiate__tds__RemoveScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:532 */
#ifndef SOAP_TYPE__tds__GetDiscoveryMode
#define SOAP_TYPE__tds__GetDiscoveryMode (179)
/* tds:GetDiscoveryMode complex type: */
class SOAP_CMAC _tds__GetDiscoveryMode
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDiscoveryMode (179)
	virtual int soap_type(void) const { return 179; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDiscoveryMode, default initialized and not managed by a soap context
	virtual _tds__GetDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_tds__GetDiscoveryMode); }
	         _tds__GetDiscoveryMode() { _tds__GetDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__GetDiscoveryMode() { }
	friend SOAP_FMAC1 _tds__GetDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__GetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:535 */
#ifndef SOAP_TYPE__tds__GetDiscoveryModeResponse
#define SOAP_TYPE__tds__GetDiscoveryModeResponse (180)
/* tds:GetDiscoveryModeResponse complex type: */
class SOAP_CMAC _tds__GetDiscoveryModeResponse
{
public:
	enum tt__DiscoveryMode DiscoveryMode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:DiscoveryMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDiscoveryModeResponse (180)
	virtual int soap_type(void) const { return 180; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDiscoveryModeResponse, default initialized and not managed by a soap context
	virtual _tds__GetDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDiscoveryModeResponse); }
	         _tds__GetDiscoveryModeResponse() { _tds__GetDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__GetDiscoveryModeResponse() { }
	friend SOAP_FMAC1 _tds__GetDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:538 */
#ifndef SOAP_TYPE__tds__SetDiscoveryMode
#define SOAP_TYPE__tds__SetDiscoveryMode (181)
/* tds:SetDiscoveryMode complex type: */
class SOAP_CMAC _tds__SetDiscoveryMode
{
public:
	enum tt__DiscoveryMode DiscoveryMode;	/* required element of XSD type tt:DiscoveryMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDiscoveryMode (181)
	virtual int soap_type(void) const { return 181; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDiscoveryMode, default initialized and not managed by a soap context
	virtual _tds__SetDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_tds__SetDiscoveryMode); }
	         _tds__SetDiscoveryMode() { _tds__SetDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__SetDiscoveryMode() { }
	friend SOAP_FMAC1 _tds__SetDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__SetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:541 */
#ifndef SOAP_TYPE__tds__SetDiscoveryModeResponse
#define SOAP_TYPE__tds__SetDiscoveryModeResponse (182)
/* tds:SetDiscoveryModeResponse complex type: */
class SOAP_CMAC _tds__SetDiscoveryModeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDiscoveryModeResponse (182)
	virtual int soap_type(void) const { return 182; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDiscoveryModeResponse, default initialized and not managed by a soap context
	virtual _tds__SetDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDiscoveryModeResponse); }
	         _tds__SetDiscoveryModeResponse() { _tds__SetDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__SetDiscoveryModeResponse() { }
	friend SOAP_FMAC1 _tds__SetDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:544 */
#ifndef SOAP_TYPE__tds__GetRemoteDiscoveryMode
#define SOAP_TYPE__tds__GetRemoteDiscoveryMode (183)
/* tds:GetRemoteDiscoveryMode complex type: */
class SOAP_CMAC _tds__GetRemoteDiscoveryMode
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRemoteDiscoveryMode (183)
	virtual int soap_type(void) const { return 183; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRemoteDiscoveryMode, default initialized and not managed by a soap context
	virtual _tds__GetRemoteDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_tds__GetRemoteDiscoveryMode); }
	         _tds__GetRemoteDiscoveryMode() { _tds__GetRemoteDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__GetRemoteDiscoveryMode() { }
	friend SOAP_FMAC1 _tds__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__GetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:547 */
#ifndef SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse
#define SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse (184)
/* tds:GetRemoteDiscoveryModeResponse complex type: */
class SOAP_CMAC _tds__GetRemoteDiscoveryModeResponse
{
public:
	enum tt__DiscoveryMode RemoteDiscoveryMode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:DiscoveryMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse (184)
	virtual int soap_type(void) const { return 184; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRemoteDiscoveryModeResponse, default initialized and not managed by a soap context
	virtual _tds__GetRemoteDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetRemoteDiscoveryModeResponse); }
	         _tds__GetRemoteDiscoveryModeResponse() { _tds__GetRemoteDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__GetRemoteDiscoveryModeResponse() { }
	friend SOAP_FMAC1 _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetRemoteDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:550 */
#ifndef SOAP_TYPE__tds__SetRemoteDiscoveryMode
#define SOAP_TYPE__tds__SetRemoteDiscoveryMode (185)
/* tds:SetRemoteDiscoveryMode complex type: */
class SOAP_CMAC _tds__SetRemoteDiscoveryMode
{
public:
	enum tt__DiscoveryMode RemoteDiscoveryMode;	/* required element of XSD type tt:DiscoveryMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRemoteDiscoveryMode (185)
	virtual int soap_type(void) const { return 185; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRemoteDiscoveryMode, default initialized and not managed by a soap context
	virtual _tds__SetRemoteDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_tds__SetRemoteDiscoveryMode); }
	         _tds__SetRemoteDiscoveryMode() { _tds__SetRemoteDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__SetRemoteDiscoveryMode() { }
	friend SOAP_FMAC1 _tds__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__SetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:553 */
#ifndef SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse
#define SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse (186)
/* tds:SetRemoteDiscoveryModeResponse complex type: */
class SOAP_CMAC _tds__SetRemoteDiscoveryModeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse (186)
	virtual int soap_type(void) const { return 186; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRemoteDiscoveryModeResponse, default initialized and not managed by a soap context
	virtual _tds__SetRemoteDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetRemoteDiscoveryModeResponse); }
	         _tds__SetRemoteDiscoveryModeResponse() { _tds__SetRemoteDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__SetRemoteDiscoveryModeResponse() { }
	friend SOAP_FMAC1 _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetRemoteDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:556 */
#ifndef SOAP_TYPE__tds__GetDPAddresses
#define SOAP_TYPE__tds__GetDPAddresses (187)
/* tds:GetDPAddresses complex type: */
class SOAP_CMAC _tds__GetDPAddresses
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDPAddresses (187)
	virtual int soap_type(void) const { return 187; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDPAddresses, default initialized and not managed by a soap context
	virtual _tds__GetDPAddresses *soap_alloc(void) const { return SOAP_NEW(_tds__GetDPAddresses); }
	         _tds__GetDPAddresses() { _tds__GetDPAddresses::soap_default(NULL); }
	virtual ~_tds__GetDPAddresses() { }
	friend SOAP_FMAC1 _tds__GetDPAddresses * SOAP_FMAC2 soap_instantiate__tds__GetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:559 */
#ifndef SOAP_TYPE__tds__GetDPAddressesResponse
#define SOAP_TYPE__tds__GetDPAddressesResponse (188)
/* tds:GetDPAddressesResponse complex type: */
class SOAP_CMAC _tds__GetDPAddressesResponse
{
public:
	std::vector<tt__NetworkHost *> DPAddress;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:NetworkHost */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDPAddressesResponse (188)
	virtual int soap_type(void) const { return 188; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDPAddressesResponse, default initialized and not managed by a soap context
	virtual _tds__GetDPAddressesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDPAddressesResponse); }
	         _tds__GetDPAddressesResponse() { _tds__GetDPAddressesResponse::soap_default(NULL); }
	virtual ~_tds__GetDPAddressesResponse() { }
	friend SOAP_FMAC1 _tds__GetDPAddressesResponse * SOAP_FMAC2 soap_instantiate__tds__GetDPAddressesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:562 */
#ifndef SOAP_TYPE__tds__SetDPAddresses
#define SOAP_TYPE__tds__SetDPAddresses (189)
/* tds:SetDPAddresses complex type: */
class SOAP_CMAC _tds__SetDPAddresses
{
public:
	std::vector<tt__NetworkHost *> DPAddress;	/* optional element of XSD type tt:NetworkHost */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDPAddresses (189)
	virtual int soap_type(void) const { return 189; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDPAddresses, default initialized and not managed by a soap context
	virtual _tds__SetDPAddresses *soap_alloc(void) const { return SOAP_NEW(_tds__SetDPAddresses); }
	         _tds__SetDPAddresses() { _tds__SetDPAddresses::soap_default(NULL); }
	virtual ~_tds__SetDPAddresses() { }
	friend SOAP_FMAC1 _tds__SetDPAddresses * SOAP_FMAC2 soap_instantiate__tds__SetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:565 */
#ifndef SOAP_TYPE__tds__SetDPAddressesResponse
#define SOAP_TYPE__tds__SetDPAddressesResponse (190)
/* tds:SetDPAddressesResponse complex type: */
class SOAP_CMAC _tds__SetDPAddressesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDPAddressesResponse (190)
	virtual int soap_type(void) const { return 190; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDPAddressesResponse, default initialized and not managed by a soap context
	virtual _tds__SetDPAddressesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDPAddressesResponse); }
	         _tds__SetDPAddressesResponse() { _tds__SetDPAddressesResponse::soap_default(NULL); }
	virtual ~_tds__SetDPAddressesResponse() { }
	friend SOAP_FMAC1 _tds__SetDPAddressesResponse * SOAP_FMAC2 soap_instantiate__tds__SetDPAddressesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:568 */
#ifndef SOAP_TYPE__tds__GetEndpointReference
#define SOAP_TYPE__tds__GetEndpointReference (191)
/* tds:GetEndpointReference complex type: */
class SOAP_CMAC _tds__GetEndpointReference
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetEndpointReference (191)
	virtual int soap_type(void) const { return 191; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetEndpointReference, default initialized and not managed by a soap context
	virtual _tds__GetEndpointReference *soap_alloc(void) const { return SOAP_NEW(_tds__GetEndpointReference); }
	         _tds__GetEndpointReference() { _tds__GetEndpointReference::soap_default(NULL); }
	virtual ~_tds__GetEndpointReference() { }
	friend SOAP_FMAC1 _tds__GetEndpointReference * SOAP_FMAC2 soap_instantiate__tds__GetEndpointReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:571 */
#ifndef SOAP_TYPE__tds__GetEndpointReferenceResponse
#define SOAP_TYPE__tds__GetEndpointReferenceResponse (192)
/* tds:GetEndpointReferenceResponse complex type: */
class SOAP_CMAC _tds__GetEndpointReferenceResponse
{
public:
	std::string GUID;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetEndpointReferenceResponse (192)
	virtual int soap_type(void) const { return 192; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetEndpointReferenceResponse, default initialized and not managed by a soap context
	virtual _tds__GetEndpointReferenceResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetEndpointReferenceResponse); }
	         _tds__GetEndpointReferenceResponse() { _tds__GetEndpointReferenceResponse::soap_default(NULL); }
	virtual ~_tds__GetEndpointReferenceResponse() { }
	friend SOAP_FMAC1 _tds__GetEndpointReferenceResponse * SOAP_FMAC2 soap_instantiate__tds__GetEndpointReferenceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:574 */
#ifndef SOAP_TYPE__tds__GetRemoteUser
#define SOAP_TYPE__tds__GetRemoteUser (193)
/* tds:GetRemoteUser complex type: */
class SOAP_CMAC _tds__GetRemoteUser
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRemoteUser (193)
	virtual int soap_type(void) const { return 193; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRemoteUser, default initialized and not managed by a soap context
	virtual _tds__GetRemoteUser *soap_alloc(void) const { return SOAP_NEW(_tds__GetRemoteUser); }
	         _tds__GetRemoteUser() { _tds__GetRemoteUser::soap_default(NULL); }
	virtual ~_tds__GetRemoteUser() { }
	friend SOAP_FMAC1 _tds__GetRemoteUser * SOAP_FMAC2 soap_instantiate__tds__GetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:577 */
#ifndef SOAP_TYPE__tds__GetRemoteUserResponse
#define SOAP_TYPE__tds__GetRemoteUserResponse (194)
/* tds:GetRemoteUserResponse complex type: */
class SOAP_CMAC _tds__GetRemoteUserResponse
{
public:
	tt__RemoteUser *RemoteUser;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:RemoteUser */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRemoteUserResponse (194)
	virtual int soap_type(void) const { return 194; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRemoteUserResponse, default initialized and not managed by a soap context
	virtual _tds__GetRemoteUserResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetRemoteUserResponse); }
	         _tds__GetRemoteUserResponse() { _tds__GetRemoteUserResponse::soap_default(NULL); }
	virtual ~_tds__GetRemoteUserResponse() { }
	friend SOAP_FMAC1 _tds__GetRemoteUserResponse * SOAP_FMAC2 soap_instantiate__tds__GetRemoteUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:580 */
#ifndef SOAP_TYPE__tds__SetRemoteUser
#define SOAP_TYPE__tds__SetRemoteUser (195)
/* tds:SetRemoteUser complex type: */
class SOAP_CMAC _tds__SetRemoteUser
{
public:
	tt__RemoteUser *RemoteUser;	/* optional element of XSD type tt:RemoteUser */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRemoteUser (195)
	virtual int soap_type(void) const { return 195; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRemoteUser, default initialized and not managed by a soap context
	virtual _tds__SetRemoteUser *soap_alloc(void) const { return SOAP_NEW(_tds__SetRemoteUser); }
	         _tds__SetRemoteUser() { _tds__SetRemoteUser::soap_default(NULL); }
	virtual ~_tds__SetRemoteUser() { }
	friend SOAP_FMAC1 _tds__SetRemoteUser * SOAP_FMAC2 soap_instantiate__tds__SetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:583 */
#ifndef SOAP_TYPE__tds__SetRemoteUserResponse
#define SOAP_TYPE__tds__SetRemoteUserResponse (196)
/* tds:SetRemoteUserResponse complex type: */
class SOAP_CMAC _tds__SetRemoteUserResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRemoteUserResponse (196)
	virtual int soap_type(void) const { return 196; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRemoteUserResponse, default initialized and not managed by a soap context
	virtual _tds__SetRemoteUserResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetRemoteUserResponse); }
	         _tds__SetRemoteUserResponse() { _tds__SetRemoteUserResponse::soap_default(NULL); }
	virtual ~_tds__SetRemoteUserResponse() { }
	friend SOAP_FMAC1 _tds__SetRemoteUserResponse * SOAP_FMAC2 soap_instantiate__tds__SetRemoteUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:586 */
#ifndef SOAP_TYPE__tds__GetUsers
#define SOAP_TYPE__tds__GetUsers (197)
/* tds:GetUsers complex type: */
class SOAP_CMAC _tds__GetUsers
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetUsers (197)
	virtual int soap_type(void) const { return 197; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetUsers, default initialized and not managed by a soap context
	virtual _tds__GetUsers *soap_alloc(void) const { return SOAP_NEW(_tds__GetUsers); }
	         _tds__GetUsers() { _tds__GetUsers::soap_default(NULL); }
	virtual ~_tds__GetUsers() { }
	friend SOAP_FMAC1 _tds__GetUsers * SOAP_FMAC2 soap_instantiate__tds__GetUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:589 */
#ifndef SOAP_TYPE__tds__GetUsersResponse
#define SOAP_TYPE__tds__GetUsersResponse (198)
/* tds:GetUsersResponse complex type: */
class SOAP_CMAC _tds__GetUsersResponse
{
public:
	std::vector<tt__User *> User;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:User */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetUsersResponse (198)
	virtual int soap_type(void) const { return 198; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetUsersResponse, default initialized and not managed by a soap context
	virtual _tds__GetUsersResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetUsersResponse); }
	         _tds__GetUsersResponse() { _tds__GetUsersResponse::soap_default(NULL); }
	virtual ~_tds__GetUsersResponse() { }
	friend SOAP_FMAC1 _tds__GetUsersResponse * SOAP_FMAC2 soap_instantiate__tds__GetUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:592 */
#ifndef SOAP_TYPE__tds__CreateUsers
#define SOAP_TYPE__tds__CreateUsers (199)
/* tds:CreateUsers complex type: */
class SOAP_CMAC _tds__CreateUsers
{
public:
	std::vector<tt__User *> User;	/* required element of XSD type tt:User */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateUsers (199)
	virtual int soap_type(void) const { return 199; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateUsers, default initialized and not managed by a soap context
	virtual _tds__CreateUsers *soap_alloc(void) const { return SOAP_NEW(_tds__CreateUsers); }
	         _tds__CreateUsers() { _tds__CreateUsers::soap_default(NULL); }
	virtual ~_tds__CreateUsers() { }
	friend SOAP_FMAC1 _tds__CreateUsers * SOAP_FMAC2 soap_instantiate__tds__CreateUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:595 */
#ifndef SOAP_TYPE__tds__CreateUsersResponse
#define SOAP_TYPE__tds__CreateUsersResponse (200)
/* tds:CreateUsersResponse complex type: */
class SOAP_CMAC _tds__CreateUsersResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateUsersResponse (200)
	virtual int soap_type(void) const { return 200; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateUsersResponse, default initialized and not managed by a soap context
	virtual _tds__CreateUsersResponse *soap_alloc(void) const { return SOAP_NEW(_tds__CreateUsersResponse); }
	         _tds__CreateUsersResponse() { _tds__CreateUsersResponse::soap_default(NULL); }
	virtual ~_tds__CreateUsersResponse() { }
	friend SOAP_FMAC1 _tds__CreateUsersResponse * SOAP_FMAC2 soap_instantiate__tds__CreateUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:598 */
#ifndef SOAP_TYPE__tds__DeleteUsers
#define SOAP_TYPE__tds__DeleteUsers (201)
/* tds:DeleteUsers complex type: */
class SOAP_CMAC _tds__DeleteUsers
{
public:
	std::vector<std::string> Username;	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteUsers (201)
	virtual int soap_type(void) const { return 201; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteUsers, default initialized and not managed by a soap context
	virtual _tds__DeleteUsers *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteUsers); }
	         _tds__DeleteUsers() { _tds__DeleteUsers::soap_default(NULL); }
	virtual ~_tds__DeleteUsers() { }
	friend SOAP_FMAC1 _tds__DeleteUsers * SOAP_FMAC2 soap_instantiate__tds__DeleteUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:601 */
#ifndef SOAP_TYPE__tds__DeleteUsersResponse
#define SOAP_TYPE__tds__DeleteUsersResponse (202)
/* tds:DeleteUsersResponse complex type: */
class SOAP_CMAC _tds__DeleteUsersResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteUsersResponse (202)
	virtual int soap_type(void) const { return 202; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteUsersResponse, default initialized and not managed by a soap context
	virtual _tds__DeleteUsersResponse *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteUsersResponse); }
	         _tds__DeleteUsersResponse() { _tds__DeleteUsersResponse::soap_default(NULL); }
	virtual ~_tds__DeleteUsersResponse() { }
	friend SOAP_FMAC1 _tds__DeleteUsersResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:604 */
#ifndef SOAP_TYPE__tds__SetUser
#define SOAP_TYPE__tds__SetUser (203)
/* tds:SetUser complex type: */
class SOAP_CMAC _tds__SetUser
{
public:
	std::vector<tt__User *> User;	/* required element of XSD type tt:User */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetUser (203)
	virtual int soap_type(void) const { return 203; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetUser, default initialized and not managed by a soap context
	virtual _tds__SetUser *soap_alloc(void) const { return SOAP_NEW(_tds__SetUser); }
	         _tds__SetUser() { _tds__SetUser::soap_default(NULL); }
	virtual ~_tds__SetUser() { }
	friend SOAP_FMAC1 _tds__SetUser * SOAP_FMAC2 soap_instantiate__tds__SetUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:607 */
#ifndef SOAP_TYPE__tds__SetUserResponse
#define SOAP_TYPE__tds__SetUserResponse (204)
/* tds:SetUserResponse complex type: */
class SOAP_CMAC _tds__SetUserResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetUserResponse (204)
	virtual int soap_type(void) const { return 204; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetUserResponse, default initialized and not managed by a soap context
	virtual _tds__SetUserResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetUserResponse); }
	         _tds__SetUserResponse() { _tds__SetUserResponse::soap_default(NULL); }
	virtual ~_tds__SetUserResponse() { }
	friend SOAP_FMAC1 _tds__SetUserResponse * SOAP_FMAC2 soap_instantiate__tds__SetUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:610 */
#ifndef SOAP_TYPE__tds__GetWsdlUrl
#define SOAP_TYPE__tds__GetWsdlUrl (205)
/* tds:GetWsdlUrl complex type: */
class SOAP_CMAC _tds__GetWsdlUrl
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetWsdlUrl (205)
	virtual int soap_type(void) const { return 205; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetWsdlUrl, default initialized and not managed by a soap context
	virtual _tds__GetWsdlUrl *soap_alloc(void) const { return SOAP_NEW(_tds__GetWsdlUrl); }
	         _tds__GetWsdlUrl() { _tds__GetWsdlUrl::soap_default(NULL); }
	virtual ~_tds__GetWsdlUrl() { }
	friend SOAP_FMAC1 _tds__GetWsdlUrl * SOAP_FMAC2 soap_instantiate__tds__GetWsdlUrl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:613 */
#ifndef SOAP_TYPE__tds__GetWsdlUrlResponse
#define SOAP_TYPE__tds__GetWsdlUrlResponse (206)
/* tds:GetWsdlUrlResponse complex type: */
class SOAP_CMAC _tds__GetWsdlUrlResponse
{
public:
	std::string WsdlUrl;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetWsdlUrlResponse (206)
	virtual int soap_type(void) const { return 206; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetWsdlUrlResponse, default initialized and not managed by a soap context
	virtual _tds__GetWsdlUrlResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetWsdlUrlResponse); }
	         _tds__GetWsdlUrlResponse() { _tds__GetWsdlUrlResponse::soap_default(NULL); }
	virtual ~_tds__GetWsdlUrlResponse() { }
	friend SOAP_FMAC1 _tds__GetWsdlUrlResponse * SOAP_FMAC2 soap_instantiate__tds__GetWsdlUrlResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:616 */
#ifndef SOAP_TYPE__tds__GetCapabilities
#define SOAP_TYPE__tds__GetCapabilities (207)
/* tds:GetCapabilities complex type: */
class SOAP_CMAC _tds__GetCapabilities
{
public:
	std::vector<enum tt__CapabilityCategory> Category;	/* optional element of XSD type tt:CapabilityCategory */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCapabilities (207)
	virtual int soap_type(void) const { return 207; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCapabilities, default initialized and not managed by a soap context
	virtual _tds__GetCapabilities *soap_alloc(void) const { return SOAP_NEW(_tds__GetCapabilities); }
	         _tds__GetCapabilities() { _tds__GetCapabilities::soap_default(NULL); }
	virtual ~_tds__GetCapabilities() { }
	friend SOAP_FMAC1 _tds__GetCapabilities * SOAP_FMAC2 soap_instantiate__tds__GetCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:619 */
#ifndef SOAP_TYPE__tds__GetCapabilitiesResponse
#define SOAP_TYPE__tds__GetCapabilitiesResponse (208)
/* tds:GetCapabilitiesResponse complex type: */
class SOAP_CMAC _tds__GetCapabilitiesResponse
{
public:
	tt__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCapabilitiesResponse (208)
	virtual int soap_type(void) const { return 208; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tds__GetCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCapabilitiesResponse); }
	         _tds__GetCapabilitiesResponse() { _tds__GetCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tds__GetCapabilitiesResponse() { }
	friend SOAP_FMAC1 _tds__GetCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:622 */
#ifndef SOAP_TYPE__tds__GetHostname
#define SOAP_TYPE__tds__GetHostname (209)
/* tds:GetHostname complex type: */
class SOAP_CMAC _tds__GetHostname
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetHostname (209)
	virtual int soap_type(void) const { return 209; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetHostname, default initialized and not managed by a soap context
	virtual _tds__GetHostname *soap_alloc(void) const { return SOAP_NEW(_tds__GetHostname); }
	         _tds__GetHostname() { _tds__GetHostname::soap_default(NULL); }
	virtual ~_tds__GetHostname() { }
	friend SOAP_FMAC1 _tds__GetHostname * SOAP_FMAC2 soap_instantiate__tds__GetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:625 */
#ifndef SOAP_TYPE__tds__GetHostnameResponse
#define SOAP_TYPE__tds__GetHostnameResponse (210)
/* tds:GetHostnameResponse complex type: */
class SOAP_CMAC _tds__GetHostnameResponse
{
public:
	tt__HostnameInformation *HostnameInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:HostnameInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetHostnameResponse (210)
	virtual int soap_type(void) const { return 210; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetHostnameResponse, default initialized and not managed by a soap context
	virtual _tds__GetHostnameResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetHostnameResponse); }
	         _tds__GetHostnameResponse() { _tds__GetHostnameResponse::soap_default(NULL); }
	virtual ~_tds__GetHostnameResponse() { }
	friend SOAP_FMAC1 _tds__GetHostnameResponse * SOAP_FMAC2 soap_instantiate__tds__GetHostnameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:628 */
#ifndef SOAP_TYPE__tds__SetHostname
#define SOAP_TYPE__tds__SetHostname (211)
/* tds:SetHostname complex type: */
class SOAP_CMAC _tds__SetHostname
{
public:
	std::string Name;	/* required element of XSD type xsd:token */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetHostname (211)
	virtual int soap_type(void) const { return 211; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetHostname, default initialized and not managed by a soap context
	virtual _tds__SetHostname *soap_alloc(void) const { return SOAP_NEW(_tds__SetHostname); }
	         _tds__SetHostname() { _tds__SetHostname::soap_default(NULL); }
	virtual ~_tds__SetHostname() { }
	friend SOAP_FMAC1 _tds__SetHostname * SOAP_FMAC2 soap_instantiate__tds__SetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:631 */
#ifndef SOAP_TYPE__tds__SetHostnameResponse
#define SOAP_TYPE__tds__SetHostnameResponse (212)
/* tds:SetHostnameResponse complex type: */
class SOAP_CMAC _tds__SetHostnameResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetHostnameResponse (212)
	virtual int soap_type(void) const { return 212; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetHostnameResponse, default initialized and not managed by a soap context
	virtual _tds__SetHostnameResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetHostnameResponse); }
	         _tds__SetHostnameResponse() { _tds__SetHostnameResponse::soap_default(NULL); }
	virtual ~_tds__SetHostnameResponse() { }
	friend SOAP_FMAC1 _tds__SetHostnameResponse * SOAP_FMAC2 soap_instantiate__tds__SetHostnameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:634 */
#ifndef SOAP_TYPE__tds__SetHostnameFromDHCP
#define SOAP_TYPE__tds__SetHostnameFromDHCP (213)
/* tds:SetHostnameFromDHCP complex type: */
class SOAP_CMAC _tds__SetHostnameFromDHCP
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetHostnameFromDHCP (213)
	virtual int soap_type(void) const { return 213; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetHostnameFromDHCP, default initialized and not managed by a soap context
	virtual _tds__SetHostnameFromDHCP *soap_alloc(void) const { return SOAP_NEW(_tds__SetHostnameFromDHCP); }
	         _tds__SetHostnameFromDHCP() { _tds__SetHostnameFromDHCP::soap_default(NULL); }
	virtual ~_tds__SetHostnameFromDHCP() { }
	friend SOAP_FMAC1 _tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate__tds__SetHostnameFromDHCP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:637 */
#ifndef SOAP_TYPE__tds__SetHostnameFromDHCPResponse
#define SOAP_TYPE__tds__SetHostnameFromDHCPResponse (214)
/* tds:SetHostnameFromDHCPResponse complex type: */
class SOAP_CMAC _tds__SetHostnameFromDHCPResponse
{
public:
	bool RebootNeeded;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetHostnameFromDHCPResponse (214)
	virtual int soap_type(void) const { return 214; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetHostnameFromDHCPResponse, default initialized and not managed by a soap context
	virtual _tds__SetHostnameFromDHCPResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetHostnameFromDHCPResponse); }
	         _tds__SetHostnameFromDHCPResponse() { _tds__SetHostnameFromDHCPResponse::soap_default(NULL); }
	virtual ~_tds__SetHostnameFromDHCPResponse() { }
	friend SOAP_FMAC1 _tds__SetHostnameFromDHCPResponse * SOAP_FMAC2 soap_instantiate__tds__SetHostnameFromDHCPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:640 */
#ifndef SOAP_TYPE__tds__GetDNS
#define SOAP_TYPE__tds__GetDNS (215)
/* tds:GetDNS complex type: */
class SOAP_CMAC _tds__GetDNS
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDNS (215)
	virtual int soap_type(void) const { return 215; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDNS, default initialized and not managed by a soap context
	virtual _tds__GetDNS *soap_alloc(void) const { return SOAP_NEW(_tds__GetDNS); }
	         _tds__GetDNS() { _tds__GetDNS::soap_default(NULL); }
	virtual ~_tds__GetDNS() { }
	friend SOAP_FMAC1 _tds__GetDNS * SOAP_FMAC2 soap_instantiate__tds__GetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:643 */
#ifndef SOAP_TYPE__tds__GetDNSResponse
#define SOAP_TYPE__tds__GetDNSResponse (216)
/* tds:GetDNSResponse complex type: */
class SOAP_CMAC _tds__GetDNSResponse
{
public:
	tt__DNSInformation *DNSInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:DNSInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDNSResponse (216)
	virtual int soap_type(void) const { return 216; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDNSResponse, default initialized and not managed by a soap context
	virtual _tds__GetDNSResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDNSResponse); }
	         _tds__GetDNSResponse() { _tds__GetDNSResponse::soap_default(NULL); }
	virtual ~_tds__GetDNSResponse() { }
	friend SOAP_FMAC1 _tds__GetDNSResponse * SOAP_FMAC2 soap_instantiate__tds__GetDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:646 */
#ifndef SOAP_TYPE__tds__SetDNS
#define SOAP_TYPE__tds__SetDNS (217)
/* tds:SetDNS complex type: */
class SOAP_CMAC _tds__SetDNS
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	std::vector<std::string> SearchDomain;	/* optional element of XSD type xsd:token */
	std::vector<tt__IPAddress *> DNSManual;	/* optional element of XSD type tt:IPAddress */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDNS (217)
	virtual int soap_type(void) const { return 217; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDNS, default initialized and not managed by a soap context
	virtual _tds__SetDNS *soap_alloc(void) const { return SOAP_NEW(_tds__SetDNS); }
	         _tds__SetDNS() { _tds__SetDNS::soap_default(NULL); }
	virtual ~_tds__SetDNS() { }
	friend SOAP_FMAC1 _tds__SetDNS * SOAP_FMAC2 soap_instantiate__tds__SetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:649 */
#ifndef SOAP_TYPE__tds__SetDNSResponse
#define SOAP_TYPE__tds__SetDNSResponse (218)
/* tds:SetDNSResponse complex type: */
class SOAP_CMAC _tds__SetDNSResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDNSResponse (218)
	virtual int soap_type(void) const { return 218; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDNSResponse, default initialized and not managed by a soap context
	virtual _tds__SetDNSResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDNSResponse); }
	         _tds__SetDNSResponse() { _tds__SetDNSResponse::soap_default(NULL); }
	virtual ~_tds__SetDNSResponse() { }
	friend SOAP_FMAC1 _tds__SetDNSResponse * SOAP_FMAC2 soap_instantiate__tds__SetDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:652 */
#ifndef SOAP_TYPE__tds__GetNTP
#define SOAP_TYPE__tds__GetNTP (219)
/* tds:GetNTP complex type: */
class SOAP_CMAC _tds__GetNTP
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNTP (219)
	virtual int soap_type(void) const { return 219; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNTP, default initialized and not managed by a soap context
	virtual _tds__GetNTP *soap_alloc(void) const { return SOAP_NEW(_tds__GetNTP); }
	         _tds__GetNTP() { _tds__GetNTP::soap_default(NULL); }
	virtual ~_tds__GetNTP() { }
	friend SOAP_FMAC1 _tds__GetNTP * SOAP_FMAC2 soap_instantiate__tds__GetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:655 */
#ifndef SOAP_TYPE__tds__GetNTPResponse
#define SOAP_TYPE__tds__GetNTPResponse (220)
/* tds:GetNTPResponse complex type: */
class SOAP_CMAC _tds__GetNTPResponse
{
public:
	tt__NTPInformation *NTPInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:NTPInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNTPResponse (220)
	virtual int soap_type(void) const { return 220; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNTPResponse, default initialized and not managed by a soap context
	virtual _tds__GetNTPResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetNTPResponse); }
	         _tds__GetNTPResponse() { _tds__GetNTPResponse::soap_default(NULL); }
	virtual ~_tds__GetNTPResponse() { }
	friend SOAP_FMAC1 _tds__GetNTPResponse * SOAP_FMAC2 soap_instantiate__tds__GetNTPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:658 */
#ifndef SOAP_TYPE__tds__SetNTP
#define SOAP_TYPE__tds__SetNTP (221)
/* tds:SetNTP complex type: */
class SOAP_CMAC _tds__SetNTP
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	std::vector<tt__NetworkHost *> NTPManual;	/* optional element of XSD type tt:NetworkHost */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNTP (221)
	virtual int soap_type(void) const { return 221; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNTP, default initialized and not managed by a soap context
	virtual _tds__SetNTP *soap_alloc(void) const { return SOAP_NEW(_tds__SetNTP); }
	         _tds__SetNTP() { _tds__SetNTP::soap_default(NULL); }
	virtual ~_tds__SetNTP() { }
	friend SOAP_FMAC1 _tds__SetNTP * SOAP_FMAC2 soap_instantiate__tds__SetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:661 */
#ifndef SOAP_TYPE__tds__SetNTPResponse
#define SOAP_TYPE__tds__SetNTPResponse (222)
/* tds:SetNTPResponse complex type: */
class SOAP_CMAC _tds__SetNTPResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNTPResponse (222)
	virtual int soap_type(void) const { return 222; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNTPResponse, default initialized and not managed by a soap context
	virtual _tds__SetNTPResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetNTPResponse); }
	         _tds__SetNTPResponse() { _tds__SetNTPResponse::soap_default(NULL); }
	virtual ~_tds__SetNTPResponse() { }
	friend SOAP_FMAC1 _tds__SetNTPResponse * SOAP_FMAC2 soap_instantiate__tds__SetNTPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:664 */
#ifndef SOAP_TYPE__tds__GetDynamicDNS
#define SOAP_TYPE__tds__GetDynamicDNS (223)
/* tds:GetDynamicDNS complex type: */
class SOAP_CMAC _tds__GetDynamicDNS
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDynamicDNS (223)
	virtual int soap_type(void) const { return 223; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDynamicDNS, default initialized and not managed by a soap context
	virtual _tds__GetDynamicDNS *soap_alloc(void) const { return SOAP_NEW(_tds__GetDynamicDNS); }
	         _tds__GetDynamicDNS() { _tds__GetDynamicDNS::soap_default(NULL); }
	virtual ~_tds__GetDynamicDNS() { }
	friend SOAP_FMAC1 _tds__GetDynamicDNS * SOAP_FMAC2 soap_instantiate__tds__GetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:667 */
#ifndef SOAP_TYPE__tds__GetDynamicDNSResponse
#define SOAP_TYPE__tds__GetDynamicDNSResponse (224)
/* tds:GetDynamicDNSResponse complex type: */
class SOAP_CMAC _tds__GetDynamicDNSResponse
{
public:
	tt__DynamicDNSInformation *DynamicDNSInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:DynamicDNSInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDynamicDNSResponse (224)
	virtual int soap_type(void) const { return 224; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDynamicDNSResponse, default initialized and not managed by a soap context
	virtual _tds__GetDynamicDNSResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDynamicDNSResponse); }
	         _tds__GetDynamicDNSResponse() { _tds__GetDynamicDNSResponse::soap_default(NULL); }
	virtual ~_tds__GetDynamicDNSResponse() { }
	friend SOAP_FMAC1 _tds__GetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__tds__GetDynamicDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:670 */
#ifndef SOAP_TYPE__tds__SetDynamicDNS
#define SOAP_TYPE__tds__SetDynamicDNS (225)
/* tds:SetDynamicDNS complex type: */
class SOAP_CMAC _tds__SetDynamicDNS
{
public:
	enum tt__DynamicDNSType Type;	/* required element of XSD type tt:DynamicDNSType */
	std::string *Name;	/* optional element of XSD type tt:DNSName */
	LONG64 *TTL;	/* optional element of XSD type xsd:duration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDynamicDNS (225)
	virtual int soap_type(void) const { return 225; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDynamicDNS, default initialized and not managed by a soap context
	virtual _tds__SetDynamicDNS *soap_alloc(void) const { return SOAP_NEW(_tds__SetDynamicDNS); }
	         _tds__SetDynamicDNS() { _tds__SetDynamicDNS::soap_default(NULL); }
	virtual ~_tds__SetDynamicDNS() { }
	friend SOAP_FMAC1 _tds__SetDynamicDNS * SOAP_FMAC2 soap_instantiate__tds__SetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:673 */
#ifndef SOAP_TYPE__tds__SetDynamicDNSResponse
#define SOAP_TYPE__tds__SetDynamicDNSResponse (226)
/* tds:SetDynamicDNSResponse complex type: */
class SOAP_CMAC _tds__SetDynamicDNSResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDynamicDNSResponse (226)
	virtual int soap_type(void) const { return 226; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDynamicDNSResponse, default initialized and not managed by a soap context
	virtual _tds__SetDynamicDNSResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDynamicDNSResponse); }
	         _tds__SetDynamicDNSResponse() { _tds__SetDynamicDNSResponse::soap_default(NULL); }
	virtual ~_tds__SetDynamicDNSResponse() { }
	friend SOAP_FMAC1 _tds__SetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__tds__SetDynamicDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:676 */
#ifndef SOAP_TYPE__tds__GetNetworkInterfaces
#define SOAP_TYPE__tds__GetNetworkInterfaces (227)
/* tds:GetNetworkInterfaces complex type: */
class SOAP_CMAC _tds__GetNetworkInterfaces
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkInterfaces (227)
	virtual int soap_type(void) const { return 227; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkInterfaces, default initialized and not managed by a soap context
	virtual _tds__GetNetworkInterfaces *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkInterfaces); }
	         _tds__GetNetworkInterfaces() { _tds__GetNetworkInterfaces::soap_default(NULL); }
	virtual ~_tds__GetNetworkInterfaces() { }
	friend SOAP_FMAC1 _tds__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__tds__GetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:679 */
#ifndef SOAP_TYPE__tds__GetNetworkInterfacesResponse
#define SOAP_TYPE__tds__GetNetworkInterfacesResponse (228)
/* tds:GetNetworkInterfacesResponse complex type: */
class SOAP_CMAC _tds__GetNetworkInterfacesResponse
{
public:
	std::vector<tt__NetworkInterface *> NetworkInterfaces;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:NetworkInterface */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkInterfacesResponse (228)
	virtual int soap_type(void) const { return 228; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkInterfacesResponse, default initialized and not managed by a soap context
	virtual _tds__GetNetworkInterfacesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkInterfacesResponse); }
	         _tds__GetNetworkInterfacesResponse() { _tds__GetNetworkInterfacesResponse::soap_default(NULL); }
	virtual ~_tds__GetNetworkInterfacesResponse() { }
	friend SOAP_FMAC1 _tds__GetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkInterfacesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:682 */
#ifndef SOAP_TYPE__tds__SetNetworkInterfaces
#define SOAP_TYPE__tds__SetNetworkInterfaces (229)
/* tds:SetNetworkInterfaces complex type: */
class SOAP_CMAC _tds__SetNetworkInterfaces
{
public:
	std::string InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	tt__NetworkInterfaceSetConfiguration *NetworkInterface;	/* required element of XSD type tt:NetworkInterfaceSetConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkInterfaces (229)
	virtual int soap_type(void) const { return 229; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkInterfaces, default initialized and not managed by a soap context
	virtual _tds__SetNetworkInterfaces *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkInterfaces); }
	         _tds__SetNetworkInterfaces() { _tds__SetNetworkInterfaces::soap_default(NULL); }
	virtual ~_tds__SetNetworkInterfaces() { }
	friend SOAP_FMAC1 _tds__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__tds__SetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:685 */
#ifndef SOAP_TYPE__tds__SetNetworkInterfacesResponse
#define SOAP_TYPE__tds__SetNetworkInterfacesResponse (230)
/* tds:SetNetworkInterfacesResponse complex type: */
class SOAP_CMAC _tds__SetNetworkInterfacesResponse
{
public:
	bool RebootNeeded;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkInterfacesResponse (230)
	virtual int soap_type(void) const { return 230; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkInterfacesResponse, default initialized and not managed by a soap context
	virtual _tds__SetNetworkInterfacesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkInterfacesResponse); }
	         _tds__SetNetworkInterfacesResponse() { _tds__SetNetworkInterfacesResponse::soap_default(NULL); }
	virtual ~_tds__SetNetworkInterfacesResponse() { }
	friend SOAP_FMAC1 _tds__SetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkInterfacesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:688 */
#ifndef SOAP_TYPE__tds__GetNetworkProtocols
#define SOAP_TYPE__tds__GetNetworkProtocols (231)
/* tds:GetNetworkProtocols complex type: */
class SOAP_CMAC _tds__GetNetworkProtocols
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkProtocols (231)
	virtual int soap_type(void) const { return 231; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkProtocols, default initialized and not managed by a soap context
	virtual _tds__GetNetworkProtocols *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkProtocols); }
	         _tds__GetNetworkProtocols() { _tds__GetNetworkProtocols::soap_default(NULL); }
	virtual ~_tds__GetNetworkProtocols() { }
	friend SOAP_FMAC1 _tds__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate__tds__GetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:691 */
#ifndef SOAP_TYPE__tds__GetNetworkProtocolsResponse
#define SOAP_TYPE__tds__GetNetworkProtocolsResponse (232)
/* tds:GetNetworkProtocolsResponse complex type: */
class SOAP_CMAC _tds__GetNetworkProtocolsResponse
{
public:
	std::vector<tt__NetworkProtocol *> NetworkProtocols;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:NetworkProtocol */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkProtocolsResponse (232)
	virtual int soap_type(void) const { return 232; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkProtocolsResponse, default initialized and not managed by a soap context
	virtual _tds__GetNetworkProtocolsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkProtocolsResponse); }
	         _tds__GetNetworkProtocolsResponse() { _tds__GetNetworkProtocolsResponse::soap_default(NULL); }
	virtual ~_tds__GetNetworkProtocolsResponse() { }
	friend SOAP_FMAC1 _tds__GetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkProtocolsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:694 */
#ifndef SOAP_TYPE__tds__SetNetworkProtocols
#define SOAP_TYPE__tds__SetNetworkProtocols (233)
/* tds:SetNetworkProtocols complex type: */
class SOAP_CMAC _tds__SetNetworkProtocols
{
public:
	std::vector<tt__NetworkProtocol *> NetworkProtocols;	/* required element of XSD type tt:NetworkProtocol */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkProtocols (233)
	virtual int soap_type(void) const { return 233; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkProtocols, default initialized and not managed by a soap context
	virtual _tds__SetNetworkProtocols *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkProtocols); }
	         _tds__SetNetworkProtocols() { _tds__SetNetworkProtocols::soap_default(NULL); }
	virtual ~_tds__SetNetworkProtocols() { }
	friend SOAP_FMAC1 _tds__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate__tds__SetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:697 */
#ifndef SOAP_TYPE__tds__SetNetworkProtocolsResponse
#define SOAP_TYPE__tds__SetNetworkProtocolsResponse (234)
/* tds:SetNetworkProtocolsResponse complex type: */
class SOAP_CMAC _tds__SetNetworkProtocolsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkProtocolsResponse (234)
	virtual int soap_type(void) const { return 234; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkProtocolsResponse, default initialized and not managed by a soap context
	virtual _tds__SetNetworkProtocolsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkProtocolsResponse); }
	         _tds__SetNetworkProtocolsResponse() { _tds__SetNetworkProtocolsResponse::soap_default(NULL); }
	virtual ~_tds__SetNetworkProtocolsResponse() { }
	friend SOAP_FMAC1 _tds__SetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkProtocolsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:700 */
#ifndef SOAP_TYPE__tds__GetNetworkDefaultGateway
#define SOAP_TYPE__tds__GetNetworkDefaultGateway (235)
/* tds:GetNetworkDefaultGateway complex type: */
class SOAP_CMAC _tds__GetNetworkDefaultGateway
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkDefaultGateway (235)
	virtual int soap_type(void) const { return 235; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkDefaultGateway, default initialized and not managed by a soap context
	virtual _tds__GetNetworkDefaultGateway *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkDefaultGateway); }
	         _tds__GetNetworkDefaultGateway() { _tds__GetNetworkDefaultGateway::soap_default(NULL); }
	virtual ~_tds__GetNetworkDefaultGateway() { }
	friend SOAP_FMAC1 _tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__tds__GetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:703 */
#ifndef SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse
#define SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse (236)
/* tds:GetNetworkDefaultGatewayResponse complex type: */
class SOAP_CMAC _tds__GetNetworkDefaultGatewayResponse
{
public:
	tt__NetworkGateway *NetworkGateway;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:NetworkGateway */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse (236)
	virtual int soap_type(void) const { return 236; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkDefaultGatewayResponse, default initialized and not managed by a soap context
	virtual _tds__GetNetworkDefaultGatewayResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkDefaultGatewayResponse); }
	         _tds__GetNetworkDefaultGatewayResponse() { _tds__GetNetworkDefaultGatewayResponse::soap_default(NULL); }
	virtual ~_tds__GetNetworkDefaultGatewayResponse() { }
	friend SOAP_FMAC1 _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkDefaultGatewayResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:706 */
#ifndef SOAP_TYPE__tds__SetNetworkDefaultGateway
#define SOAP_TYPE__tds__SetNetworkDefaultGateway (237)
/* tds:SetNetworkDefaultGateway complex type: */
class SOAP_CMAC _tds__SetNetworkDefaultGateway
{
public:
	std::vector<std::string> IPv4Address;	/* optional element of XSD type tt:IPv4Address */
	std::vector<std::string> IPv6Address;	/* optional element of XSD type tt:IPv6Address */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkDefaultGateway (237)
	virtual int soap_type(void) const { return 237; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkDefaultGateway, default initialized and not managed by a soap context
	virtual _tds__SetNetworkDefaultGateway *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkDefaultGateway); }
	         _tds__SetNetworkDefaultGateway() { _tds__SetNetworkDefaultGateway::soap_default(NULL); }
	virtual ~_tds__SetNetworkDefaultGateway() { }
	friend SOAP_FMAC1 _tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__tds__SetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:709 */
#ifndef SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse
#define SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse (238)
/* tds:SetNetworkDefaultGatewayResponse complex type: */
class SOAP_CMAC _tds__SetNetworkDefaultGatewayResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse (238)
	virtual int soap_type(void) const { return 238; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkDefaultGatewayResponse, default initialized and not managed by a soap context
	virtual _tds__SetNetworkDefaultGatewayResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkDefaultGatewayResponse); }
	         _tds__SetNetworkDefaultGatewayResponse() { _tds__SetNetworkDefaultGatewayResponse::soap_default(NULL); }
	virtual ~_tds__SetNetworkDefaultGatewayResponse() { }
	friend SOAP_FMAC1 _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkDefaultGatewayResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:712 */
#ifndef SOAP_TYPE__tds__GetZeroConfiguration
#define SOAP_TYPE__tds__GetZeroConfiguration (239)
/* tds:GetZeroConfiguration complex type: */
class SOAP_CMAC _tds__GetZeroConfiguration
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetZeroConfiguration (239)
	virtual int soap_type(void) const { return 239; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetZeroConfiguration, default initialized and not managed by a soap context
	virtual _tds__GetZeroConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__GetZeroConfiguration); }
	         _tds__GetZeroConfiguration() { _tds__GetZeroConfiguration::soap_default(NULL); }
	virtual ~_tds__GetZeroConfiguration() { }
	friend SOAP_FMAC1 _tds__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:715 */
#ifndef SOAP_TYPE__tds__GetZeroConfigurationResponse
#define SOAP_TYPE__tds__GetZeroConfigurationResponse (240)
/* tds:GetZeroConfigurationResponse complex type: */
class SOAP_CMAC _tds__GetZeroConfigurationResponse
{
public:
	tt__NetworkZeroConfiguration *ZeroConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:NetworkZeroConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetZeroConfigurationResponse (240)
	virtual int soap_type(void) const { return 240; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetZeroConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__GetZeroConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetZeroConfigurationResponse); }
	         _tds__GetZeroConfigurationResponse() { _tds__GetZeroConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__GetZeroConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__GetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetZeroConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:718 */
#ifndef SOAP_TYPE__tds__SetZeroConfiguration
#define SOAP_TYPE__tds__SetZeroConfiguration (241)
/* tds:SetZeroConfiguration complex type: */
class SOAP_CMAC _tds__SetZeroConfiguration
{
public:
	std::string InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	bool Enabled;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetZeroConfiguration (241)
	virtual int soap_type(void) const { return 241; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetZeroConfiguration, default initialized and not managed by a soap context
	virtual _tds__SetZeroConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__SetZeroConfiguration); }
	         _tds__SetZeroConfiguration() { _tds__SetZeroConfiguration::soap_default(NULL); }
	virtual ~_tds__SetZeroConfiguration() { }
	friend SOAP_FMAC1 _tds__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:721 */
#ifndef SOAP_TYPE__tds__SetZeroConfigurationResponse
#define SOAP_TYPE__tds__SetZeroConfigurationResponse (242)
/* tds:SetZeroConfigurationResponse complex type: */
class SOAP_CMAC _tds__SetZeroConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetZeroConfigurationResponse (242)
	virtual int soap_type(void) const { return 242; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetZeroConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__SetZeroConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetZeroConfigurationResponse); }
	         _tds__SetZeroConfigurationResponse() { _tds__SetZeroConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__SetZeroConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__SetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetZeroConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:724 */
#ifndef SOAP_TYPE__tds__GetIPAddressFilter
#define SOAP_TYPE__tds__GetIPAddressFilter (243)
/* tds:GetIPAddressFilter complex type: */
class SOAP_CMAC _tds__GetIPAddressFilter
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetIPAddressFilter (243)
	virtual int soap_type(void) const { return 243; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetIPAddressFilter, default initialized and not managed by a soap context
	virtual _tds__GetIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_tds__GetIPAddressFilter); }
	         _tds__GetIPAddressFilter() { _tds__GetIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__GetIPAddressFilter() { }
	friend SOAP_FMAC1 _tds__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__GetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:727 */
#ifndef SOAP_TYPE__tds__GetIPAddressFilterResponse
#define SOAP_TYPE__tds__GetIPAddressFilterResponse (244)
/* tds:GetIPAddressFilterResponse complex type: */
class SOAP_CMAC _tds__GetIPAddressFilterResponse
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:IPAddressFilter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetIPAddressFilterResponse (244)
	virtual int soap_type(void) const { return 244; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetIPAddressFilterResponse, default initialized and not managed by a soap context
	virtual _tds__GetIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetIPAddressFilterResponse); }
	         _tds__GetIPAddressFilterResponse() { _tds__GetIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__GetIPAddressFilterResponse() { }
	friend SOAP_FMAC1 _tds__GetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__GetIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:730 */
#ifndef SOAP_TYPE__tds__SetIPAddressFilter
#define SOAP_TYPE__tds__SetIPAddressFilter (245)
/* tds:SetIPAddressFilter complex type: */
class SOAP_CMAC _tds__SetIPAddressFilter
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* required element of XSD type tt:IPAddressFilter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetIPAddressFilter (245)
	virtual int soap_type(void) const { return 245; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetIPAddressFilter, default initialized and not managed by a soap context
	virtual _tds__SetIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_tds__SetIPAddressFilter); }
	         _tds__SetIPAddressFilter() { _tds__SetIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__SetIPAddressFilter() { }
	friend SOAP_FMAC1 _tds__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__SetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:733 */
#ifndef SOAP_TYPE__tds__SetIPAddressFilterResponse
#define SOAP_TYPE__tds__SetIPAddressFilterResponse (246)
/* tds:SetIPAddressFilterResponse complex type: */
class SOAP_CMAC _tds__SetIPAddressFilterResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetIPAddressFilterResponse (246)
	virtual int soap_type(void) const { return 246; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetIPAddressFilterResponse, default initialized and not managed by a soap context
	virtual _tds__SetIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetIPAddressFilterResponse); }
	         _tds__SetIPAddressFilterResponse() { _tds__SetIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__SetIPAddressFilterResponse() { }
	friend SOAP_FMAC1 _tds__SetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__SetIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:736 */
#ifndef SOAP_TYPE__tds__AddIPAddressFilter
#define SOAP_TYPE__tds__AddIPAddressFilter (247)
/* tds:AddIPAddressFilter complex type: */
class SOAP_CMAC _tds__AddIPAddressFilter
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* required element of XSD type tt:IPAddressFilter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__AddIPAddressFilter (247)
	virtual int soap_type(void) const { return 247; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__AddIPAddressFilter, default initialized and not managed by a soap context
	virtual _tds__AddIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_tds__AddIPAddressFilter); }
	         _tds__AddIPAddressFilter() { _tds__AddIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__AddIPAddressFilter() { }
	friend SOAP_FMAC1 _tds__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__AddIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:739 */
#ifndef SOAP_TYPE__tds__AddIPAddressFilterResponse
#define SOAP_TYPE__tds__AddIPAddressFilterResponse (248)
/* tds:AddIPAddressFilterResponse complex type: */
class SOAP_CMAC _tds__AddIPAddressFilterResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__AddIPAddressFilterResponse (248)
	virtual int soap_type(void) const { return 248; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__AddIPAddressFilterResponse, default initialized and not managed by a soap context
	virtual _tds__AddIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_tds__AddIPAddressFilterResponse); }
	         _tds__AddIPAddressFilterResponse() { _tds__AddIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__AddIPAddressFilterResponse() { }
	friend SOAP_FMAC1 _tds__AddIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__AddIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:742 */
#ifndef SOAP_TYPE__tds__RemoveIPAddressFilter
#define SOAP_TYPE__tds__RemoveIPAddressFilter (249)
/* tds:RemoveIPAddressFilter complex type: */
class SOAP_CMAC _tds__RemoveIPAddressFilter
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* required element of XSD type tt:IPAddressFilter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RemoveIPAddressFilter (249)
	virtual int soap_type(void) const { return 249; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RemoveIPAddressFilter, default initialized and not managed by a soap context
	virtual _tds__RemoveIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_tds__RemoveIPAddressFilter); }
	         _tds__RemoveIPAddressFilter() { _tds__RemoveIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__RemoveIPAddressFilter() { }
	friend SOAP_FMAC1 _tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__RemoveIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:745 */
#ifndef SOAP_TYPE__tds__RemoveIPAddressFilterResponse
#define SOAP_TYPE__tds__RemoveIPAddressFilterResponse (250)
/* tds:RemoveIPAddressFilterResponse complex type: */
class SOAP_CMAC _tds__RemoveIPAddressFilterResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RemoveIPAddressFilterResponse (250)
	virtual int soap_type(void) const { return 250; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RemoveIPAddressFilterResponse, default initialized and not managed by a soap context
	virtual _tds__RemoveIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_tds__RemoveIPAddressFilterResponse); }
	         _tds__RemoveIPAddressFilterResponse() { _tds__RemoveIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__RemoveIPAddressFilterResponse() { }
	friend SOAP_FMAC1 _tds__RemoveIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__RemoveIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:748 */
#ifndef SOAP_TYPE__tds__GetAccessPolicy
#define SOAP_TYPE__tds__GetAccessPolicy (251)
/* tds:GetAccessPolicy complex type: */
class SOAP_CMAC _tds__GetAccessPolicy
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetAccessPolicy (251)
	virtual int soap_type(void) const { return 251; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetAccessPolicy, default initialized and not managed by a soap context
	virtual _tds__GetAccessPolicy *soap_alloc(void) const { return SOAP_NEW(_tds__GetAccessPolicy); }
	         _tds__GetAccessPolicy() { _tds__GetAccessPolicy::soap_default(NULL); }
	virtual ~_tds__GetAccessPolicy() { }
	friend SOAP_FMAC1 _tds__GetAccessPolicy * SOAP_FMAC2 soap_instantiate__tds__GetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:751 */
#ifndef SOAP_TYPE__tds__GetAccessPolicyResponse
#define SOAP_TYPE__tds__GetAccessPolicyResponse (252)
/* tds:GetAccessPolicyResponse complex type: */
class SOAP_CMAC _tds__GetAccessPolicyResponse
{
public:
	tt__BinaryData *PolicyFile;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetAccessPolicyResponse (252)
	virtual int soap_type(void) const { return 252; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetAccessPolicyResponse, default initialized and not managed by a soap context
	virtual _tds__GetAccessPolicyResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetAccessPolicyResponse); }
	         _tds__GetAccessPolicyResponse() { _tds__GetAccessPolicyResponse::soap_default(NULL); }
	virtual ~_tds__GetAccessPolicyResponse() { }
	friend SOAP_FMAC1 _tds__GetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__tds__GetAccessPolicyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:754 */
#ifndef SOAP_TYPE__tds__SetAccessPolicy
#define SOAP_TYPE__tds__SetAccessPolicy (253)
/* tds:SetAccessPolicy complex type: */
class SOAP_CMAC _tds__SetAccessPolicy
{
public:
	tt__BinaryData *PolicyFile;	/* required element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetAccessPolicy (253)
	virtual int soap_type(void) const { return 253; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetAccessPolicy, default initialized and not managed by a soap context
	virtual _tds__SetAccessPolicy *soap_alloc(void) const { return SOAP_NEW(_tds__SetAccessPolicy); }
	         _tds__SetAccessPolicy() { _tds__SetAccessPolicy::soap_default(NULL); }
	virtual ~_tds__SetAccessPolicy() { }
	friend SOAP_FMAC1 _tds__SetAccessPolicy * SOAP_FMAC2 soap_instantiate__tds__SetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:757 */
#ifndef SOAP_TYPE__tds__SetAccessPolicyResponse
#define SOAP_TYPE__tds__SetAccessPolicyResponse (254)
/* tds:SetAccessPolicyResponse complex type: */
class SOAP_CMAC _tds__SetAccessPolicyResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetAccessPolicyResponse (254)
	virtual int soap_type(void) const { return 254; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetAccessPolicyResponse, default initialized and not managed by a soap context
	virtual _tds__SetAccessPolicyResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetAccessPolicyResponse); }
	         _tds__SetAccessPolicyResponse() { _tds__SetAccessPolicyResponse::soap_default(NULL); }
	virtual ~_tds__SetAccessPolicyResponse() { }
	friend SOAP_FMAC1 _tds__SetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__tds__SetAccessPolicyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:760 */
#ifndef SOAP_TYPE__tds__CreateCertificate
#define SOAP_TYPE__tds__CreateCertificate (255)
/* tds:CreateCertificate complex type: */
class SOAP_CMAC _tds__CreateCertificate
{
public:
	std::string *CertificateID;	/* optional element of XSD type xsd:token */
	std::string *Subject;	/* optional element of XSD type xsd:string */
	time_t *ValidNotBefore;	/* optional element of XSD type xsd:dateTime */
	time_t *ValidNotAfter;	/* optional element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateCertificate (255)
	virtual int soap_type(void) const { return 255; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateCertificate, default initialized and not managed by a soap context
	virtual _tds__CreateCertificate *soap_alloc(void) const { return SOAP_NEW(_tds__CreateCertificate); }
	         _tds__CreateCertificate() { _tds__CreateCertificate::soap_default(NULL); }
	virtual ~_tds__CreateCertificate() { }
	friend SOAP_FMAC1 _tds__CreateCertificate * SOAP_FMAC2 soap_instantiate__tds__CreateCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:763 */
#ifndef SOAP_TYPE__tds__CreateCertificateResponse
#define SOAP_TYPE__tds__CreateCertificateResponse (256)
/* tds:CreateCertificateResponse complex type: */
class SOAP_CMAC _tds__CreateCertificateResponse
{
public:
	tt__Certificate *NvtCertificate;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Certificate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateCertificateResponse (256)
	virtual int soap_type(void) const { return 256; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateCertificateResponse, default initialized and not managed by a soap context
	virtual _tds__CreateCertificateResponse *soap_alloc(void) const { return SOAP_NEW(_tds__CreateCertificateResponse); }
	         _tds__CreateCertificateResponse() { _tds__CreateCertificateResponse::soap_default(NULL); }
	virtual ~_tds__CreateCertificateResponse() { }
	friend SOAP_FMAC1 _tds__CreateCertificateResponse * SOAP_FMAC2 soap_instantiate__tds__CreateCertificateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:766 */
#ifndef SOAP_TYPE__tds__GetCertificates
#define SOAP_TYPE__tds__GetCertificates (257)
/* tds:GetCertificates complex type: */
class SOAP_CMAC _tds__GetCertificates
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificates (257)
	virtual int soap_type(void) const { return 257; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificates, default initialized and not managed by a soap context
	virtual _tds__GetCertificates *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificates); }
	         _tds__GetCertificates() { _tds__GetCertificates::soap_default(NULL); }
	virtual ~_tds__GetCertificates() { }
	friend SOAP_FMAC1 _tds__GetCertificates * SOAP_FMAC2 soap_instantiate__tds__GetCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:769 */
#ifndef SOAP_TYPE__tds__GetCertificatesResponse
#define SOAP_TYPE__tds__GetCertificatesResponse (258)
/* tds:GetCertificatesResponse complex type: */
class SOAP_CMAC _tds__GetCertificatesResponse
{
public:
	std::vector<tt__Certificate *> NvtCertificate;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:Certificate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificatesResponse (258)
	virtual int soap_type(void) const { return 258; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__GetCertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificatesResponse); }
	         _tds__GetCertificatesResponse() { _tds__GetCertificatesResponse::soap_default(NULL); }
	virtual ~_tds__GetCertificatesResponse() { }
	friend SOAP_FMAC1 _tds__GetCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:772 */
#ifndef SOAP_TYPE__tds__GetCertificatesStatus
#define SOAP_TYPE__tds__GetCertificatesStatus (259)
/* tds:GetCertificatesStatus complex type: */
class SOAP_CMAC _tds__GetCertificatesStatus
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificatesStatus (259)
	virtual int soap_type(void) const { return 259; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificatesStatus, default initialized and not managed by a soap context
	virtual _tds__GetCertificatesStatus *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificatesStatus); }
	         _tds__GetCertificatesStatus() { _tds__GetCertificatesStatus::soap_default(NULL); }
	virtual ~_tds__GetCertificatesStatus() { }
	friend SOAP_FMAC1 _tds__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:775 */
#ifndef SOAP_TYPE__tds__GetCertificatesStatusResponse
#define SOAP_TYPE__tds__GetCertificatesStatusResponse (260)
/* tds:GetCertificatesStatusResponse complex type: */
class SOAP_CMAC _tds__GetCertificatesStatusResponse
{
public:
	std::vector<tt__CertificateStatus *> CertificateStatus;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:CertificateStatus */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificatesStatusResponse (260)
	virtual int soap_type(void) const { return 260; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificatesStatusResponse, default initialized and not managed by a soap context
	virtual _tds__GetCertificatesStatusResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificatesStatusResponse); }
	         _tds__GetCertificatesStatusResponse() { _tds__GetCertificatesStatusResponse::soap_default(NULL); }
	virtual ~_tds__GetCertificatesStatusResponse() { }
	friend SOAP_FMAC1 _tds__GetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:778 */
#ifndef SOAP_TYPE__tds__SetCertificatesStatus
#define SOAP_TYPE__tds__SetCertificatesStatus (261)
/* tds:SetCertificatesStatus complex type: */
class SOAP_CMAC _tds__SetCertificatesStatus
{
public:
	std::vector<tt__CertificateStatus *> CertificateStatus;	/* optional element of XSD type tt:CertificateStatus */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetCertificatesStatus (261)
	virtual int soap_type(void) const { return 261; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetCertificatesStatus, default initialized and not managed by a soap context
	virtual _tds__SetCertificatesStatus *soap_alloc(void) const { return SOAP_NEW(_tds__SetCertificatesStatus); }
	         _tds__SetCertificatesStatus() { _tds__SetCertificatesStatus::soap_default(NULL); }
	virtual ~_tds__SetCertificatesStatus() { }
	friend SOAP_FMAC1 _tds__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate__tds__SetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:781 */
#ifndef SOAP_TYPE__tds__SetCertificatesStatusResponse
#define SOAP_TYPE__tds__SetCertificatesStatusResponse (262)
/* tds:SetCertificatesStatusResponse complex type: */
class SOAP_CMAC _tds__SetCertificatesStatusResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetCertificatesStatusResponse (262)
	virtual int soap_type(void) const { return 262; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetCertificatesStatusResponse, default initialized and not managed by a soap context
	virtual _tds__SetCertificatesStatusResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetCertificatesStatusResponse); }
	         _tds__SetCertificatesStatusResponse() { _tds__SetCertificatesStatusResponse::soap_default(NULL); }
	virtual ~_tds__SetCertificatesStatusResponse() { }
	friend SOAP_FMAC1 _tds__SetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__tds__SetCertificatesStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:784 */
#ifndef SOAP_TYPE__tds__DeleteCertificates
#define SOAP_TYPE__tds__DeleteCertificates (263)
/* tds:DeleteCertificates complex type: */
class SOAP_CMAC _tds__DeleteCertificates
{
public:
	std::vector<std::string> CertificateID;	/* required element of XSD type xsd:token */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteCertificates (263)
	virtual int soap_type(void) const { return 263; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteCertificates, default initialized and not managed by a soap context
	virtual _tds__DeleteCertificates *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteCertificates); }
	         _tds__DeleteCertificates() { _tds__DeleteCertificates::soap_default(NULL); }
	virtual ~_tds__DeleteCertificates() { }
	friend SOAP_FMAC1 _tds__DeleteCertificates * SOAP_FMAC2 soap_instantiate__tds__DeleteCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:787 */
#ifndef SOAP_TYPE__tds__DeleteCertificatesResponse
#define SOAP_TYPE__tds__DeleteCertificatesResponse (264)
/* tds:DeleteCertificatesResponse complex type: */
class SOAP_CMAC _tds__DeleteCertificatesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteCertificatesResponse (264)
	virtual int soap_type(void) const { return 264; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteCertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__DeleteCertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteCertificatesResponse); }
	         _tds__DeleteCertificatesResponse() { _tds__DeleteCertificatesResponse::soap_default(NULL); }
	virtual ~_tds__DeleteCertificatesResponse() { }
	friend SOAP_FMAC1 _tds__DeleteCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:790 */
#ifndef SOAP_TYPE__tds__GetPkcs10Request
#define SOAP_TYPE__tds__GetPkcs10Request (265)
/* tds:GetPkcs10Request complex type: */
class SOAP_CMAC _tds__GetPkcs10Request
{
public:
	std::string CertificateID;	/* required element of XSD type xsd:token */
	std::string *Subject;	/* optional element of XSD type xsd:string */
	tt__BinaryData *Attributes;	/* optional element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetPkcs10Request (265)
	virtual int soap_type(void) const { return 265; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetPkcs10Request, default initialized and not managed by a soap context
	virtual _tds__GetPkcs10Request *soap_alloc(void) const { return SOAP_NEW(_tds__GetPkcs10Request); }
	         _tds__GetPkcs10Request() { _tds__GetPkcs10Request::soap_default(NULL); }
	virtual ~_tds__GetPkcs10Request() { }
	friend SOAP_FMAC1 _tds__GetPkcs10Request * SOAP_FMAC2 soap_instantiate__tds__GetPkcs10Request(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:793 */
#ifndef SOAP_TYPE__tds__GetPkcs10RequestResponse
#define SOAP_TYPE__tds__GetPkcs10RequestResponse (266)
/* tds:GetPkcs10RequestResponse complex type: */
class SOAP_CMAC _tds__GetPkcs10RequestResponse
{
public:
	tt__BinaryData *Pkcs10Request;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetPkcs10RequestResponse (266)
	virtual int soap_type(void) const { return 266; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetPkcs10RequestResponse, default initialized and not managed by a soap context
	virtual _tds__GetPkcs10RequestResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetPkcs10RequestResponse); }
	         _tds__GetPkcs10RequestResponse() { _tds__GetPkcs10RequestResponse::soap_default(NULL); }
	virtual ~_tds__GetPkcs10RequestResponse() { }
	friend SOAP_FMAC1 _tds__GetPkcs10RequestResponse * SOAP_FMAC2 soap_instantiate__tds__GetPkcs10RequestResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:796 */
#ifndef SOAP_TYPE__tds__LoadCertificates
#define SOAP_TYPE__tds__LoadCertificates (267)
/* tds:LoadCertificates complex type: */
class SOAP_CMAC _tds__LoadCertificates
{
public:
	std::vector<tt__Certificate *> NVTCertificate;	/* required element of XSD type tt:Certificate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCertificates (267)
	virtual int soap_type(void) const { return 267; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCertificates, default initialized and not managed by a soap context
	virtual _tds__LoadCertificates *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCertificates); }
	         _tds__LoadCertificates() { _tds__LoadCertificates::soap_default(NULL); }
	virtual ~_tds__LoadCertificates() { }
	friend SOAP_FMAC1 _tds__LoadCertificates * SOAP_FMAC2 soap_instantiate__tds__LoadCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:799 */
#ifndef SOAP_TYPE__tds__LoadCertificatesResponse
#define SOAP_TYPE__tds__LoadCertificatesResponse (268)
/* tds:LoadCertificatesResponse complex type: */
class SOAP_CMAC _tds__LoadCertificatesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCertificatesResponse (268)
	virtual int soap_type(void) const { return 268; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__LoadCertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCertificatesResponse); }
	         _tds__LoadCertificatesResponse() { _tds__LoadCertificatesResponse::soap_default(NULL); }
	virtual ~_tds__LoadCertificatesResponse() { }
	friend SOAP_FMAC1 _tds__LoadCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:802 */
#ifndef SOAP_TYPE__tds__GetClientCertificateMode
#define SOAP_TYPE__tds__GetClientCertificateMode (269)
/* tds:GetClientCertificateMode complex type: */
class SOAP_CMAC _tds__GetClientCertificateMode
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetClientCertificateMode (269)
	virtual int soap_type(void) const { return 269; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetClientCertificateMode, default initialized and not managed by a soap context
	virtual _tds__GetClientCertificateMode *soap_alloc(void) const { return SOAP_NEW(_tds__GetClientCertificateMode); }
	         _tds__GetClientCertificateMode() { _tds__GetClientCertificateMode::soap_default(NULL); }
	virtual ~_tds__GetClientCertificateMode() { }
	friend SOAP_FMAC1 _tds__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate__tds__GetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:805 */
#ifndef SOAP_TYPE__tds__GetClientCertificateModeResponse
#define SOAP_TYPE__tds__GetClientCertificateModeResponse (270)
/* tds:GetClientCertificateModeResponse complex type: */
class SOAP_CMAC _tds__GetClientCertificateModeResponse
{
public:
	bool Enabled;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetClientCertificateModeResponse (270)
	virtual int soap_type(void) const { return 270; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetClientCertificateModeResponse, default initialized and not managed by a soap context
	virtual _tds__GetClientCertificateModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetClientCertificateModeResponse); }
	         _tds__GetClientCertificateModeResponse() { _tds__GetClientCertificateModeResponse::soap_default(NULL); }
	virtual ~_tds__GetClientCertificateModeResponse() { }
	friend SOAP_FMAC1 _tds__GetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetClientCertificateModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:808 */
#ifndef SOAP_TYPE__tds__SetClientCertificateMode
#define SOAP_TYPE__tds__SetClientCertificateMode (271)
/* tds:SetClientCertificateMode complex type: */
class SOAP_CMAC _tds__SetClientCertificateMode
{
public:
	bool Enabled;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetClientCertificateMode (271)
	virtual int soap_type(void) const { return 271; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetClientCertificateMode, default initialized and not managed by a soap context
	virtual _tds__SetClientCertificateMode *soap_alloc(void) const { return SOAP_NEW(_tds__SetClientCertificateMode); }
	         _tds__SetClientCertificateMode() { _tds__SetClientCertificateMode::soap_default(NULL); }
	virtual ~_tds__SetClientCertificateMode() { }
	friend SOAP_FMAC1 _tds__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate__tds__SetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:811 */
#ifndef SOAP_TYPE__tds__SetClientCertificateModeResponse
#define SOAP_TYPE__tds__SetClientCertificateModeResponse (272)
/* tds:SetClientCertificateModeResponse complex type: */
class SOAP_CMAC _tds__SetClientCertificateModeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetClientCertificateModeResponse (272)
	virtual int soap_type(void) const { return 272; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetClientCertificateModeResponse, default initialized and not managed by a soap context
	virtual _tds__SetClientCertificateModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetClientCertificateModeResponse); }
	         _tds__SetClientCertificateModeResponse() { _tds__SetClientCertificateModeResponse::soap_default(NULL); }
	virtual ~_tds__SetClientCertificateModeResponse() { }
	friend SOAP_FMAC1 _tds__SetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetClientCertificateModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:814 */
#ifndef SOAP_TYPE__tds__GetCACertificates
#define SOAP_TYPE__tds__GetCACertificates (273)
/* tds:GetCACertificates complex type: */
class SOAP_CMAC _tds__GetCACertificates
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCACertificates (273)
	virtual int soap_type(void) const { return 273; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCACertificates, default initialized and not managed by a soap context
	virtual _tds__GetCACertificates *soap_alloc(void) const { return SOAP_NEW(_tds__GetCACertificates); }
	         _tds__GetCACertificates() { _tds__GetCACertificates::soap_default(NULL); }
	virtual ~_tds__GetCACertificates() { }
	friend SOAP_FMAC1 _tds__GetCACertificates * SOAP_FMAC2 soap_instantiate__tds__GetCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:817 */
#ifndef SOAP_TYPE__tds__GetCACertificatesResponse
#define SOAP_TYPE__tds__GetCACertificatesResponse (274)
/* tds:GetCACertificatesResponse complex type: */
class SOAP_CMAC _tds__GetCACertificatesResponse
{
public:
	std::vector<tt__Certificate *> CACertificate;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:Certificate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCACertificatesResponse (274)
	virtual int soap_type(void) const { return 274; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCACertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__GetCACertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCACertificatesResponse); }
	         _tds__GetCACertificatesResponse() { _tds__GetCACertificatesResponse::soap_default(NULL); }
	virtual ~_tds__GetCACertificatesResponse() { }
	friend SOAP_FMAC1 _tds__GetCACertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCACertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:820 */
#ifndef SOAP_TYPE__tds__LoadCertificateWithPrivateKey
#define SOAP_TYPE__tds__LoadCertificateWithPrivateKey (275)
/* tds:LoadCertificateWithPrivateKey complex type: */
class SOAP_CMAC _tds__LoadCertificateWithPrivateKey
{
public:
	std::vector<tt__CertificateWithPrivateKey *> CertificateWithPrivateKey;	/* required element of XSD type tt:CertificateWithPrivateKey */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCertificateWithPrivateKey (275)
	virtual int soap_type(void) const { return 275; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCertificateWithPrivateKey, default initialized and not managed by a soap context
	virtual _tds__LoadCertificateWithPrivateKey *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCertificateWithPrivateKey); }
	         _tds__LoadCertificateWithPrivateKey() { _tds__LoadCertificateWithPrivateKey::soap_default(NULL); }
	virtual ~_tds__LoadCertificateWithPrivateKey() { }
	friend SOAP_FMAC1 _tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate__tds__LoadCertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:823 */
#ifndef SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse
#define SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse (276)
/* tds:LoadCertificateWithPrivateKeyResponse complex type: */
class SOAP_CMAC _tds__LoadCertificateWithPrivateKeyResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse (276)
	virtual int soap_type(void) const { return 276; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCertificateWithPrivateKeyResponse, default initialized and not managed by a soap context
	virtual _tds__LoadCertificateWithPrivateKeyResponse *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCertificateWithPrivateKeyResponse); }
	         _tds__LoadCertificateWithPrivateKeyResponse() { _tds__LoadCertificateWithPrivateKeyResponse::soap_default(NULL); }
	virtual ~_tds__LoadCertificateWithPrivateKeyResponse() { }
	friend SOAP_FMAC1 _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCertificateWithPrivateKeyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:826 */
#ifndef SOAP_TYPE__tds__GetCertificateInformation
#define SOAP_TYPE__tds__GetCertificateInformation (277)
/* tds:GetCertificateInformation complex type: */
class SOAP_CMAC _tds__GetCertificateInformation
{
public:
	std::string CertificateID;	/* required element of XSD type xsd:token */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificateInformation (277)
	virtual int soap_type(void) const { return 277; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificateInformation, default initialized and not managed by a soap context
	virtual _tds__GetCertificateInformation *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificateInformation); }
	         _tds__GetCertificateInformation() { _tds__GetCertificateInformation::soap_default(NULL); }
	virtual ~_tds__GetCertificateInformation() { }
	friend SOAP_FMAC1 _tds__GetCertificateInformation * SOAP_FMAC2 soap_instantiate__tds__GetCertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:829 */
#ifndef SOAP_TYPE__tds__GetCertificateInformationResponse
#define SOAP_TYPE__tds__GetCertificateInformationResponse (278)
/* tds:GetCertificateInformationResponse complex type: */
class SOAP_CMAC _tds__GetCertificateInformationResponse
{
public:
	tt__CertificateInformation *CertificateInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:CertificateInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificateInformationResponse (278)
	virtual int soap_type(void) const { return 278; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificateInformationResponse, default initialized and not managed by a soap context
	virtual _tds__GetCertificateInformationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificateInformationResponse); }
	         _tds__GetCertificateInformationResponse() { _tds__GetCertificateInformationResponse::soap_default(NULL); }
	virtual ~_tds__GetCertificateInformationResponse() { }
	friend SOAP_FMAC1 _tds__GetCertificateInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificateInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:832 */
#ifndef SOAP_TYPE__tds__LoadCACertificates
#define SOAP_TYPE__tds__LoadCACertificates (279)
/* tds:LoadCACertificates complex type: */
class SOAP_CMAC _tds__LoadCACertificates
{
public:
	std::vector<tt__Certificate *> CACertificate;	/* required element of XSD type tt:Certificate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCACertificates (279)
	virtual int soap_type(void) const { return 279; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCACertificates, default initialized and not managed by a soap context
	virtual _tds__LoadCACertificates *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCACertificates); }
	         _tds__LoadCACertificates() { _tds__LoadCACertificates::soap_default(NULL); }
	virtual ~_tds__LoadCACertificates() { }
	friend SOAP_FMAC1 _tds__LoadCACertificates * SOAP_FMAC2 soap_instantiate__tds__LoadCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:835 */
#ifndef SOAP_TYPE__tds__LoadCACertificatesResponse
#define SOAP_TYPE__tds__LoadCACertificatesResponse (280)
/* tds:LoadCACertificatesResponse complex type: */
class SOAP_CMAC _tds__LoadCACertificatesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCACertificatesResponse (280)
	virtual int soap_type(void) const { return 280; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCACertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__LoadCACertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCACertificatesResponse); }
	         _tds__LoadCACertificatesResponse() { _tds__LoadCACertificatesResponse::soap_default(NULL); }
	virtual ~_tds__LoadCACertificatesResponse() { }
	friend SOAP_FMAC1 _tds__LoadCACertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCACertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:838 */
#ifndef SOAP_TYPE__tds__CreateDot1XConfiguration
#define SOAP_TYPE__tds__CreateDot1XConfiguration (281)
/* tds:CreateDot1XConfiguration complex type: */
class SOAP_CMAC _tds__CreateDot1XConfiguration
{
public:
	tt__Dot1XConfiguration *Dot1XConfiguration;	/* required element of XSD type tt:Dot1XConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateDot1XConfiguration (281)
	virtual int soap_type(void) const { return 281; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateDot1XConfiguration, default initialized and not managed by a soap context
	virtual _tds__CreateDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__CreateDot1XConfiguration); }
	         _tds__CreateDot1XConfiguration() { _tds__CreateDot1XConfiguration::soap_default(NULL); }
	virtual ~_tds__CreateDot1XConfiguration() { }
	friend SOAP_FMAC1 _tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__CreateDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:841 */
#ifndef SOAP_TYPE__tds__CreateDot1XConfigurationResponse
#define SOAP_TYPE__tds__CreateDot1XConfigurationResponse (282)
/* tds:CreateDot1XConfigurationResponse complex type: */
class SOAP_CMAC _tds__CreateDot1XConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateDot1XConfigurationResponse (282)
	virtual int soap_type(void) const { return 282; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateDot1XConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__CreateDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__CreateDot1XConfigurationResponse); }
	         _tds__CreateDot1XConfigurationResponse() { _tds__CreateDot1XConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__CreateDot1XConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__CreateDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__CreateDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:844 */
#ifndef SOAP_TYPE__tds__SetDot1XConfiguration
#define SOAP_TYPE__tds__SetDot1XConfiguration (283)
/* tds:SetDot1XConfiguration complex type: */
class SOAP_CMAC _tds__SetDot1XConfiguration
{
public:
	tt__Dot1XConfiguration *Dot1XConfiguration;	/* required element of XSD type tt:Dot1XConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDot1XConfiguration (283)
	virtual int soap_type(void) const { return 283; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDot1XConfiguration, default initialized and not managed by a soap context
	virtual _tds__SetDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__SetDot1XConfiguration); }
	         _tds__SetDot1XConfiguration() { _tds__SetDot1XConfiguration::soap_default(NULL); }
	virtual ~_tds__SetDot1XConfiguration() { }
	friend SOAP_FMAC1 _tds__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:847 */
#ifndef SOAP_TYPE__tds__SetDot1XConfigurationResponse
#define SOAP_TYPE__tds__SetDot1XConfigurationResponse (284)
/* tds:SetDot1XConfigurationResponse complex type: */
class SOAP_CMAC _tds__SetDot1XConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDot1XConfigurationResponse (284)
	virtual int soap_type(void) const { return 284; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDot1XConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__SetDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDot1XConfigurationResponse); }
	         _tds__SetDot1XConfigurationResponse() { _tds__SetDot1XConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__SetDot1XConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__SetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:850 */
#ifndef SOAP_TYPE__tds__GetDot1XConfiguration
#define SOAP_TYPE__tds__GetDot1XConfiguration (285)
/* tds:GetDot1XConfiguration complex type: */
class SOAP_CMAC _tds__GetDot1XConfiguration
{
public:
	std::string Dot1XConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot1XConfiguration (285)
	virtual int soap_type(void) const { return 285; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot1XConfiguration, default initialized and not managed by a soap context
	virtual _tds__GetDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot1XConfiguration); }
	         _tds__GetDot1XConfiguration() { _tds__GetDot1XConfiguration::soap_default(NULL); }
	virtual ~_tds__GetDot1XConfiguration() { }
	friend SOAP_FMAC1 _tds__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:853 */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurationResponse
#define SOAP_TYPE__tds__GetDot1XConfigurationResponse (286)
/* tds:GetDot1XConfigurationResponse complex type: */
class SOAP_CMAC _tds__GetDot1XConfigurationResponse
{
public:
	tt__Dot1XConfiguration *Dot1XConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Dot1XConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot1XConfigurationResponse (286)
	virtual int soap_type(void) const { return 286; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot1XConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__GetDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot1XConfigurationResponse); }
	         _tds__GetDot1XConfigurationResponse() { _tds__GetDot1XConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__GetDot1XConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__GetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:856 */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurations
#define SOAP_TYPE__tds__GetDot1XConfigurations (287)
/* tds:GetDot1XConfigurations complex type: */
class SOAP_CMAC _tds__GetDot1XConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot1XConfigurations (287)
	virtual int soap_type(void) const { return 287; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot1XConfigurations, default initialized and not managed by a soap context
	virtual _tds__GetDot1XConfigurations *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot1XConfigurations); }
	         _tds__GetDot1XConfigurations() { _tds__GetDot1XConfigurations::soap_default(NULL); }
	virtual ~_tds__GetDot1XConfigurations() { }
	friend SOAP_FMAC1 _tds__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:859 */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurationsResponse
#define SOAP_TYPE__tds__GetDot1XConfigurationsResponse (288)
/* tds:GetDot1XConfigurationsResponse complex type: */
class SOAP_CMAC _tds__GetDot1XConfigurationsResponse
{
public:
	std::vector<tt__Dot1XConfiguration *> Dot1XConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:Dot1XConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot1XConfigurationsResponse (288)
	virtual int soap_type(void) const { return 288; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot1XConfigurationsResponse, default initialized and not managed by a soap context
	virtual _tds__GetDot1XConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot1XConfigurationsResponse); }
	         _tds__GetDot1XConfigurationsResponse() { _tds__GetDot1XConfigurationsResponse::soap_default(NULL); }
	virtual ~_tds__GetDot1XConfigurationsResponse() { }
	friend SOAP_FMAC1 _tds__GetDot1XConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:862 */
#ifndef SOAP_TYPE__tds__DeleteDot1XConfiguration
#define SOAP_TYPE__tds__DeleteDot1XConfiguration (289)
/* tds:DeleteDot1XConfiguration complex type: */
class SOAP_CMAC _tds__DeleteDot1XConfiguration
{
public:
	std::vector<std::string> Dot1XConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteDot1XConfiguration (289)
	virtual int soap_type(void) const { return 289; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteDot1XConfiguration, default initialized and not managed by a soap context
	virtual _tds__DeleteDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteDot1XConfiguration); }
	         _tds__DeleteDot1XConfiguration() { _tds__DeleteDot1XConfiguration::soap_default(NULL); }
	virtual ~_tds__DeleteDot1XConfiguration() { }
	friend SOAP_FMAC1 _tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__DeleteDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:865 */
#ifndef SOAP_TYPE__tds__DeleteDot1XConfigurationResponse
#define SOAP_TYPE__tds__DeleteDot1XConfigurationResponse (290)
/* tds:DeleteDot1XConfigurationResponse complex type: */
class SOAP_CMAC _tds__DeleteDot1XConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteDot1XConfigurationResponse (290)
	virtual int soap_type(void) const { return 290; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteDot1XConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__DeleteDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteDot1XConfigurationResponse); }
	         _tds__DeleteDot1XConfigurationResponse() { _tds__DeleteDot1XConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__DeleteDot1XConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:868 */
#ifndef SOAP_TYPE__tds__GetRelayOutputs
#define SOAP_TYPE__tds__GetRelayOutputs (291)
/* tds:GetRelayOutputs complex type: */
class SOAP_CMAC _tds__GetRelayOutputs
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRelayOutputs (291)
	virtual int soap_type(void) const { return 291; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRelayOutputs, default initialized and not managed by a soap context
	virtual _tds__GetRelayOutputs *soap_alloc(void) const { return SOAP_NEW(_tds__GetRelayOutputs); }
	         _tds__GetRelayOutputs() { _tds__GetRelayOutputs::soap_default(NULL); }
	virtual ~_tds__GetRelayOutputs() { }
	friend SOAP_FMAC1 _tds__GetRelayOutputs * SOAP_FMAC2 soap_instantiate__tds__GetRelayOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:871 */
#ifndef SOAP_TYPE__tds__GetRelayOutputsResponse
#define SOAP_TYPE__tds__GetRelayOutputsResponse (292)
/* tds:GetRelayOutputsResponse complex type: */
class SOAP_CMAC _tds__GetRelayOutputsResponse
{
public:
	std::vector<tt__RelayOutput *> RelayOutputs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:RelayOutput */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRelayOutputsResponse (292)
	virtual int soap_type(void) const { return 292; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRelayOutputsResponse, default initialized and not managed by a soap context
	virtual _tds__GetRelayOutputsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetRelayOutputsResponse); }
	         _tds__GetRelayOutputsResponse() { _tds__GetRelayOutputsResponse::soap_default(NULL); }
	virtual ~_tds__GetRelayOutputsResponse() { }
	friend SOAP_FMAC1 _tds__GetRelayOutputsResponse * SOAP_FMAC2 soap_instantiate__tds__GetRelayOutputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:874 */
#ifndef SOAP_TYPE__tds__SetRelayOutputSettings
#define SOAP_TYPE__tds__SetRelayOutputSettings (293)
/* tds:SetRelayOutputSettings complex type: */
class SOAP_CMAC _tds__SetRelayOutputSettings
{
public:
	std::string RelayOutputToken;	/* required element of XSD type tt:ReferenceToken */
	tt__RelayOutputSettings *Properties;	/* required element of XSD type tt:RelayOutputSettings */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRelayOutputSettings (293)
	virtual int soap_type(void) const { return 293; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRelayOutputSettings, default initialized and not managed by a soap context
	virtual _tds__SetRelayOutputSettings *soap_alloc(void) const { return SOAP_NEW(_tds__SetRelayOutputSettings); }
	         _tds__SetRelayOutputSettings() { _tds__SetRelayOutputSettings::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputSettings() { }
	friend SOAP_FMAC1 _tds__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:877 */
#ifndef SOAP_TYPE__tds__SetRelayOutputSettingsResponse
#define SOAP_TYPE__tds__SetRelayOutputSettingsResponse (294)
/* tds:SetRelayOutputSettingsResponse complex type: */
class SOAP_CMAC _tds__SetRelayOutputSettingsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRelayOutputSettingsResponse (294)
	virtual int soap_type(void) const { return 294; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRelayOutputSettingsResponse, default initialized and not managed by a soap context
	virtual _tds__SetRelayOutputSettingsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetRelayOutputSettingsResponse); }
	         _tds__SetRelayOutputSettingsResponse() { _tds__SetRelayOutputSettingsResponse::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputSettingsResponse() { }
	friend SOAP_FMAC1 _tds__SetRelayOutputSettingsResponse * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:880 */
#ifndef SOAP_TYPE__tds__SetRelayOutputState
#define SOAP_TYPE__tds__SetRelayOutputState (295)
/* tds:SetRelayOutputState complex type: */
class SOAP_CMAC _tds__SetRelayOutputState
{
public:
	std::string RelayOutputToken;	/* required element of XSD type tt:ReferenceToken */
	enum tt__RelayLogicalState LogicalState;	/* required element of XSD type tt:RelayLogicalState */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRelayOutputState (295)
	virtual int soap_type(void) const { return 295; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRelayOutputState, default initialized and not managed by a soap context
	virtual _tds__SetRelayOutputState *soap_alloc(void) const { return SOAP_NEW(_tds__SetRelayOutputState); }
	         _tds__SetRelayOutputState() { _tds__SetRelayOutputState::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputState() { }
	friend SOAP_FMAC1 _tds__SetRelayOutputState * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:883 */
#ifndef SOAP_TYPE__tds__SetRelayOutputStateResponse
#define SOAP_TYPE__tds__SetRelayOutputStateResponse (296)
/* tds:SetRelayOutputStateResponse complex type: */
class SOAP_CMAC _tds__SetRelayOutputStateResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRelayOutputStateResponse (296)
	virtual int soap_type(void) const { return 296; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRelayOutputStateResponse, default initialized and not managed by a soap context
	virtual _tds__SetRelayOutputStateResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetRelayOutputStateResponse); }
	         _tds__SetRelayOutputStateResponse() { _tds__SetRelayOutputStateResponse::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputStateResponse() { }
	friend SOAP_FMAC1 _tds__SetRelayOutputStateResponse * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:886 */
#ifndef SOAP_TYPE__tds__SendAuxiliaryCommand
#define SOAP_TYPE__tds__SendAuxiliaryCommand (297)
/* tds:SendAuxiliaryCommand complex type: */
class SOAP_CMAC _tds__SendAuxiliaryCommand
{
public:
	std::string AuxiliaryCommand;	/* required element of XSD type tt:AuxiliaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SendAuxiliaryCommand (297)
	virtual int soap_type(void) const { return 297; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SendAuxiliaryCommand, default initialized and not managed by a soap context
	virtual _tds__SendAuxiliaryCommand *soap_alloc(void) const { return SOAP_NEW(_tds__SendAuxiliaryCommand); }
	         _tds__SendAuxiliaryCommand() { _tds__SendAuxiliaryCommand::soap_default(NULL); }
	virtual ~_tds__SendAuxiliaryCommand() { }
	friend SOAP_FMAC1 _tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate__tds__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:889 */
#ifndef SOAP_TYPE__tds__SendAuxiliaryCommandResponse
#define SOAP_TYPE__tds__SendAuxiliaryCommandResponse (298)
/* tds:SendAuxiliaryCommandResponse complex type: */
class SOAP_CMAC _tds__SendAuxiliaryCommandResponse
{
public:
	std::string *AuxiliaryCommandResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:AuxiliaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SendAuxiliaryCommandResponse (298)
	virtual int soap_type(void) const { return 298; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SendAuxiliaryCommandResponse, default initialized and not managed by a soap context
	virtual _tds__SendAuxiliaryCommandResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SendAuxiliaryCommandResponse); }
	         _tds__SendAuxiliaryCommandResponse() { _tds__SendAuxiliaryCommandResponse::soap_default(NULL); }
	virtual ~_tds__SendAuxiliaryCommandResponse() { }
	friend SOAP_FMAC1 _tds__SendAuxiliaryCommandResponse * SOAP_FMAC2 soap_instantiate__tds__SendAuxiliaryCommandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:892 */
#ifndef SOAP_TYPE__tds__GetDot11Capabilities
#define SOAP_TYPE__tds__GetDot11Capabilities (299)
/* tds:GetDot11Capabilities complex type: */
class SOAP_CMAC _tds__GetDot11Capabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot11Capabilities (299)
	virtual int soap_type(void) const { return 299; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot11Capabilities, default initialized and not managed by a soap context
	virtual _tds__GetDot11Capabilities *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot11Capabilities); }
	         _tds__GetDot11Capabilities() { _tds__GetDot11Capabilities::soap_default(NULL); }
	virtual ~_tds__GetDot11Capabilities() { }
	friend SOAP_FMAC1 _tds__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate__tds__GetDot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:895 */
#ifndef SOAP_TYPE__tds__GetDot11CapabilitiesResponse
#define SOAP_TYPE__tds__GetDot11CapabilitiesResponse (300)
/* tds:GetDot11CapabilitiesResponse complex type: */
class SOAP_CMAC _tds__GetDot11CapabilitiesResponse
{
public:
	tt__Dot11Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Dot11Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot11CapabilitiesResponse (300)
	virtual int soap_type(void) const { return 300; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot11CapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tds__GetDot11CapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot11CapabilitiesResponse); }
	         _tds__GetDot11CapabilitiesResponse() { _tds__GetDot11CapabilitiesResponse::soap_default(NULL); }
	virtual ~_tds__GetDot11CapabilitiesResponse() { }
	friend SOAP_FMAC1 _tds__GetDot11CapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot11CapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:898 */
#ifndef SOAP_TYPE__tds__GetDot11Status
#define SOAP_TYPE__tds__GetDot11Status (301)
/* tds:GetDot11Status complex type: */
class SOAP_CMAC _tds__GetDot11Status
{
public:
	std::string InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot11Status (301)
	virtual int soap_type(void) const { return 301; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot11Status, default initialized and not managed by a soap context
	virtual _tds__GetDot11Status *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot11Status); }
	         _tds__GetDot11Status() { _tds__GetDot11Status::soap_default(NULL); }
	virtual ~_tds__GetDot11Status() { }
	friend SOAP_FMAC1 _tds__GetDot11Status * SOAP_FMAC2 soap_instantiate__tds__GetDot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:901 */
#ifndef SOAP_TYPE__tds__GetDot11StatusResponse
#define SOAP_TYPE__tds__GetDot11StatusResponse (302)
/* tds:GetDot11StatusResponse complex type: */
class SOAP_CMAC _tds__GetDot11StatusResponse
{
public:
	tt__Dot11Status *Status;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Dot11Status */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot11StatusResponse (302)
	virtual int soap_type(void) const { return 302; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot11StatusResponse, default initialized and not managed by a soap context
	virtual _tds__GetDot11StatusResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot11StatusResponse); }
	         _tds__GetDot11StatusResponse() { _tds__GetDot11StatusResponse::soap_default(NULL); }
	virtual ~_tds__GetDot11StatusResponse() { }
	friend SOAP_FMAC1 _tds__GetDot11StatusResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot11StatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:904 */
#ifndef SOAP_TYPE__tds__ScanAvailableDot11Networks
#define SOAP_TYPE__tds__ScanAvailableDot11Networks (303)
/* tds:ScanAvailableDot11Networks complex type: */
class SOAP_CMAC _tds__ScanAvailableDot11Networks
{
public:
	std::string InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__ScanAvailableDot11Networks (303)
	virtual int soap_type(void) const { return 303; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__ScanAvailableDot11Networks, default initialized and not managed by a soap context
	virtual _tds__ScanAvailableDot11Networks *soap_alloc(void) const { return SOAP_NEW(_tds__ScanAvailableDot11Networks); }
	         _tds__ScanAvailableDot11Networks() { _tds__ScanAvailableDot11Networks::soap_default(NULL); }
	virtual ~_tds__ScanAvailableDot11Networks() { }
	friend SOAP_FMAC1 _tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate__tds__ScanAvailableDot11Networks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:907 */
#ifndef SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse
#define SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse (304)
/* tds:ScanAvailableDot11NetworksResponse complex type: */
class SOAP_CMAC _tds__ScanAvailableDot11NetworksResponse
{
public:
	std::vector<tt__Dot11AvailableNetworks *> Networks;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:Dot11AvailableNetworks */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse (304)
	virtual int soap_type(void) const { return 304; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__ScanAvailableDot11NetworksResponse, default initialized and not managed by a soap context
	virtual _tds__ScanAvailableDot11NetworksResponse *soap_alloc(void) const { return SOAP_NEW(_tds__ScanAvailableDot11NetworksResponse); }
	         _tds__ScanAvailableDot11NetworksResponse() { _tds__ScanAvailableDot11NetworksResponse::soap_default(NULL); }
	virtual ~_tds__ScanAvailableDot11NetworksResponse() { }
	friend SOAP_FMAC1 _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC2 soap_instantiate__tds__ScanAvailableDot11NetworksResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:910 */
#ifndef SOAP_TYPE__tds__GetSystemUris
#define SOAP_TYPE__tds__GetSystemUris (305)
/* tds:GetSystemUris complex type: */
class SOAP_CMAC _tds__GetSystemUris
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemUris (305)
	virtual int soap_type(void) const { return 305; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemUris, default initialized and not managed by a soap context
	virtual _tds__GetSystemUris *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemUris); }
	         _tds__GetSystemUris() { _tds__GetSystemUris::soap_default(NULL); }
	virtual ~_tds__GetSystemUris() { }
	friend SOAP_FMAC1 _tds__GetSystemUris * SOAP_FMAC2 soap_instantiate__tds__GetSystemUris(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:9482 */
#ifndef SOAP_TYPE__tds__GetSystemUrisResponse_Extension
#define SOAP_TYPE__tds__GetSystemUrisResponse_Extension (1084)
/* tds:GetSystemUrisResponse-Extension complex type: */
class SOAP_CMAC _tds__GetSystemUrisResponse_Extension
{
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemUrisResponse_Extension (1084)
	virtual int soap_type(void) const { return 1084; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemUrisResponse_Extension, default initialized and not managed by a soap context
	virtual _tds__GetSystemUrisResponse_Extension *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemUrisResponse_Extension); }
	         _tds__GetSystemUrisResponse_Extension() { _tds__GetSystemUrisResponse_Extension::soap_default(NULL); }
	virtual ~_tds__GetSystemUrisResponse_Extension() { }
	friend SOAP_FMAC1 _tds__GetSystemUrisResponse_Extension * SOAP_FMAC2 soap_instantiate__tds__GetSystemUrisResponse_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:913 */
#ifndef SOAP_TYPE__tds__GetSystemUrisResponse
#define SOAP_TYPE__tds__GetSystemUrisResponse (306)
/* tds:GetSystemUrisResponse complex type: */
class SOAP_CMAC _tds__GetSystemUrisResponse
{
public:
	tt__SystemLogUriList *SystemLogUris;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:SystemLogUriList */
	std::string *SupportInfoUri;	/* optional element of XSD type xsd:anyURI */
	std::string *SystemBackupUri;	/* optional element of XSD type xsd:anyURI */
	_tds__GetSystemUrisResponse_Extension *Extension;	/* optional element of XSD type tds:GetSystemUrisResponse-Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemUrisResponse (306)
	virtual int soap_type(void) const { return 306; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemUrisResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemUrisResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemUrisResponse); }
	         _tds__GetSystemUrisResponse() { _tds__GetSystemUrisResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemUrisResponse() { }
	friend SOAP_FMAC1 _tds__GetSystemUrisResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemUrisResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:916 */
#ifndef SOAP_TYPE__tds__StartFirmwareUpgrade
#define SOAP_TYPE__tds__StartFirmwareUpgrade (307)
/* tds:StartFirmwareUpgrade complex type: */
class SOAP_CMAC _tds__StartFirmwareUpgrade
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StartFirmwareUpgrade (307)
	virtual int soap_type(void) const { return 307; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StartFirmwareUpgrade, default initialized and not managed by a soap context
	virtual _tds__StartFirmwareUpgrade *soap_alloc(void) const { return SOAP_NEW(_tds__StartFirmwareUpgrade); }
	         _tds__StartFirmwareUpgrade() { _tds__StartFirmwareUpgrade::soap_default(NULL); }
	virtual ~_tds__StartFirmwareUpgrade() { }
	friend SOAP_FMAC1 _tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate__tds__StartFirmwareUpgrade(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:919 */
#ifndef SOAP_TYPE__tds__StartFirmwareUpgradeResponse
#define SOAP_TYPE__tds__StartFirmwareUpgradeResponse (308)
/* tds:StartFirmwareUpgradeResponse complex type: */
class SOAP_CMAC _tds__StartFirmwareUpgradeResponse
{
public:
	std::string UploadUri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:anyURI */
	LONG64 UploadDelay;	/* external (custom serializer) */
	LONG64 ExpectedDownTime;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StartFirmwareUpgradeResponse (308)
	virtual int soap_type(void) const { return 308; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StartFirmwareUpgradeResponse, default initialized and not managed by a soap context
	virtual _tds__StartFirmwareUpgradeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__StartFirmwareUpgradeResponse); }
	         _tds__StartFirmwareUpgradeResponse() { _tds__StartFirmwareUpgradeResponse::soap_default(NULL); }
	virtual ~_tds__StartFirmwareUpgradeResponse() { }
	friend SOAP_FMAC1 _tds__StartFirmwareUpgradeResponse * SOAP_FMAC2 soap_instantiate__tds__StartFirmwareUpgradeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:922 */
#ifndef SOAP_TYPE__tds__StartSystemRestore
#define SOAP_TYPE__tds__StartSystemRestore (309)
/* tds:StartSystemRestore complex type: */
class SOAP_CMAC _tds__StartSystemRestore
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StartSystemRestore (309)
	virtual int soap_type(void) const { return 309; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StartSystemRestore, default initialized and not managed by a soap context
	virtual _tds__StartSystemRestore *soap_alloc(void) const { return SOAP_NEW(_tds__StartSystemRestore); }
	         _tds__StartSystemRestore() { _tds__StartSystemRestore::soap_default(NULL); }
	virtual ~_tds__StartSystemRestore() { }
	friend SOAP_FMAC1 _tds__StartSystemRestore * SOAP_FMAC2 soap_instantiate__tds__StartSystemRestore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:925 */
#ifndef SOAP_TYPE__tds__StartSystemRestoreResponse
#define SOAP_TYPE__tds__StartSystemRestoreResponse (310)
/* tds:StartSystemRestoreResponse complex type: */
class SOAP_CMAC _tds__StartSystemRestoreResponse
{
public:
	std::string UploadUri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:anyURI */
	LONG64 ExpectedDownTime;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StartSystemRestoreResponse (310)
	virtual int soap_type(void) const { return 310; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StartSystemRestoreResponse, default initialized and not managed by a soap context
	virtual _tds__StartSystemRestoreResponse *soap_alloc(void) const { return SOAP_NEW(_tds__StartSystemRestoreResponse); }
	         _tds__StartSystemRestoreResponse() { _tds__StartSystemRestoreResponse::soap_default(NULL); }
	virtual ~_tds__StartSystemRestoreResponse() { }
	friend SOAP_FMAC1 _tds__StartSystemRestoreResponse * SOAP_FMAC2 soap_instantiate__tds__StartSystemRestoreResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:928 */
#ifndef SOAP_TYPE__tds__GetStorageConfigurations
#define SOAP_TYPE__tds__GetStorageConfigurations (311)
/* tds:GetStorageConfigurations complex type: */
class SOAP_CMAC _tds__GetStorageConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetStorageConfigurations (311)
	virtual int soap_type(void) const { return 311; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetStorageConfigurations, default initialized and not managed by a soap context
	virtual _tds__GetStorageConfigurations *soap_alloc(void) const { return SOAP_NEW(_tds__GetStorageConfigurations); }
	         _tds__GetStorageConfigurations() { _tds__GetStorageConfigurations::soap_default(NULL); }
	virtual ~_tds__GetStorageConfigurations() { }
	friend SOAP_FMAC1 _tds__GetStorageConfigurations * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:931 */
#ifndef SOAP_TYPE__tds__GetStorageConfigurationsResponse
#define SOAP_TYPE__tds__GetStorageConfigurationsResponse (312)
/* tds:GetStorageConfigurationsResponse complex type: */
class SOAP_CMAC _tds__GetStorageConfigurationsResponse
{
public:
	std::vector<tds__StorageConfiguration *> StorageConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tds:StorageConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetStorageConfigurationsResponse (312)
	virtual int soap_type(void) const { return 312; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetStorageConfigurationsResponse, default initialized and not managed by a soap context
	virtual _tds__GetStorageConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetStorageConfigurationsResponse); }
	         _tds__GetStorageConfigurationsResponse() { _tds__GetStorageConfigurationsResponse::soap_default(NULL); }
	virtual ~_tds__GetStorageConfigurationsResponse() { }
	friend SOAP_FMAC1 _tds__GetStorageConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:934 */
#ifndef SOAP_TYPE__tds__CreateStorageConfiguration
#define SOAP_TYPE__tds__CreateStorageConfiguration (313)
/* tds:CreateStorageConfiguration complex type: */
class SOAP_CMAC _tds__CreateStorageConfiguration
{
public:
	tds__StorageConfigurationData *StorageConfiguration;	/* required element of XSD type tds:StorageConfigurationData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateStorageConfiguration (313)
	virtual int soap_type(void) const { return 313; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateStorageConfiguration, default initialized and not managed by a soap context
	virtual _tds__CreateStorageConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__CreateStorageConfiguration); }
	         _tds__CreateStorageConfiguration() { _tds__CreateStorageConfiguration::soap_default(NULL); }
	virtual ~_tds__CreateStorageConfiguration() { }
	friend SOAP_FMAC1 _tds__CreateStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__CreateStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:937 */
#ifndef SOAP_TYPE__tds__CreateStorageConfigurationResponse
#define SOAP_TYPE__tds__CreateStorageConfigurationResponse (314)
/* tds:CreateStorageConfigurationResponse complex type: */
class SOAP_CMAC _tds__CreateStorageConfigurationResponse
{
public:
	std::string Token;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateStorageConfigurationResponse (314)
	virtual int soap_type(void) const { return 314; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateStorageConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__CreateStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__CreateStorageConfigurationResponse); }
	         _tds__CreateStorageConfigurationResponse() { _tds__CreateStorageConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__CreateStorageConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__CreateStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__CreateStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:940 */
#ifndef SOAP_TYPE__tds__GetStorageConfiguration
#define SOAP_TYPE__tds__GetStorageConfiguration (315)
/* tds:GetStorageConfiguration complex type: */
class SOAP_CMAC _tds__GetStorageConfiguration
{
public:
	std::string Token;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetStorageConfiguration (315)
	virtual int soap_type(void) const { return 315; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetStorageConfiguration, default initialized and not managed by a soap context
	virtual _tds__GetStorageConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__GetStorageConfiguration); }
	         _tds__GetStorageConfiguration() { _tds__GetStorageConfiguration::soap_default(NULL); }
	virtual ~_tds__GetStorageConfiguration() { }
	friend SOAP_FMAC1 _tds__GetStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:943 */
#ifndef SOAP_TYPE__tds__GetStorageConfigurationResponse
#define SOAP_TYPE__tds__GetStorageConfigurationResponse (316)
/* tds:GetStorageConfigurationResponse complex type: */
class SOAP_CMAC _tds__GetStorageConfigurationResponse
{
public:
	tds__StorageConfiguration *StorageConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tds:StorageConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetStorageConfigurationResponse (316)
	virtual int soap_type(void) const { return 316; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetStorageConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__GetStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetStorageConfigurationResponse); }
	         _tds__GetStorageConfigurationResponse() { _tds__GetStorageConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__GetStorageConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__GetStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:946 */
#ifndef SOAP_TYPE__tds__SetStorageConfiguration
#define SOAP_TYPE__tds__SetStorageConfiguration (317)
/* tds:SetStorageConfiguration complex type: */
class SOAP_CMAC _tds__SetStorageConfiguration
{
public:
	tds__StorageConfiguration *StorageConfiguration;	/* required element of XSD type tds:StorageConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetStorageConfiguration (317)
	virtual int soap_type(void) const { return 317; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetStorageConfiguration, default initialized and not managed by a soap context
	virtual _tds__SetStorageConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__SetStorageConfiguration); }
	         _tds__SetStorageConfiguration() { _tds__SetStorageConfiguration::soap_default(NULL); }
	virtual ~_tds__SetStorageConfiguration() { }
	friend SOAP_FMAC1 _tds__SetStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:949 */
#ifndef SOAP_TYPE__tds__SetStorageConfigurationResponse
#define SOAP_TYPE__tds__SetStorageConfigurationResponse (318)
/* tds:SetStorageConfigurationResponse complex type: */
class SOAP_CMAC _tds__SetStorageConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetStorageConfigurationResponse (318)
	virtual int soap_type(void) const { return 318; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetStorageConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__SetStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetStorageConfigurationResponse); }
	         _tds__SetStorageConfigurationResponse() { _tds__SetStorageConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__SetStorageConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__SetStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:952 */
#ifndef SOAP_TYPE__tds__DeleteStorageConfiguration
#define SOAP_TYPE__tds__DeleteStorageConfiguration (319)
/* tds:DeleteStorageConfiguration complex type: */
class SOAP_CMAC _tds__DeleteStorageConfiguration
{
public:
	std::string Token;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteStorageConfiguration (319)
	virtual int soap_type(void) const { return 319; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteStorageConfiguration, default initialized and not managed by a soap context
	virtual _tds__DeleteStorageConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteStorageConfiguration); }
	         _tds__DeleteStorageConfiguration() { _tds__DeleteStorageConfiguration::soap_default(NULL); }
	virtual ~_tds__DeleteStorageConfiguration() { }
	friend SOAP_FMAC1 _tds__DeleteStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__DeleteStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:955 */
#ifndef SOAP_TYPE__tds__DeleteStorageConfigurationResponse
#define SOAP_TYPE__tds__DeleteStorageConfigurationResponse (320)
/* tds:DeleteStorageConfigurationResponse complex type: */
class SOAP_CMAC _tds__DeleteStorageConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteStorageConfigurationResponse (320)
	virtual int soap_type(void) const { return 320; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteStorageConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__DeleteStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteStorageConfigurationResponse); }
	         _tds__DeleteStorageConfigurationResponse() { _tds__DeleteStorageConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__DeleteStorageConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__DeleteStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:958 */
#ifndef SOAP_TYPE__tds__GetGeoLocation
#define SOAP_TYPE__tds__GetGeoLocation (321)
/* tds:GetGeoLocation complex type: */
class SOAP_CMAC _tds__GetGeoLocation
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetGeoLocation (321)
	virtual int soap_type(void) const { return 321; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetGeoLocation, default initialized and not managed by a soap context
	virtual _tds__GetGeoLocation *soap_alloc(void) const { return SOAP_NEW(_tds__GetGeoLocation); }
	         _tds__GetGeoLocation() { _tds__GetGeoLocation::soap_default(NULL); }
	virtual ~_tds__GetGeoLocation() { }
	friend SOAP_FMAC1 _tds__GetGeoLocation * SOAP_FMAC2 soap_instantiate__tds__GetGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:961 */
#ifndef SOAP_TYPE__tds__GetGeoLocationResponse
#define SOAP_TYPE__tds__GetGeoLocationResponse (322)
/* tds:GetGeoLocationResponse complex type: */
class SOAP_CMAC _tds__GetGeoLocationResponse
{
public:
	std::vector<tt__LocationEntity *> Location;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:LocationEntity */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetGeoLocationResponse (322)
	virtual int soap_type(void) const { return 322; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetGeoLocationResponse, default initialized and not managed by a soap context
	virtual _tds__GetGeoLocationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetGeoLocationResponse); }
	         _tds__GetGeoLocationResponse() { _tds__GetGeoLocationResponse::soap_default(NULL); }
	virtual ~_tds__GetGeoLocationResponse() { }
	friend SOAP_FMAC1 _tds__GetGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__GetGeoLocationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:964 */
#ifndef SOAP_TYPE__tds__SetGeoLocation
#define SOAP_TYPE__tds__SetGeoLocation (323)
/* tds:SetGeoLocation complex type: */
class SOAP_CMAC _tds__SetGeoLocation
{
public:
	std::vector<tt__LocationEntity *> Location;	/* required element of XSD type tt:LocationEntity */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetGeoLocation (323)
	virtual int soap_type(void) const { return 323; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetGeoLocation, default initialized and not managed by a soap context
	virtual _tds__SetGeoLocation *soap_alloc(void) const { return SOAP_NEW(_tds__SetGeoLocation); }
	         _tds__SetGeoLocation() { _tds__SetGeoLocation::soap_default(NULL); }
	virtual ~_tds__SetGeoLocation() { }
	friend SOAP_FMAC1 _tds__SetGeoLocation * SOAP_FMAC2 soap_instantiate__tds__SetGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:967 */
#ifndef SOAP_TYPE__tds__SetGeoLocationResponse
#define SOAP_TYPE__tds__SetGeoLocationResponse (324)
/* tds:SetGeoLocationResponse complex type: */
class SOAP_CMAC _tds__SetGeoLocationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetGeoLocationResponse (324)
	virtual int soap_type(void) const { return 324; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetGeoLocationResponse, default initialized and not managed by a soap context
	virtual _tds__SetGeoLocationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetGeoLocationResponse); }
	         _tds__SetGeoLocationResponse() { _tds__SetGeoLocationResponse::soap_default(NULL); }
	virtual ~_tds__SetGeoLocationResponse() { }
	friend SOAP_FMAC1 _tds__SetGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__SetGeoLocationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:970 */
#ifndef SOAP_TYPE__tds__DeleteGeoLocation
#define SOAP_TYPE__tds__DeleteGeoLocation (325)
/* tds:DeleteGeoLocation complex type: */
class SOAP_CMAC _tds__DeleteGeoLocation
{
public:
	std::vector<tt__LocationEntity *> Location;	/* required element of XSD type tt:LocationEntity */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteGeoLocation (325)
	virtual int soap_type(void) const { return 325; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteGeoLocation, default initialized and not managed by a soap context
	virtual _tds__DeleteGeoLocation *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteGeoLocation); }
	         _tds__DeleteGeoLocation() { _tds__DeleteGeoLocation::soap_default(NULL); }
	virtual ~_tds__DeleteGeoLocation() { }
	friend SOAP_FMAC1 _tds__DeleteGeoLocation * SOAP_FMAC2 soap_instantiate__tds__DeleteGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:973 */
#ifndef SOAP_TYPE__tds__DeleteGeoLocationResponse
#define SOAP_TYPE__tds__DeleteGeoLocationResponse (326)
/* tds:DeleteGeoLocationResponse complex type: */
class SOAP_CMAC _tds__DeleteGeoLocationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteGeoLocationResponse (326)
	virtual int soap_type(void) const { return 326; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteGeoLocationResponse, default initialized and not managed by a soap context
	virtual _tds__DeleteGeoLocationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteGeoLocationResponse); }
	         _tds__DeleteGeoLocationResponse() { _tds__DeleteGeoLocationResponse::soap_default(NULL); }
	virtual ~_tds__DeleteGeoLocationResponse() { }
	friend SOAP_FMAC1 _tds__DeleteGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteGeoLocationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:976 */
#ifndef SOAP_TYPE_tt__DeviceEntity
#define SOAP_TYPE_tt__DeviceEntity (327)
/* Type tt__DeviceEntity is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DeviceEntity complex type: */
class SOAP_CMAC tt__DeviceEntity
{
public:
	std::string token;	/* required attribute of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DeviceEntity (327)
	virtual int soap_type(void) const { return 327; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DeviceEntity, default initialized and not managed by a soap context
	virtual tt__DeviceEntity *soap_alloc(void) const { return SOAP_NEW(tt__DeviceEntity); }
	         tt__DeviceEntity() { tt__DeviceEntity::soap_default(NULL); }
	virtual ~tt__DeviceEntity() { }
	friend SOAP_FMAC1 tt__DeviceEntity * SOAP_FMAC2 soap_instantiate_tt__DeviceEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:979 */
#ifndef SOAP_TYPE_tt__IntRectangle
#define SOAP_TYPE_tt__IntRectangle (328)
/* tt:IntRectangle complex type: */
class SOAP_CMAC tt__IntRectangle
{
public:
	int x;	/* required attribute of XSD type xsd:int */
	int y;	/* required attribute of XSD type xsd:int */
	int width;	/* required attribute of XSD type xsd:int */
	int height;	/* required attribute of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IntRectangle (328)
	virtual int soap_type(void) const { return 328; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IntRectangle, default initialized and not managed by a soap context
	virtual tt__IntRectangle *soap_alloc(void) const { return SOAP_NEW(tt__IntRectangle); }
	         tt__IntRectangle() { tt__IntRectangle::soap_default(NULL); }
	virtual ~tt__IntRectangle() { }
	friend SOAP_FMAC1 tt__IntRectangle * SOAP_FMAC2 soap_instantiate_tt__IntRectangle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:982 */
#ifndef SOAP_TYPE_tt__IntRectangleRange
#define SOAP_TYPE_tt__IntRectangleRange (329)
/* tt:IntRectangleRange complex type: */
class SOAP_CMAC tt__IntRectangleRange
{
public:
	tt__IntRange *XRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *YRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *WidthRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *HeightRange;	/* required element of XSD type tt:IntRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IntRectangleRange (329)
	virtual int soap_type(void) const { return 329; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IntRectangleRange, default initialized and not managed by a soap context
	virtual tt__IntRectangleRange *soap_alloc(void) const { return SOAP_NEW(tt__IntRectangleRange); }
	         tt__IntRectangleRange() { tt__IntRectangleRange::soap_default(NULL); }
	virtual ~tt__IntRectangleRange() { }
	friend SOAP_FMAC1 tt__IntRectangleRange * SOAP_FMAC2 soap_instantiate_tt__IntRectangleRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:985 */
#ifndef SOAP_TYPE_tt__IntRange
#define SOAP_TYPE_tt__IntRange (330)
/* tt:IntRange complex type: */
class SOAP_CMAC tt__IntRange
{
public:
	int Min;	/* required element of XSD type xsd:int */
	int Max;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IntRange (330)
	virtual int soap_type(void) const { return 330; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IntRange, default initialized and not managed by a soap context
	virtual tt__IntRange *soap_alloc(void) const { return SOAP_NEW(tt__IntRange); }
	         tt__IntRange() { tt__IntRange::soap_default(NULL); }
	virtual ~tt__IntRange() { }
	friend SOAP_FMAC1 tt__IntRange * SOAP_FMAC2 soap_instantiate_tt__IntRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:988 */
#ifndef SOAP_TYPE_tt__FloatRange
#define SOAP_TYPE_tt__FloatRange (331)
/* tt:FloatRange complex type: */
class SOAP_CMAC tt__FloatRange
{
public:
	float Min;	/* required element of XSD type xsd:float */
	float Max;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FloatRange (331)
	virtual int soap_type(void) const { return 331; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FloatRange, default initialized and not managed by a soap context
	virtual tt__FloatRange *soap_alloc(void) const { return SOAP_NEW(tt__FloatRange); }
	         tt__FloatRange() { tt__FloatRange::soap_default(NULL); }
	virtual ~tt__FloatRange() { }
	friend SOAP_FMAC1 tt__FloatRange * SOAP_FMAC2 soap_instantiate_tt__FloatRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:991 */
#ifndef SOAP_TYPE_tt__DurationRange
#define SOAP_TYPE_tt__DurationRange (332)
/* tt:DurationRange complex type: */
class SOAP_CMAC tt__DurationRange
{
public:
	LONG64 Min;	/* external (custom serializer) */
	LONG64 Max;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DurationRange (332)
	virtual int soap_type(void) const { return 332; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DurationRange, default initialized and not managed by a soap context
	virtual tt__DurationRange *soap_alloc(void) const { return SOAP_NEW(tt__DurationRange); }
	         tt__DurationRange() { tt__DurationRange::soap_default(NULL); }
	virtual ~tt__DurationRange() { }
	friend SOAP_FMAC1 tt__DurationRange * SOAP_FMAC2 soap_instantiate_tt__DurationRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:994 */
#ifndef SOAP_TYPE_tt__IntList
#define SOAP_TYPE_tt__IntList (333)
/* tt:IntList complex type: */
class SOAP_CMAC tt__IntList
{
public:
	std::vector<int> Items;	/* optional element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IntList (333)
	virtual int soap_type(void) const { return 333; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IntList, default initialized and not managed by a soap context
	virtual tt__IntList *soap_alloc(void) const { return SOAP_NEW(tt__IntList); }
	         tt__IntList() { tt__IntList::soap_default(NULL); }
	virtual ~tt__IntList() { }
	friend SOAP_FMAC1 tt__IntList * SOAP_FMAC2 soap_instantiate_tt__IntList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:997 */
#ifndef SOAP_TYPE_tt__FloatList
#define SOAP_TYPE_tt__FloatList (334)
/* tt:FloatList complex type: */
class SOAP_CMAC tt__FloatList
{
public:
	std::vector<float> Items;	/* optional element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FloatList (334)
	virtual int soap_type(void) const { return 334; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FloatList, default initialized and not managed by a soap context
	virtual tt__FloatList *soap_alloc(void) const { return SOAP_NEW(tt__FloatList); }
	         tt__FloatList() { tt__FloatList::soap_default(NULL); }
	virtual ~tt__FloatList() { }
	friend SOAP_FMAC1 tt__FloatList * SOAP_FMAC2 soap_instantiate_tt__FloatList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1000 */
#ifndef SOAP_TYPE_tt__AnyHolder
#define SOAP_TYPE_tt__AnyHolder (335)
/* tt:AnyHolder complex type: */
class SOAP_CMAC tt__AnyHolder
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnyHolder (335)
	virtual int soap_type(void) const { return 335; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnyHolder, default initialized and not managed by a soap context
	virtual tt__AnyHolder *soap_alloc(void) const { return SOAP_NEW(tt__AnyHolder); }
	         tt__AnyHolder() { tt__AnyHolder::soap_default(NULL); }
	virtual ~tt__AnyHolder() { }
	friend SOAP_FMAC1 tt__AnyHolder * SOAP_FMAC2 soap_instantiate_tt__AnyHolder(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1006 */
#ifndef SOAP_TYPE_tt__VideoSourceExtension
#define SOAP_TYPE_tt__VideoSourceExtension (337)
/* tt:VideoSourceExtension complex type: */
class SOAP_CMAC tt__VideoSourceExtension
{
public:
	tt__ImagingSettings20 *Imaging;	/* optional element of XSD type tt:ImagingSettings20 */
	tt__VideoSourceExtension2 *Extension;	/* optional element of XSD type tt:VideoSourceExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceExtension (337)
	virtual int soap_type(void) const { return 337; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceExtension, default initialized and not managed by a soap context
	virtual tt__VideoSourceExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceExtension); }
	         tt__VideoSourceExtension() { tt__VideoSourceExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceExtension() { }
	friend SOAP_FMAC1 tt__VideoSourceExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1009 */
#ifndef SOAP_TYPE_tt__VideoSourceExtension2
#define SOAP_TYPE_tt__VideoSourceExtension2 (338)
/* tt:VideoSourceExtension2 complex type: */
class SOAP_CMAC tt__VideoSourceExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceExtension2 (338)
	virtual int soap_type(void) const { return 338; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceExtension2, default initialized and not managed by a soap context
	virtual tt__VideoSourceExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceExtension2); }
	         tt__VideoSourceExtension2() { tt__VideoSourceExtension2::soap_default(NULL); }
	virtual ~tt__VideoSourceExtension2() { }
	friend SOAP_FMAC1 tt__VideoSourceExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1015 */
#ifndef SOAP_TYPE_tt__Profile
#define SOAP_TYPE_tt__Profile (340)
/* tt:Profile complex type: */
class SOAP_CMAC tt__Profile
{
public:
	std::string Name;	/* required element of XSD type tt:Name */
	tt__VideoSourceConfiguration *VideoSourceConfiguration;	/* optional element of XSD type tt:VideoSourceConfiguration */
	tt__AudioSourceConfiguration *AudioSourceConfiguration;	/* optional element of XSD type tt:AudioSourceConfiguration */
	tt__VideoEncoderConfiguration *VideoEncoderConfiguration;	/* optional element of XSD type tt:VideoEncoderConfiguration */
	tt__AudioEncoderConfiguration *AudioEncoderConfiguration;	/* optional element of XSD type tt:AudioEncoderConfiguration */
	tt__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;	/* optional element of XSD type tt:VideoAnalyticsConfiguration */
	tt__PTZConfiguration *PTZConfiguration;	/* optional element of XSD type tt:PTZConfiguration */
	tt__MetadataConfiguration *MetadataConfiguration;	/* optional element of XSD type tt:MetadataConfiguration */
	tt__ProfileExtension *Extension;	/* optional element of XSD type tt:ProfileExtension */
	std::string token;	/* required attribute of XSD type tt:ReferenceToken */
	bool *fixed;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Profile (340)
	virtual int soap_type(void) const { return 340; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Profile, default initialized and not managed by a soap context
	virtual tt__Profile *soap_alloc(void) const { return SOAP_NEW(tt__Profile); }
	         tt__Profile() { tt__Profile::soap_default(NULL); }
	virtual ~tt__Profile() { }
	friend SOAP_FMAC1 tt__Profile * SOAP_FMAC2 soap_instantiate_tt__Profile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1018 */
#ifndef SOAP_TYPE_tt__ProfileExtension
#define SOAP_TYPE_tt__ProfileExtension (341)
/* tt:ProfileExtension complex type: */
class SOAP_CMAC tt__ProfileExtension
{
public:
	tt__AudioOutputConfiguration *AudioOutputConfiguration;	/* optional element of XSD type tt:AudioOutputConfiguration */
	tt__AudioDecoderConfiguration *AudioDecoderConfiguration;	/* optional element of XSD type tt:AudioDecoderConfiguration */
	tt__ProfileExtension2 *Extension;	/* optional element of XSD type tt:ProfileExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ProfileExtension (341)
	virtual int soap_type(void) const { return 341; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ProfileExtension, default initialized and not managed by a soap context
	virtual tt__ProfileExtension *soap_alloc(void) const { return SOAP_NEW(tt__ProfileExtension); }
	         tt__ProfileExtension() { tt__ProfileExtension::soap_default(NULL); }
	virtual ~tt__ProfileExtension() { }
	friend SOAP_FMAC1 tt__ProfileExtension * SOAP_FMAC2 soap_instantiate_tt__ProfileExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1021 */
#ifndef SOAP_TYPE_tt__ProfileExtension2
#define SOAP_TYPE_tt__ProfileExtension2 (342)
/* tt:ProfileExtension2 complex type: */
class SOAP_CMAC tt__ProfileExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ProfileExtension2 (342)
	virtual int soap_type(void) const { return 342; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ProfileExtension2, default initialized and not managed by a soap context
	virtual tt__ProfileExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__ProfileExtension2); }
	         tt__ProfileExtension2() { tt__ProfileExtension2::soap_default(NULL); }
	virtual ~tt__ProfileExtension2() { }
	friend SOAP_FMAC1 tt__ProfileExtension2 * SOAP_FMAC2 soap_instantiate_tt__ProfileExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1024 */
#ifndef SOAP_TYPE_tt__ConfigurationEntity
#define SOAP_TYPE_tt__ConfigurationEntity (343)
/* Type tt__ConfigurationEntity is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ConfigurationEntity complex type: */
class SOAP_CMAC tt__ConfigurationEntity
{
public:
	std::string Name;	/* required element of XSD type tt:Name */
	int UseCount;	/* required element of XSD type xsd:int */
	std::string token;	/* required attribute of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ConfigurationEntity (343)
	virtual int soap_type(void) const { return 343; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ConfigurationEntity, default initialized and not managed by a soap context
	virtual tt__ConfigurationEntity *soap_alloc(void) const { return SOAP_NEW(tt__ConfigurationEntity); }
	         tt__ConfigurationEntity() { tt__ConfigurationEntity::soap_default(NULL); }
	virtual ~tt__ConfigurationEntity() { }
	friend SOAP_FMAC1 tt__ConfigurationEntity * SOAP_FMAC2 soap_instantiate_tt__ConfigurationEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1030 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension (345)
/* tt:VideoSourceConfigurationExtension complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationExtension
{
public:
	tt__Rotate *Rotate;	/* optional element of XSD type tt:Rotate */
	tt__VideoSourceConfigurationExtension2 *Extension;	/* optional element of XSD type tt:VideoSourceConfigurationExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationExtension (345)
	virtual int soap_type(void) const { return 345; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationExtension); }
	         tt__VideoSourceConfigurationExtension() { tt__VideoSourceConfigurationExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationExtension() { }
	friend SOAP_FMAC1 tt__VideoSourceConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1033 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension2 (346)
/* tt:VideoSourceConfigurationExtension2 complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationExtension2
{
public:
	std::vector<tt__LensDescription *> LensDescription;	/* optional element of XSD type tt:LensDescription */
	tt__SceneOrientation *SceneOrientation;	/* optional element of XSD type tt:SceneOrientation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationExtension2 (346)
	virtual int soap_type(void) const { return 346; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationExtension2, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationExtension2); }
	         tt__VideoSourceConfigurationExtension2() { tt__VideoSourceConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationExtension2() { }
	friend SOAP_FMAC1 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1036 */
#ifndef SOAP_TYPE_tt__Rotate
#define SOAP_TYPE_tt__Rotate (347)
/* tt:Rotate complex type: */
class SOAP_CMAC tt__Rotate
{
public:
	enum tt__RotateMode Mode;	/* required element of XSD type tt:RotateMode */
	int *Degree;	/* optional element of XSD type xsd:int */
	tt__RotateExtension *Extension;	/* optional element of XSD type tt:RotateExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Rotate (347)
	virtual int soap_type(void) const { return 347; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Rotate, default initialized and not managed by a soap context
	virtual tt__Rotate *soap_alloc(void) const { return SOAP_NEW(tt__Rotate); }
	         tt__Rotate() { tt__Rotate::soap_default(NULL); }
	virtual ~tt__Rotate() { }
	friend SOAP_FMAC1 tt__Rotate * SOAP_FMAC2 soap_instantiate_tt__Rotate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1039 */
#ifndef SOAP_TYPE_tt__RotateExtension
#define SOAP_TYPE_tt__RotateExtension (348)
/* tt:RotateExtension complex type: */
class SOAP_CMAC tt__RotateExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RotateExtension (348)
	virtual int soap_type(void) const { return 348; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RotateExtension, default initialized and not managed by a soap context
	virtual tt__RotateExtension *soap_alloc(void) const { return SOAP_NEW(tt__RotateExtension); }
	         tt__RotateExtension() { tt__RotateExtension::soap_default(NULL); }
	virtual ~tt__RotateExtension() { }
	friend SOAP_FMAC1 tt__RotateExtension * SOAP_FMAC2 soap_instantiate_tt__RotateExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1042 */
#ifndef SOAP_TYPE_tt__LensProjection
#define SOAP_TYPE_tt__LensProjection (349)
/* tt:LensProjection complex type: */
class SOAP_CMAC tt__LensProjection
{
public:
	float Angle;	/* required element of XSD type xsd:float */
	float Radius;	/* required element of XSD type xsd:float */
	float *Transmittance;	/* optional element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LensProjection (349)
	virtual int soap_type(void) const { return 349; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LensProjection, default initialized and not managed by a soap context
	virtual tt__LensProjection *soap_alloc(void) const { return SOAP_NEW(tt__LensProjection); }
	         tt__LensProjection() { tt__LensProjection::soap_default(NULL); }
	virtual ~tt__LensProjection() { }
	friend SOAP_FMAC1 tt__LensProjection * SOAP_FMAC2 soap_instantiate_tt__LensProjection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1045 */
#ifndef SOAP_TYPE_tt__LensOffset
#define SOAP_TYPE_tt__LensOffset (350)
/* tt:LensOffset complex type: */
class SOAP_CMAC tt__LensOffset
{
public:
	float *x;	/* optional attribute of XSD type xsd:float */
	float *y;	/* optional attribute of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LensOffset (350)
	virtual int soap_type(void) const { return 350; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LensOffset, default initialized and not managed by a soap context
	virtual tt__LensOffset *soap_alloc(void) const { return SOAP_NEW(tt__LensOffset); }
	         tt__LensOffset() { tt__LensOffset::soap_default(NULL); }
	virtual ~tt__LensOffset() { }
	friend SOAP_FMAC1 tt__LensOffset * SOAP_FMAC2 soap_instantiate_tt__LensOffset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1048 */
#ifndef SOAP_TYPE_tt__LensDescription
#define SOAP_TYPE_tt__LensDescription (351)
/* tt:LensDescription complex type: */
class SOAP_CMAC tt__LensDescription
{
public:
	tt__LensOffset *Offset;	/* required element of XSD type tt:LensOffset */
	std::vector<tt__LensProjection *> Projection;	/* required element of XSD type tt:LensProjection */
	float XFactor;	/* required element of XSD type xsd:float */
	float *FocalLength;	/* optional attribute of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LensDescription (351)
	virtual int soap_type(void) const { return 351; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LensDescription, default initialized and not managed by a soap context
	virtual tt__LensDescription *soap_alloc(void) const { return SOAP_NEW(tt__LensDescription); }
	         tt__LensDescription() { tt__LensDescription::soap_default(NULL); }
	virtual ~tt__LensDescription() { }
	friend SOAP_FMAC1 tt__LensDescription * SOAP_FMAC2 soap_instantiate_tt__LensDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1051 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptions
#define SOAP_TYPE_tt__VideoSourceConfigurationOptions (352)
/* tt:VideoSourceConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationOptions
{
public:
	tt__IntRectangleRange *BoundsRange;	/* required element of XSD type tt:IntRectangleRange */
	std::vector<std::string> VideoSourceTokensAvailable;	/* required element of XSD type tt:ReferenceToken */
	tt__VideoSourceConfigurationOptionsExtension *Extension;	/* optional element of XSD type tt:VideoSourceConfigurationOptionsExtension */
	int *MaximumNumberOfProfiles;	/* optional attribute of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationOptions (352)
	virtual int soap_type(void) const { return 352; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationOptions); }
	         tt__VideoSourceConfigurationOptions() { tt__VideoSourceConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptions() { }
	friend SOAP_FMAC1 tt__VideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1054 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension (353)
/* tt:VideoSourceConfigurationOptionsExtension complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationOptionsExtension
{
public:
	tt__RotateOptions *Rotate;	/* optional element of XSD type tt:RotateOptions */
	tt__VideoSourceConfigurationOptionsExtension2 *Extension;	/* optional element of XSD type tt:VideoSourceConfigurationOptionsExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension (353)
	virtual int soap_type(void) const { return 353; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationOptionsExtension); }
	         tt__VideoSourceConfigurationOptionsExtension() { tt__VideoSourceConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptionsExtension() { }
	friend SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1057 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2 (354)
/* tt:VideoSourceConfigurationOptionsExtension2 complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationOptionsExtension2
{
public:
	std::vector<enum tt__SceneOrientationMode> SceneOrientationMode;	/* optional element of XSD type tt:SceneOrientationMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2 (354)
	virtual int soap_type(void) const { return 354; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationOptionsExtension2, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationOptionsExtension2); }
	         tt__VideoSourceConfigurationOptionsExtension2() { tt__VideoSourceConfigurationOptionsExtension2::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptionsExtension2() { }
	friend SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1060 */
#ifndef SOAP_TYPE_tt__RotateOptions
#define SOAP_TYPE_tt__RotateOptions (355)
/* tt:RotateOptions complex type: */
class SOAP_CMAC tt__RotateOptions
{
public:
	std::vector<enum tt__RotateMode> Mode;	/* required element of XSD type tt:RotateMode */
	tt__IntList *DegreeList;	/* optional element of XSD type tt:IntList */
	tt__RotateOptionsExtension *Extension;	/* optional element of XSD type tt:RotateOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RotateOptions (355)
	virtual int soap_type(void) const { return 355; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RotateOptions, default initialized and not managed by a soap context
	virtual tt__RotateOptions *soap_alloc(void) const { return SOAP_NEW(tt__RotateOptions); }
	         tt__RotateOptions() { tt__RotateOptions::soap_default(NULL); }
	virtual ~tt__RotateOptions() { }
	friend SOAP_FMAC1 tt__RotateOptions * SOAP_FMAC2 soap_instantiate_tt__RotateOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1063 */
#ifndef SOAP_TYPE_tt__RotateOptionsExtension
#define SOAP_TYPE_tt__RotateOptionsExtension (356)
/* tt:RotateOptionsExtension complex type: */
class SOAP_CMAC tt__RotateOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RotateOptionsExtension (356)
	virtual int soap_type(void) const { return 356; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RotateOptionsExtension, default initialized and not managed by a soap context
	virtual tt__RotateOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__RotateOptionsExtension); }
	         tt__RotateOptionsExtension() { tt__RotateOptionsExtension::soap_default(NULL); }
	virtual ~tt__RotateOptionsExtension() { }
	friend SOAP_FMAC1 tt__RotateOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__RotateOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1066 */
#ifndef SOAP_TYPE_tt__SceneOrientation
#define SOAP_TYPE_tt__SceneOrientation (357)
/* tt:SceneOrientation complex type: */
class SOAP_CMAC tt__SceneOrientation
{
public:
	enum tt__SceneOrientationMode Mode;	/* required element of XSD type tt:SceneOrientationMode */
	std::string *Orientation;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SceneOrientation (357)
	virtual int soap_type(void) const { return 357; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SceneOrientation, default initialized and not managed by a soap context
	virtual tt__SceneOrientation *soap_alloc(void) const { return SOAP_NEW(tt__SceneOrientation); }
	         tt__SceneOrientation() { tt__SceneOrientation::soap_default(NULL); }
	virtual ~tt__SceneOrientation() { }
	friend SOAP_FMAC1 tt__SceneOrientation * SOAP_FMAC2 soap_instantiate_tt__SceneOrientation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1072 */
#ifndef SOAP_TYPE_tt__VideoResolution
#define SOAP_TYPE_tt__VideoResolution (359)
/* tt:VideoResolution complex type: */
class SOAP_CMAC tt__VideoResolution
{
public:
	int Width;	/* required element of XSD type xsd:int */
	int Height;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoResolution (359)
	virtual int soap_type(void) const { return 359; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoResolution, default initialized and not managed by a soap context
	virtual tt__VideoResolution *soap_alloc(void) const { return SOAP_NEW(tt__VideoResolution); }
	         tt__VideoResolution() { tt__VideoResolution::soap_default(NULL); }
	virtual ~tt__VideoResolution() { }
	friend SOAP_FMAC1 tt__VideoResolution * SOAP_FMAC2 soap_instantiate_tt__VideoResolution(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1075 */
#ifndef SOAP_TYPE_tt__VideoRateControl
#define SOAP_TYPE_tt__VideoRateControl (360)
/* tt:VideoRateControl complex type: */
class SOAP_CMAC tt__VideoRateControl
{
public:
	int FrameRateLimit;	/* required element of XSD type xsd:int */
	int EncodingInterval;	/* required element of XSD type xsd:int */
	int BitrateLimit;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoRateControl (360)
	virtual int soap_type(void) const { return 360; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoRateControl, default initialized and not managed by a soap context
	virtual tt__VideoRateControl *soap_alloc(void) const { return SOAP_NEW(tt__VideoRateControl); }
	         tt__VideoRateControl() { tt__VideoRateControl::soap_default(NULL); }
	virtual ~tt__VideoRateControl() { }
	friend SOAP_FMAC1 tt__VideoRateControl * SOAP_FMAC2 soap_instantiate_tt__VideoRateControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1078 */
#ifndef SOAP_TYPE_tt__Mpeg4Configuration
#define SOAP_TYPE_tt__Mpeg4Configuration (361)
/* tt:Mpeg4Configuration complex type: */
class SOAP_CMAC tt__Mpeg4Configuration
{
public:
	int GovLength;	/* required element of XSD type xsd:int */
	enum tt__Mpeg4Profile Mpeg4Profile;	/* required element of XSD type tt:Mpeg4Profile */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Mpeg4Configuration (361)
	virtual int soap_type(void) const { return 361; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Mpeg4Configuration, default initialized and not managed by a soap context
	virtual tt__Mpeg4Configuration *soap_alloc(void) const { return SOAP_NEW(tt__Mpeg4Configuration); }
	         tt__Mpeg4Configuration() { tt__Mpeg4Configuration::soap_default(NULL); }
	virtual ~tt__Mpeg4Configuration() { }
	friend SOAP_FMAC1 tt__Mpeg4Configuration * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1081 */
#ifndef SOAP_TYPE_tt__H264Configuration
#define SOAP_TYPE_tt__H264Configuration (362)
/* tt:H264Configuration complex type: */
class SOAP_CMAC tt__H264Configuration
{
public:
	int GovLength;	/* required element of XSD type xsd:int */
	enum tt__H264Profile H264Profile;	/* required element of XSD type tt:H264Profile */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__H264Configuration (362)
	virtual int soap_type(void) const { return 362; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__H264Configuration, default initialized and not managed by a soap context
	virtual tt__H264Configuration *soap_alloc(void) const { return SOAP_NEW(tt__H264Configuration); }
	         tt__H264Configuration() { tt__H264Configuration::soap_default(NULL); }
	virtual ~tt__H264Configuration() { }
	friend SOAP_FMAC1 tt__H264Configuration * SOAP_FMAC2 soap_instantiate_tt__H264Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1084 */
#ifndef SOAP_TYPE_tt__VideoEncoderConfigurationOptions
#define SOAP_TYPE_tt__VideoEncoderConfigurationOptions (363)
/* tt:VideoEncoderConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoEncoderConfigurationOptions
{
public:
	tt__IntRange *QualityRange;	/* required element of XSD type tt:IntRange */
	tt__JpegOptions *JPEG;	/* optional element of XSD type tt:JpegOptions */
	tt__Mpeg4Options *MPEG4;	/* optional element of XSD type tt:Mpeg4Options */
	tt__H264Options *H264;	/* optional element of XSD type tt:H264Options */
	tt__VideoEncoderOptionsExtension *Extension;	/* optional element of XSD type tt:VideoEncoderOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoderConfigurationOptions (363)
	virtual int soap_type(void) const { return 363; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoderConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoderConfigurationOptions); }
	         tt__VideoEncoderConfigurationOptions() { tt__VideoEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoEncoderConfigurationOptions() { }
	friend SOAP_FMAC1 tt__VideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1087 */
#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension (364)
/* tt:VideoEncoderOptionsExtension complex type: */
class SOAP_CMAC tt__VideoEncoderOptionsExtension
{
public:
	tt__JpegOptions2 *JPEG;	/* optional element of XSD type tt:JpegOptions2 */
	tt__Mpeg4Options2 *MPEG4;	/* optional element of XSD type tt:Mpeg4Options2 */
	tt__H264Options2 *H264;	/* optional element of XSD type tt:H264Options2 */
	tt__VideoEncoderOptionsExtension2 *Extension;	/* optional element of XSD type tt:VideoEncoderOptionsExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoderOptionsExtension (364)
	virtual int soap_type(void) const { return 364; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoderOptionsExtension, default initialized and not managed by a soap context
	virtual tt__VideoEncoderOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoderOptionsExtension); }
	         tt__VideoEncoderOptionsExtension() { tt__VideoEncoderOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoEncoderOptionsExtension() { }
	friend SOAP_FMAC1 tt__VideoEncoderOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1090 */
#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension2
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension2 (365)
/* tt:VideoEncoderOptionsExtension2 complex type: */
class SOAP_CMAC tt__VideoEncoderOptionsExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoderOptionsExtension2 (365)
	virtual int soap_type(void) const { return 365; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoderOptionsExtension2, default initialized and not managed by a soap context
	virtual tt__VideoEncoderOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoderOptionsExtension2); }
	         tt__VideoEncoderOptionsExtension2() { tt__VideoEncoderOptionsExtension2::soap_default(NULL); }
	virtual ~tt__VideoEncoderOptionsExtension2() { }
	friend SOAP_FMAC1 tt__VideoEncoderOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1093 */
#ifndef SOAP_TYPE_tt__JpegOptions
#define SOAP_TYPE_tt__JpegOptions (366)
/* Type tt__JpegOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:JpegOptions complex type: */
class SOAP_CMAC tt__JpegOptions
{
public:
	std::vector<tt__VideoResolution *> ResolutionsAvailable;	/* required element of XSD type tt:VideoResolution */
	tt__IntRange *FrameRateRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of XSD type tt:IntRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__JpegOptions (366)
	virtual int soap_type(void) const { return 366; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__JpegOptions, default initialized and not managed by a soap context
	virtual tt__JpegOptions *soap_alloc(void) const { return SOAP_NEW(tt__JpegOptions); }
	         tt__JpegOptions() { tt__JpegOptions::soap_default(NULL); }
	virtual ~tt__JpegOptions() { }
	friend SOAP_FMAC1 tt__JpegOptions * SOAP_FMAC2 soap_instantiate_tt__JpegOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1099 */
#ifndef SOAP_TYPE_tt__Mpeg4Options
#define SOAP_TYPE_tt__Mpeg4Options (368)
/* Type tt__Mpeg4Options is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Mpeg4Options complex type: */
class SOAP_CMAC tt__Mpeg4Options
{
public:
	std::vector<tt__VideoResolution *> ResolutionsAvailable;	/* required element of XSD type tt:VideoResolution */
	tt__IntRange *GovLengthRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *FrameRateRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of XSD type tt:IntRange */
	std::vector<enum tt__Mpeg4Profile> Mpeg4ProfilesSupported;	/* required element of XSD type tt:Mpeg4Profile */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Mpeg4Options (368)
	virtual int soap_type(void) const { return 368; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Mpeg4Options, default initialized and not managed by a soap context
	virtual tt__Mpeg4Options *soap_alloc(void) const { return SOAP_NEW(tt__Mpeg4Options); }
	         tt__Mpeg4Options() { tt__Mpeg4Options::soap_default(NULL); }
	virtual ~tt__Mpeg4Options() { }
	friend SOAP_FMAC1 tt__Mpeg4Options * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Options(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1105 */
#ifndef SOAP_TYPE_tt__H264Options
#define SOAP_TYPE_tt__H264Options (370)
/* Type tt__H264Options is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:H264Options complex type: */
class SOAP_CMAC tt__H264Options
{
public:
	std::vector<tt__VideoResolution *> ResolutionsAvailable;	/* required element of XSD type tt:VideoResolution */
	tt__IntRange *GovLengthRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *FrameRateRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of XSD type tt:IntRange */
	std::vector<enum tt__H264Profile> H264ProfilesSupported;	/* required element of XSD type tt:H264Profile */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__H264Options (370)
	virtual int soap_type(void) const { return 370; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__H264Options, default initialized and not managed by a soap context
	virtual tt__H264Options *soap_alloc(void) const { return SOAP_NEW(tt__H264Options); }
	         tt__H264Options() { tt__H264Options::soap_default(NULL); }
	virtual ~tt__H264Options() { }
	friend SOAP_FMAC1 tt__H264Options * SOAP_FMAC2 soap_instantiate_tt__H264Options(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1114 */
#ifndef SOAP_TYPE_tt__VideoResolution2
#define SOAP_TYPE_tt__VideoResolution2 (373)
/* tt:VideoResolution2 complex type: */
class SOAP_CMAC tt__VideoResolution2
{
public:
	int Width;	/* required element of XSD type xsd:int */
	int Height;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoResolution2 (373)
	virtual int soap_type(void) const { return 373; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoResolution2, default initialized and not managed by a soap context
	virtual tt__VideoResolution2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoResolution2); }
	         tt__VideoResolution2() { tt__VideoResolution2::soap_default(NULL); }
	virtual ~tt__VideoResolution2() { }
	friend SOAP_FMAC1 tt__VideoResolution2 * SOAP_FMAC2 soap_instantiate_tt__VideoResolution2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1117 */
#ifndef SOAP_TYPE_tt__VideoRateControl2
#define SOAP_TYPE_tt__VideoRateControl2 (374)
/* tt:VideoRateControl2 complex type: */
class SOAP_CMAC tt__VideoRateControl2
{
public:
	float FrameRateLimit;	/* required element of XSD type xsd:float */
	int BitrateLimit;	/* required element of XSD type xsd:int */
	bool *ConstantBitRate;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoRateControl2 (374)
	virtual int soap_type(void) const { return 374; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoRateControl2, default initialized and not managed by a soap context
	virtual tt__VideoRateControl2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoRateControl2); }
	         tt__VideoRateControl2() { tt__VideoRateControl2::soap_default(NULL); }
	virtual ~tt__VideoRateControl2() { }
	friend SOAP_FMAC1 tt__VideoRateControl2 * SOAP_FMAC2 soap_instantiate_tt__VideoRateControl2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1120 */
#ifndef SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions
#define SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions (375)
/* tt:VideoEncoder2ConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoEncoder2ConfigurationOptions
{
public:
	std::string Encoding;	/* required element of XSD type xsd:string */
	tt__FloatRange *QualityRange;	/* required element of XSD type tt:FloatRange */
	std::vector<tt__VideoResolution2 *> ResolutionsAvailable;	/* required element of XSD type tt:VideoResolution2 */
	tt__IntRange *BitrateRange;	/* required element of XSD type tt:IntRange */
	std::string *GovLengthRange;	/* optional attribute of XSD type tt:IntAttrList */
	std::string *FrameRatesSupported;	/* optional attribute of XSD type tt:FloatAttrList */
	std::string *ProfilesSupported;	/* optional attribute of XSD type tt:StringAttrList */
	bool *ConstantBitRateSupported;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions (375)
	virtual int soap_type(void) const { return 375; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoder2ConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoEncoder2ConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoder2ConfigurationOptions); }
	         tt__VideoEncoder2ConfigurationOptions() { tt__VideoEncoder2ConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoEncoder2ConfigurationOptions() { }
	friend SOAP_FMAC1 tt__VideoEncoder2ConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoEncoder2ConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1126 */
#ifndef SOAP_TYPE_tt__AudioSourceConfigurationOptions
#define SOAP_TYPE_tt__AudioSourceConfigurationOptions (377)
/* tt:AudioSourceConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioSourceConfigurationOptions
{
public:
	std::vector<std::string> InputTokensAvailable;	/* required element of XSD type tt:ReferenceToken */
	tt__AudioSourceOptionsExtension *Extension;	/* optional element of XSD type tt:AudioSourceOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioSourceConfigurationOptions (377)
	virtual int soap_type(void) const { return 377; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioSourceConfigurationOptions); }
	         tt__AudioSourceConfigurationOptions() { tt__AudioSourceConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioSourceConfigurationOptions() { }
	friend SOAP_FMAC1 tt__AudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1129 */
#ifndef SOAP_TYPE_tt__AudioSourceOptionsExtension
#define SOAP_TYPE_tt__AudioSourceOptionsExtension (378)
/* tt:AudioSourceOptionsExtension complex type: */
class SOAP_CMAC tt__AudioSourceOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioSourceOptionsExtension (378)
	virtual int soap_type(void) const { return 378; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioSourceOptionsExtension, default initialized and not managed by a soap context
	virtual tt__AudioSourceOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__AudioSourceOptionsExtension); }
	         tt__AudioSourceOptionsExtension() { tt__AudioSourceOptionsExtension::soap_default(NULL); }
	virtual ~tt__AudioSourceOptionsExtension() { }
	friend SOAP_FMAC1 tt__AudioSourceOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__AudioSourceOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1135 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOptions
#define SOAP_TYPE_tt__AudioEncoderConfigurationOptions (380)
/* tt:AudioEncoderConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioEncoderConfigurationOptions
{
public:
	std::vector<tt__AudioEncoderConfigurationOption *> Options;	/* optional element of XSD type tt:AudioEncoderConfigurationOption */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoderConfigurationOptions (380)
	virtual int soap_type(void) const { return 380; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoderConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoderConfigurationOptions); }
	         tt__AudioEncoderConfigurationOptions() { tt__AudioEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfigurationOptions() { }
	friend SOAP_FMAC1 tt__AudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1138 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOption
#define SOAP_TYPE_tt__AudioEncoderConfigurationOption (381)
/* tt:AudioEncoderConfigurationOption complex type: */
class SOAP_CMAC tt__AudioEncoderConfigurationOption
{
public:
	enum tt__AudioEncoding Encoding;	/* required element of XSD type tt:AudioEncoding */
	tt__IntList *BitrateList;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateList;	/* required element of XSD type tt:IntList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoderConfigurationOption (381)
	virtual int soap_type(void) const { return 381; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoderConfigurationOption, default initialized and not managed by a soap context
	virtual tt__AudioEncoderConfigurationOption *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoderConfigurationOption); }
	         tt__AudioEncoderConfigurationOption() { tt__AudioEncoderConfigurationOption::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfigurationOption() { }
	friend SOAP_FMAC1 tt__AudioEncoderConfigurationOption * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfigurationOption(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1144 */
#ifndef SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions
#define SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions (383)
/* tt:AudioEncoder2ConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioEncoder2ConfigurationOptions
{
public:
	std::string Encoding;	/* required element of XSD type xsd:string */
	tt__IntList *BitrateList;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateList;	/* required element of XSD type tt:IntList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions (383)
	virtual int soap_type(void) const { return 383; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoder2ConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioEncoder2ConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoder2ConfigurationOptions); }
	         tt__AudioEncoder2ConfigurationOptions() { tt__AudioEncoder2ConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioEncoder2ConfigurationOptions() { }
	friend SOAP_FMAC1 tt__AudioEncoder2ConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioEncoder2ConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1153 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationExtension
#define SOAP_TYPE_tt__MetadataConfigurationExtension (386)
/* tt:MetadataConfigurationExtension complex type: */
class SOAP_CMAC tt__MetadataConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataConfigurationExtension (386)
	virtual int soap_type(void) const { return 386; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__MetadataConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__MetadataConfigurationExtension); }
	         tt__MetadataConfigurationExtension() { tt__MetadataConfigurationExtension::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationExtension() { }
	friend SOAP_FMAC1 tt__MetadataConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1156 */
#ifndef SOAP_TYPE_tt__PTZFilter
#define SOAP_TYPE_tt__PTZFilter (387)
/* tt:PTZFilter complex type: */
class SOAP_CMAC tt__PTZFilter
{
public:
	bool Status;	/* required element of XSD type xsd:boolean */
	bool Position;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZFilter (387)
	virtual int soap_type(void) const { return 387; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZFilter, default initialized and not managed by a soap context
	virtual tt__PTZFilter *soap_alloc(void) const { return SOAP_NEW(tt__PTZFilter); }
	         tt__PTZFilter() { tt__PTZFilter::soap_default(NULL); }
	virtual ~tt__PTZFilter() { }
	friend SOAP_FMAC1 tt__PTZFilter * SOAP_FMAC2 soap_instantiate_tt__PTZFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:11582 */
#ifndef SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy (1142)
/* tt:EventSubscription-SubscriptionPolicy complex type: */
class SOAP_CMAC _tt__EventSubscription_SubscriptionPolicy
{
public:
	/// Return the unique type ID value SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy (1142)
	virtual int soap_type(void) const { return 1142; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__EventSubscription_SubscriptionPolicy, default initialized and not managed by a soap context
	virtual _tt__EventSubscription_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW(_tt__EventSubscription_SubscriptionPolicy); }
	         _tt__EventSubscription_SubscriptionPolicy() { _tt__EventSubscription_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_tt__EventSubscription_SubscriptionPolicy() { }
	friend SOAP_FMAC1 _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__tt__EventSubscription_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1159 */
#ifndef SOAP_TYPE_tt__EventSubscription
#define SOAP_TYPE_tt__EventSubscription (388)
/* tt:EventSubscription complex type: */
class SOAP_CMAC tt__EventSubscription
{
public:
	wsnt__FilterType *Filter;	/* optional element of XSD type wsnt:FilterType */
	_tt__EventSubscription_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of XSD type tt:EventSubscription-SubscriptionPolicy */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EventSubscription (388)
	virtual int soap_type(void) const { return 388; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EventSubscription, default initialized and not managed by a soap context
	virtual tt__EventSubscription *soap_alloc(void) const { return SOAP_NEW(tt__EventSubscription); }
	         tt__EventSubscription() { tt__EventSubscription::soap_default(NULL); }
	virtual ~tt__EventSubscription() { }
	friend SOAP_FMAC1 tt__EventSubscription * SOAP_FMAC2 soap_instantiate_tt__EventSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1162 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptions
#define SOAP_TYPE_tt__MetadataConfigurationOptions (389)
/* tt:MetadataConfigurationOptions complex type: */
class SOAP_CMAC tt__MetadataConfigurationOptions
{
public:
	tt__PTZStatusFilterOptions *PTZStatusFilterOptions;	/* required element of XSD type tt:PTZStatusFilterOptions */
	tt__MetadataConfigurationOptionsExtension *Extension;	/* optional element of XSD type tt:MetadataConfigurationOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataConfigurationOptions (389)
	virtual int soap_type(void) const { return 389; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__MetadataConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__MetadataConfigurationOptions); }
	         tt__MetadataConfigurationOptions() { tt__MetadataConfigurationOptions::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationOptions() { }
	friend SOAP_FMAC1 tt__MetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1165 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptionsExtension
#define SOAP_TYPE_tt__MetadataConfigurationOptionsExtension (390)
/* tt:MetadataConfigurationOptionsExtension complex type: */
class SOAP_CMAC tt__MetadataConfigurationOptionsExtension
{
public:
	std::vector<std::string> CompressionType;	/* optional element of XSD type xsd:string */
	tt__MetadataConfigurationOptionsExtension2 *Extension;	/* optional element of XSD type tt:MetadataConfigurationOptionsExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataConfigurationOptionsExtension (390)
	virtual int soap_type(void) const { return 390; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataConfigurationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__MetadataConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__MetadataConfigurationOptionsExtension); }
	         tt__MetadataConfigurationOptionsExtension() { tt__MetadataConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationOptionsExtension() { }
	friend SOAP_FMAC1 tt__MetadataConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1168 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2
#define SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2 (391)
/* tt:MetadataConfigurationOptionsExtension2 complex type: */
class SOAP_CMAC tt__MetadataConfigurationOptionsExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2 (391)
	virtual int soap_type(void) const { return 391; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataConfigurationOptionsExtension2, default initialized and not managed by a soap context
	virtual tt__MetadataConfigurationOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__MetadataConfigurationOptionsExtension2); }
	         tt__MetadataConfigurationOptionsExtension2() { tt__MetadataConfigurationOptionsExtension2::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationOptionsExtension2() { }
	friend SOAP_FMAC1 tt__MetadataConfigurationOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1171 */
#ifndef SOAP_TYPE_tt__PTZStatusFilterOptions
#define SOAP_TYPE_tt__PTZStatusFilterOptions (392)
/* tt:PTZStatusFilterOptions complex type: */
class SOAP_CMAC tt__PTZStatusFilterOptions
{
public:
	bool PanTiltStatusSupported;	/* required element of XSD type xsd:boolean */
	bool ZoomStatusSupported;	/* required element of XSD type xsd:boolean */
	bool *PanTiltPositionSupported;	/* optional element of XSD type xsd:boolean */
	bool *ZoomPositionSupported;	/* optional element of XSD type xsd:boolean */
	tt__PTZStatusFilterOptionsExtension *Extension;	/* optional element of XSD type tt:PTZStatusFilterOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZStatusFilterOptions (392)
	virtual int soap_type(void) const { return 392; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZStatusFilterOptions, default initialized and not managed by a soap context
	virtual tt__PTZStatusFilterOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZStatusFilterOptions); }
	         tt__PTZStatusFilterOptions() { tt__PTZStatusFilterOptions::soap_default(NULL); }
	virtual ~tt__PTZStatusFilterOptions() { }
	friend SOAP_FMAC1 tt__PTZStatusFilterOptions * SOAP_FMAC2 soap_instantiate_tt__PTZStatusFilterOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1174 */
#ifndef SOAP_TYPE_tt__PTZStatusFilterOptionsExtension
#define SOAP_TYPE_tt__PTZStatusFilterOptionsExtension (393)
/* tt:PTZStatusFilterOptionsExtension complex type: */
class SOAP_CMAC tt__PTZStatusFilterOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZStatusFilterOptionsExtension (393)
	virtual int soap_type(void) const { return 393; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZStatusFilterOptionsExtension, default initialized and not managed by a soap context
	virtual tt__PTZStatusFilterOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZStatusFilterOptionsExtension); }
	         tt__PTZStatusFilterOptionsExtension() { tt__PTZStatusFilterOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTZStatusFilterOptionsExtension() { }
	friend SOAP_FMAC1 tt__PTZStatusFilterOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZStatusFilterOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1180 */
#ifndef SOAP_TYPE_tt__VideoOutputExtension
#define SOAP_TYPE_tt__VideoOutputExtension (395)
/* tt:VideoOutputExtension complex type: */
class SOAP_CMAC tt__VideoOutputExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoOutputExtension (395)
	virtual int soap_type(void) const { return 395; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoOutputExtension, default initialized and not managed by a soap context
	virtual tt__VideoOutputExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoOutputExtension); }
	         tt__VideoOutputExtension() { tt__VideoOutputExtension::soap_default(NULL); }
	virtual ~tt__VideoOutputExtension() { }
	friend SOAP_FMAC1 tt__VideoOutputExtension * SOAP_FMAC2 soap_instantiate_tt__VideoOutputExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1186 */
#ifndef SOAP_TYPE_tt__VideoOutputConfigurationOptions
#define SOAP_TYPE_tt__VideoOutputConfigurationOptions (397)
/* tt:VideoOutputConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoOutputConfigurationOptions
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoOutputConfigurationOptions (397)
	virtual int soap_type(void) const { return 397; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoOutputConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoOutputConfigurationOptions); }
	         tt__VideoOutputConfigurationOptions() { tt__VideoOutputConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoOutputConfigurationOptions() { }
	friend SOAP_FMAC1 tt__VideoOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1189 */
#ifndef SOAP_TYPE_tt__VideoDecoderConfigurationOptions
#define SOAP_TYPE_tt__VideoDecoderConfigurationOptions (398)
/* tt:VideoDecoderConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoDecoderConfigurationOptions
{
public:
	tt__JpegDecOptions *JpegDecOptions;	/* optional element of XSD type tt:JpegDecOptions */
	tt__H264DecOptions *H264DecOptions;	/* optional element of XSD type tt:H264DecOptions */
	tt__Mpeg4DecOptions *Mpeg4DecOptions;	/* optional element of XSD type tt:Mpeg4DecOptions */
	tt__VideoDecoderConfigurationOptionsExtension *Extension;	/* optional element of XSD type tt:VideoDecoderConfigurationOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoDecoderConfigurationOptions (398)
	virtual int soap_type(void) const { return 398; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoDecoderConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoDecoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoDecoderConfigurationOptions); }
	         tt__VideoDecoderConfigurationOptions() { tt__VideoDecoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoDecoderConfigurationOptions() { }
	friend SOAP_FMAC1 tt__VideoDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1192 */
#ifndef SOAP_TYPE_tt__H264DecOptions
#define SOAP_TYPE_tt__H264DecOptions (399)
/* tt:H264DecOptions complex type: */
class SOAP_CMAC tt__H264DecOptions
{
public:
	std::vector<tt__VideoResolution *> ResolutionsAvailable;	/* required element of XSD type tt:VideoResolution */
	std::vector<enum tt__H264Profile> SupportedH264Profiles;	/* required element of XSD type tt:H264Profile */
	tt__IntRange *SupportedInputBitrate;	/* required element of XSD type tt:IntRange */
	tt__IntRange *SupportedFrameRate;	/* required element of XSD type tt:IntRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__H264DecOptions (399)
	virtual int soap_type(void) const { return 399; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__H264DecOptions, default initialized and not managed by a soap context
	virtual tt__H264DecOptions *soap_alloc(void) const { return SOAP_NEW(tt__H264DecOptions); }
	         tt__H264DecOptions() { tt__H264DecOptions::soap_default(NULL); }
	virtual ~tt__H264DecOptions() { }
	friend SOAP_FMAC1 tt__H264DecOptions * SOAP_FMAC2 soap_instantiate_tt__H264DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1195 */
#ifndef SOAP_TYPE_tt__JpegDecOptions
#define SOAP_TYPE_tt__JpegDecOptions (400)
/* tt:JpegDecOptions complex type: */
class SOAP_CMAC tt__JpegDecOptions
{
public:
	std::vector<tt__VideoResolution *> ResolutionsAvailable;	/* required element of XSD type tt:VideoResolution */
	tt__IntRange *SupportedInputBitrate;	/* required element of XSD type tt:IntRange */
	tt__IntRange *SupportedFrameRate;	/* required element of XSD type tt:IntRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__JpegDecOptions (400)
	virtual int soap_type(void) const { return 400; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__JpegDecOptions, default initialized and not managed by a soap context
	virtual tt__JpegDecOptions *soap_alloc(void) const { return SOAP_NEW(tt__JpegDecOptions); }
	         tt__JpegDecOptions() { tt__JpegDecOptions::soap_default(NULL); }
	virtual ~tt__JpegDecOptions() { }
	friend SOAP_FMAC1 tt__JpegDecOptions * SOAP_FMAC2 soap_instantiate_tt__JpegDecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1198 */
#ifndef SOAP_TYPE_tt__Mpeg4DecOptions
#define SOAP_TYPE_tt__Mpeg4DecOptions (401)
/* tt:Mpeg4DecOptions complex type: */
class SOAP_CMAC tt__Mpeg4DecOptions
{
public:
	std::vector<tt__VideoResolution *> ResolutionsAvailable;	/* required element of XSD type tt:VideoResolution */
	std::vector<enum tt__Mpeg4Profile> SupportedMpeg4Profiles;	/* required element of XSD type tt:Mpeg4Profile */
	tt__IntRange *SupportedInputBitrate;	/* required element of XSD type tt:IntRange */
	tt__IntRange *SupportedFrameRate;	/* required element of XSD type tt:IntRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Mpeg4DecOptions (401)
	virtual int soap_type(void) const { return 401; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Mpeg4DecOptions, default initialized and not managed by a soap context
	virtual tt__Mpeg4DecOptions *soap_alloc(void) const { return SOAP_NEW(tt__Mpeg4DecOptions); }
	         tt__Mpeg4DecOptions() { tt__Mpeg4DecOptions::soap_default(NULL); }
	virtual ~tt__Mpeg4DecOptions() { }
	friend SOAP_FMAC1 tt__Mpeg4DecOptions * SOAP_FMAC2 soap_instantiate_tt__Mpeg4DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1201 */
#ifndef SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension (402)
/* tt:VideoDecoderConfigurationOptionsExtension complex type: */
class SOAP_CMAC tt__VideoDecoderConfigurationOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension (402)
	virtual int soap_type(void) const { return 402; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoDecoderConfigurationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__VideoDecoderConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoDecoderConfigurationOptionsExtension); }
	         tt__VideoDecoderConfigurationOptionsExtension() { tt__VideoDecoderConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoDecoderConfigurationOptionsExtension() { }
	friend SOAP_FMAC1 tt__VideoDecoderConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoDecoderConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1210 */
#ifndef SOAP_TYPE_tt__AudioOutputConfigurationOptions
#define SOAP_TYPE_tt__AudioOutputConfigurationOptions (405)
/* tt:AudioOutputConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioOutputConfigurationOptions
{
public:
	std::vector<std::string> OutputTokensAvailable;	/* required element of XSD type tt:ReferenceToken */
	std::vector<std::string> SendPrimacyOptions;	/* optional element of XSD type xsd:anyURI */
	tt__IntRange *OutputLevelRange;	/* required element of XSD type tt:IntRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioOutputConfigurationOptions (405)
	virtual int soap_type(void) const { return 405; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioOutputConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioOutputConfigurationOptions); }
	         tt__AudioOutputConfigurationOptions() { tt__AudioOutputConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioOutputConfigurationOptions() { }
	friend SOAP_FMAC1 tt__AudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1216 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptions
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptions (407)
/* tt:AudioDecoderConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioDecoderConfigurationOptions
{
public:
	tt__AACDecOptions *AACDecOptions;	/* optional element of XSD type tt:AACDecOptions */
	tt__G711DecOptions *G711DecOptions;	/* optional element of XSD type tt:G711DecOptions */
	tt__G726DecOptions *G726DecOptions;	/* optional element of XSD type tt:G726DecOptions */
	tt__AudioDecoderConfigurationOptionsExtension *Extension;	/* optional element of XSD type tt:AudioDecoderConfigurationOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioDecoderConfigurationOptions (407)
	virtual int soap_type(void) const { return 407; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioDecoderConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioDecoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioDecoderConfigurationOptions); }
	         tt__AudioDecoderConfigurationOptions() { tt__AudioDecoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioDecoderConfigurationOptions() { }
	friend SOAP_FMAC1 tt__AudioDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1219 */
#ifndef SOAP_TYPE_tt__G711DecOptions
#define SOAP_TYPE_tt__G711DecOptions (408)
/* tt:G711DecOptions complex type: */
class SOAP_CMAC tt__G711DecOptions
{
public:
	tt__IntList *Bitrate;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateRange;	/* required element of XSD type tt:IntList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__G711DecOptions (408)
	virtual int soap_type(void) const { return 408; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__G711DecOptions, default initialized and not managed by a soap context
	virtual tt__G711DecOptions *soap_alloc(void) const { return SOAP_NEW(tt__G711DecOptions); }
	         tt__G711DecOptions() { tt__G711DecOptions::soap_default(NULL); }
	virtual ~tt__G711DecOptions() { }
	friend SOAP_FMAC1 tt__G711DecOptions * SOAP_FMAC2 soap_instantiate_tt__G711DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1222 */
#ifndef SOAP_TYPE_tt__AACDecOptions
#define SOAP_TYPE_tt__AACDecOptions (409)
/* tt:AACDecOptions complex type: */
class SOAP_CMAC tt__AACDecOptions
{
public:
	tt__IntList *Bitrate;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateRange;	/* required element of XSD type tt:IntList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AACDecOptions (409)
	virtual int soap_type(void) const { return 409; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AACDecOptions, default initialized and not managed by a soap context
	virtual tt__AACDecOptions *soap_alloc(void) const { return SOAP_NEW(tt__AACDecOptions); }
	         tt__AACDecOptions() { tt__AACDecOptions::soap_default(NULL); }
	virtual ~tt__AACDecOptions() { }
	friend SOAP_FMAC1 tt__AACDecOptions * SOAP_FMAC2 soap_instantiate_tt__AACDecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1225 */
#ifndef SOAP_TYPE_tt__G726DecOptions
#define SOAP_TYPE_tt__G726DecOptions (410)
/* tt:G726DecOptions complex type: */
class SOAP_CMAC tt__G726DecOptions
{
public:
	tt__IntList *Bitrate;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateRange;	/* required element of XSD type tt:IntList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__G726DecOptions (410)
	virtual int soap_type(void) const { return 410; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__G726DecOptions, default initialized and not managed by a soap context
	virtual tt__G726DecOptions *soap_alloc(void) const { return SOAP_NEW(tt__G726DecOptions); }
	         tt__G726DecOptions() { tt__G726DecOptions::soap_default(NULL); }
	virtual ~tt__G726DecOptions() { }
	friend SOAP_FMAC1 tt__G726DecOptions * SOAP_FMAC2 soap_instantiate_tt__G726DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1228 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension (411)
/* tt:AudioDecoderConfigurationOptionsExtension complex type: */
class SOAP_CMAC tt__AudioDecoderConfigurationOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension (411)
	virtual int soap_type(void) const { return 411; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioDecoderConfigurationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__AudioDecoderConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__AudioDecoderConfigurationOptionsExtension); }
	         tt__AudioDecoderConfigurationOptionsExtension() { tt__AudioDecoderConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__AudioDecoderConfigurationOptionsExtension() { }
	friend SOAP_FMAC1 tt__AudioDecoderConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1231 */
#ifndef SOAP_TYPE_tt__MulticastConfiguration
#define SOAP_TYPE_tt__MulticastConfiguration (412)
/* tt:MulticastConfiguration complex type: */
class SOAP_CMAC tt__MulticastConfiguration
{
public:
	tt__IPAddress *Address;	/* required element of XSD type tt:IPAddress */
	int Port;	/* required element of XSD type xsd:int */
	int TTL;	/* required element of XSD type xsd:int */
	bool AutoStart;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MulticastConfiguration (412)
	virtual int soap_type(void) const { return 412; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MulticastConfiguration, default initialized and not managed by a soap context
	virtual tt__MulticastConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__MulticastConfiguration); }
	         tt__MulticastConfiguration() { tt__MulticastConfiguration::soap_default(NULL); }
	virtual ~tt__MulticastConfiguration() { }
	friend SOAP_FMAC1 tt__MulticastConfiguration * SOAP_FMAC2 soap_instantiate_tt__MulticastConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1234 */
#ifndef SOAP_TYPE_tt__StreamSetup
#define SOAP_TYPE_tt__StreamSetup (413)
/* tt:StreamSetup complex type: */
class SOAP_CMAC tt__StreamSetup
{
public:
	enum tt__StreamType Stream;	/* required element of XSD type tt:StreamType */
	tt__Transport *Transport;	/* required element of XSD type tt:Transport */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__StreamSetup (413)
	virtual int soap_type(void) const { return 413; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__StreamSetup, default initialized and not managed by a soap context
	virtual tt__StreamSetup *soap_alloc(void) const { return SOAP_NEW(tt__StreamSetup); }
	         tt__StreamSetup() { tt__StreamSetup::soap_default(NULL); }
	virtual ~tt__StreamSetup() { }
	friend SOAP_FMAC1 tt__StreamSetup * SOAP_FMAC2 soap_instantiate_tt__StreamSetup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1237 */
#ifndef SOAP_TYPE_tt__Transport
#define SOAP_TYPE_tt__Transport (414)
/* Type tt__Transport is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Transport complex type: */
class SOAP_CMAC tt__Transport
{
public:
	enum tt__TransportProtocol Protocol;	/* required element of XSD type tt:TransportProtocol */
	tt__Transport *Tunnel;	/* optional element of XSD type tt:Transport */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Transport (414)
	virtual int soap_type(void) const { return 414; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Transport, default initialized and not managed by a soap context
	virtual tt__Transport *soap_alloc(void) const { return SOAP_NEW(tt__Transport); }
	         tt__Transport() { tt__Transport::soap_default(NULL); }
	virtual ~tt__Transport() { }
	friend SOAP_FMAC1 tt__Transport * SOAP_FMAC2 soap_instantiate_tt__Transport(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1240 */
#ifndef SOAP_TYPE_tt__MediaUri
#define SOAP_TYPE_tt__MediaUri (415)
/* tt:MediaUri complex type: */
class SOAP_CMAC tt__MediaUri
{
public:
	std::string Uri;	/* required element of XSD type xsd:anyURI */
	bool InvalidAfterConnect;	/* required element of XSD type xsd:boolean */
	bool InvalidAfterReboot;	/* required element of XSD type xsd:boolean */
	LONG64 Timeout;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MediaUri (415)
	virtual int soap_type(void) const { return 415; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MediaUri, default initialized and not managed by a soap context
	virtual tt__MediaUri *soap_alloc(void) const { return SOAP_NEW(tt__MediaUri); }
	         tt__MediaUri() { tt__MediaUri::soap_default(NULL); }
	virtual ~tt__MediaUri() { }
	friend SOAP_FMAC1 tt__MediaUri * SOAP_FMAC2 soap_instantiate_tt__MediaUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1243 */
#ifndef SOAP_TYPE_tt__Scope
#define SOAP_TYPE_tt__Scope (416)
/* tt:Scope complex type: */
class SOAP_CMAC tt__Scope
{
public:
	enum tt__ScopeDefinition ScopeDef;	/* required element of XSD type tt:ScopeDefinition */
	std::string ScopeItem;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Scope (416)
	virtual int soap_type(void) const { return 416; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Scope, default initialized and not managed by a soap context
	virtual tt__Scope *soap_alloc(void) const { return SOAP_NEW(tt__Scope); }
	         tt__Scope() { tt__Scope::soap_default(NULL); }
	virtual ~tt__Scope() { }
	friend SOAP_FMAC1 tt__Scope * SOAP_FMAC2 soap_instantiate_tt__Scope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1249 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension
#define SOAP_TYPE_tt__NetworkInterfaceExtension (418)
/* tt:NetworkInterfaceExtension complex type: */
class SOAP_CMAC tt__NetworkInterfaceExtension
{
public:
	int InterfaceType;	/* required element of XSD type tt:IANA-IfTypes */
	std::vector<tt__Dot3Configuration *> Dot3;	/* optional element of XSD type tt:Dot3Configuration */
	std::vector<tt__Dot11Configuration *> Dot11;	/* optional element of XSD type tt:Dot11Configuration */
	tt__NetworkInterfaceExtension2 *Extension;	/* optional element of XSD type tt:NetworkInterfaceExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceExtension (418)
	virtual int soap_type(void) const { return 418; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceExtension, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceExtension); }
	         tt__NetworkInterfaceExtension() { tt__NetworkInterfaceExtension::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceExtension() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1252 */
#ifndef SOAP_TYPE_tt__Dot3Configuration
#define SOAP_TYPE_tt__Dot3Configuration (419)
/* tt:Dot3Configuration complex type: */
class SOAP_CMAC tt__Dot3Configuration
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot3Configuration (419)
	virtual int soap_type(void) const { return 419; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot3Configuration, default initialized and not managed by a soap context
	virtual tt__Dot3Configuration *soap_alloc(void) const { return SOAP_NEW(tt__Dot3Configuration); }
	         tt__Dot3Configuration() { tt__Dot3Configuration::soap_default(NULL); }
	virtual ~tt__Dot3Configuration() { }
	friend SOAP_FMAC1 tt__Dot3Configuration * SOAP_FMAC2 soap_instantiate_tt__Dot3Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1255 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension2
#define SOAP_TYPE_tt__NetworkInterfaceExtension2 (420)
/* tt:NetworkInterfaceExtension2 complex type: */
class SOAP_CMAC tt__NetworkInterfaceExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceExtension2 (420)
	virtual int soap_type(void) const { return 420; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceExtension2, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceExtension2); }
	         tt__NetworkInterfaceExtension2() { tt__NetworkInterfaceExtension2::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceExtension2() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1258 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceLink
#define SOAP_TYPE_tt__NetworkInterfaceLink (421)
/* tt:NetworkInterfaceLink complex type: */
class SOAP_CMAC tt__NetworkInterfaceLink
{
public:
	tt__NetworkInterfaceConnectionSetting *AdminSettings;	/* required element of XSD type tt:NetworkInterfaceConnectionSetting */
	tt__NetworkInterfaceConnectionSetting *OperSettings;	/* required element of XSD type tt:NetworkInterfaceConnectionSetting */
	int InterfaceType;	/* required element of XSD type tt:IANA-IfTypes */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceLink (421)
	virtual int soap_type(void) const { return 421; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceLink, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceLink *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceLink); }
	         tt__NetworkInterfaceLink() { tt__NetworkInterfaceLink::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceLink() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceLink * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceLink(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1261 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConnectionSetting
#define SOAP_TYPE_tt__NetworkInterfaceConnectionSetting (422)
/* tt:NetworkInterfaceConnectionSetting complex type: */
class SOAP_CMAC tt__NetworkInterfaceConnectionSetting
{
public:
	bool AutoNegotiation;	/* required element of XSD type xsd:boolean */
	int Speed;	/* required element of XSD type xsd:int */
	enum tt__Duplex Duplex;	/* required element of XSD type tt:Duplex */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceConnectionSetting (422)
	virtual int soap_type(void) const { return 422; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceConnectionSetting, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceConnectionSetting *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceConnectionSetting); }
	         tt__NetworkInterfaceConnectionSetting() { tt__NetworkInterfaceConnectionSetting::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceConnectionSetting() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceConnectionSetting * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceConnectionSetting(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1264 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceInfo
#define SOAP_TYPE_tt__NetworkInterfaceInfo (423)
/* tt:NetworkInterfaceInfo complex type: */
class SOAP_CMAC tt__NetworkInterfaceInfo
{
public:
	std::string *Name;	/* optional element of XSD type xsd:string */
	std::string HwAddress;	/* required element of XSD type tt:HwAddress */
	int *MTU;	/* optional element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceInfo (423)
	virtual int soap_type(void) const { return 423; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceInfo, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceInfo *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceInfo); }
	         tt__NetworkInterfaceInfo() { tt__NetworkInterfaceInfo::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceInfo() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceInfo * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1267 */
#ifndef SOAP_TYPE_tt__IPv6NetworkInterface
#define SOAP_TYPE_tt__IPv6NetworkInterface (424)
/* tt:IPv6NetworkInterface complex type: */
class SOAP_CMAC tt__IPv6NetworkInterface
{
public:
	bool Enabled;	/* required element of XSD type xsd:boolean */
	tt__IPv6Configuration *Config;	/* optional element of XSD type tt:IPv6Configuration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6NetworkInterface (424)
	virtual int soap_type(void) const { return 424; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6NetworkInterface, default initialized and not managed by a soap context
	virtual tt__IPv6NetworkInterface *soap_alloc(void) const { return SOAP_NEW(tt__IPv6NetworkInterface); }
	         tt__IPv6NetworkInterface() { tt__IPv6NetworkInterface::soap_default(NULL); }
	virtual ~tt__IPv6NetworkInterface() { }
	friend SOAP_FMAC1 tt__IPv6NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__IPv6NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1270 */
#ifndef SOAP_TYPE_tt__IPv4NetworkInterface
#define SOAP_TYPE_tt__IPv4NetworkInterface (425)
/* tt:IPv4NetworkInterface complex type: */
class SOAP_CMAC tt__IPv4NetworkInterface
{
public:
	bool Enabled;	/* required element of XSD type xsd:boolean */
	tt__IPv4Configuration *Config;	/* required element of XSD type tt:IPv4Configuration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv4NetworkInterface (425)
	virtual int soap_type(void) const { return 425; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv4NetworkInterface, default initialized and not managed by a soap context
	virtual tt__IPv4NetworkInterface *soap_alloc(void) const { return SOAP_NEW(tt__IPv4NetworkInterface); }
	         tt__IPv4NetworkInterface() { tt__IPv4NetworkInterface::soap_default(NULL); }
	virtual ~tt__IPv4NetworkInterface() { }
	friend SOAP_FMAC1 tt__IPv4NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__IPv4NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1273 */
#ifndef SOAP_TYPE_tt__IPv4Configuration
#define SOAP_TYPE_tt__IPv4Configuration (426)
/* tt:IPv4Configuration complex type: */
class SOAP_CMAC tt__IPv4Configuration
{
public:
	std::vector<tt__PrefixedIPv4Address *> Manual;	/* optional element of XSD type tt:PrefixedIPv4Address */
	tt__PrefixedIPv4Address *LinkLocal;	/* optional element of XSD type tt:PrefixedIPv4Address */
	tt__PrefixedIPv4Address *FromDHCP;	/* optional element of XSD type tt:PrefixedIPv4Address */
	bool DHCP;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv4Configuration (426)
	virtual int soap_type(void) const { return 426; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv4Configuration, default initialized and not managed by a soap context
	virtual tt__IPv4Configuration *soap_alloc(void) const { return SOAP_NEW(tt__IPv4Configuration); }
	         tt__IPv4Configuration() { tt__IPv4Configuration::soap_default(NULL); }
	virtual ~tt__IPv4Configuration() { }
	friend SOAP_FMAC1 tt__IPv4Configuration * SOAP_FMAC2 soap_instantiate_tt__IPv4Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1276 */
#ifndef SOAP_TYPE_tt__IPv6Configuration
#define SOAP_TYPE_tt__IPv6Configuration (427)
/* tt:IPv6Configuration complex type: */
class SOAP_CMAC tt__IPv6Configuration
{
public:
	bool *AcceptRouterAdvert;	/* optional element of XSD type xsd:boolean */
	enum tt__IPv6DHCPConfiguration DHCP;	/* required element of XSD type tt:IPv6DHCPConfiguration */
	std::vector<tt__PrefixedIPv6Address *> Manual;	/* optional element of XSD type tt:PrefixedIPv6Address */
	std::vector<tt__PrefixedIPv6Address *> LinkLocal;	/* optional element of XSD type tt:PrefixedIPv6Address */
	std::vector<tt__PrefixedIPv6Address *> FromDHCP;	/* optional element of XSD type tt:PrefixedIPv6Address */
	std::vector<tt__PrefixedIPv6Address *> FromRA;	/* optional element of XSD type tt:PrefixedIPv6Address */
	tt__IPv6ConfigurationExtension *Extension;	/* optional element of XSD type tt:IPv6ConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6Configuration (427)
	virtual int soap_type(void) const { return 427; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6Configuration, default initialized and not managed by a soap context
	virtual tt__IPv6Configuration *soap_alloc(void) const { return SOAP_NEW(tt__IPv6Configuration); }
	         tt__IPv6Configuration() { tt__IPv6Configuration::soap_default(NULL); }
	virtual ~tt__IPv6Configuration() { }
	friend SOAP_FMAC1 tt__IPv6Configuration * SOAP_FMAC2 soap_instantiate_tt__IPv6Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1279 */
#ifndef SOAP_TYPE_tt__IPv6ConfigurationExtension
#define SOAP_TYPE_tt__IPv6ConfigurationExtension (428)
/* tt:IPv6ConfigurationExtension complex type: */
class SOAP_CMAC tt__IPv6ConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6ConfigurationExtension (428)
	virtual int soap_type(void) const { return 428; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6ConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__IPv6ConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__IPv6ConfigurationExtension); }
	         tt__IPv6ConfigurationExtension() { tt__IPv6ConfigurationExtension::soap_default(NULL); }
	virtual ~tt__IPv6ConfigurationExtension() { }
	friend SOAP_FMAC1 tt__IPv6ConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__IPv6ConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1282 */
#ifndef SOAP_TYPE_tt__NetworkProtocol
#define SOAP_TYPE_tt__NetworkProtocol (429)
/* tt:NetworkProtocol complex type: */
class SOAP_CMAC tt__NetworkProtocol
{
public:
	enum tt__NetworkProtocolType Name;	/* required element of XSD type tt:NetworkProtocolType */
	bool Enabled;	/* required element of XSD type xsd:boolean */
	std::vector<int> Port;	/* required element of XSD type xsd:int */
	tt__NetworkProtocolExtension *Extension;	/* optional element of XSD type tt:NetworkProtocolExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkProtocol (429)
	virtual int soap_type(void) const { return 429; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkProtocol, default initialized and not managed by a soap context
	virtual tt__NetworkProtocol *soap_alloc(void) const { return SOAP_NEW(tt__NetworkProtocol); }
	         tt__NetworkProtocol() { tt__NetworkProtocol::soap_default(NULL); }
	virtual ~tt__NetworkProtocol() { }
	friend SOAP_FMAC1 tt__NetworkProtocol * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1285 */
#ifndef SOAP_TYPE_tt__NetworkProtocolExtension
#define SOAP_TYPE_tt__NetworkProtocolExtension (430)
/* tt:NetworkProtocolExtension complex type: */
class SOAP_CMAC tt__NetworkProtocolExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkProtocolExtension (430)
	virtual int soap_type(void) const { return 430; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkProtocolExtension, default initialized and not managed by a soap context
	virtual tt__NetworkProtocolExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkProtocolExtension); }
	         tt__NetworkProtocolExtension() { tt__NetworkProtocolExtension::soap_default(NULL); }
	virtual ~tt__NetworkProtocolExtension() { }
	friend SOAP_FMAC1 tt__NetworkProtocolExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocolExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1288 */
#ifndef SOAP_TYPE_tt__NetworkHost
#define SOAP_TYPE_tt__NetworkHost (431)
/* tt:NetworkHost complex type: */
class SOAP_CMAC tt__NetworkHost
{
public:
	enum tt__NetworkHostType Type;	/* required element of XSD type tt:NetworkHostType */
	std::string *IPv4Address;	/* optional element of XSD type tt:IPv4Address */
	std::string *IPv6Address;	/* optional element of XSD type tt:IPv6Address */
	std::string *DNSname;	/* optional element of XSD type tt:DNSName */
	tt__NetworkHostExtension *Extension;	/* optional element of XSD type tt:NetworkHostExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkHost (431)
	virtual int soap_type(void) const { return 431; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkHost, default initialized and not managed by a soap context
	virtual tt__NetworkHost *soap_alloc(void) const { return SOAP_NEW(tt__NetworkHost); }
	         tt__NetworkHost() { tt__NetworkHost::soap_default(NULL); }
	virtual ~tt__NetworkHost() { }
	friend SOAP_FMAC1 tt__NetworkHost * SOAP_FMAC2 soap_instantiate_tt__NetworkHost(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1291 */
#ifndef SOAP_TYPE_tt__NetworkHostExtension
#define SOAP_TYPE_tt__NetworkHostExtension (432)
/* tt:NetworkHostExtension complex type: */
class SOAP_CMAC tt__NetworkHostExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkHostExtension (432)
	virtual int soap_type(void) const { return 432; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkHostExtension, default initialized and not managed by a soap context
	virtual tt__NetworkHostExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkHostExtension); }
	         tt__NetworkHostExtension() { tt__NetworkHostExtension::soap_default(NULL); }
	virtual ~tt__NetworkHostExtension() { }
	friend SOAP_FMAC1 tt__NetworkHostExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkHostExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1294 */
#ifndef SOAP_TYPE_tt__IPAddress
#define SOAP_TYPE_tt__IPAddress (433)
/* tt:IPAddress complex type: */
class SOAP_CMAC tt__IPAddress
{
public:
	enum tt__IPType Type;	/* required element of XSD type tt:IPType */
	std::string *IPv4Address;	/* optional element of XSD type tt:IPv4Address */
	std::string *IPv6Address;	/* optional element of XSD type tt:IPv6Address */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPAddress (433)
	virtual int soap_type(void) const { return 433; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPAddress, default initialized and not managed by a soap context
	virtual tt__IPAddress *soap_alloc(void) const { return SOAP_NEW(tt__IPAddress); }
	         tt__IPAddress() { tt__IPAddress::soap_default(NULL); }
	virtual ~tt__IPAddress() { }
	friend SOAP_FMAC1 tt__IPAddress * SOAP_FMAC2 soap_instantiate_tt__IPAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1297 */
#ifndef SOAP_TYPE_tt__PrefixedIPv4Address
#define SOAP_TYPE_tt__PrefixedIPv4Address (434)
/* tt:PrefixedIPv4Address complex type: */
class SOAP_CMAC tt__PrefixedIPv4Address
{
public:
	std::string Address;	/* required element of XSD type tt:IPv4Address */
	int PrefixLength;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PrefixedIPv4Address (434)
	virtual int soap_type(void) const { return 434; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PrefixedIPv4Address, default initialized and not managed by a soap context
	virtual tt__PrefixedIPv4Address *soap_alloc(void) const { return SOAP_NEW(tt__PrefixedIPv4Address); }
	         tt__PrefixedIPv4Address() { tt__PrefixedIPv4Address::soap_default(NULL); }
	virtual ~tt__PrefixedIPv4Address() { }
	friend SOAP_FMAC1 tt__PrefixedIPv4Address * SOAP_FMAC2 soap_instantiate_tt__PrefixedIPv4Address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1300 */
#ifndef SOAP_TYPE_tt__PrefixedIPv6Address
#define SOAP_TYPE_tt__PrefixedIPv6Address (435)
/* tt:PrefixedIPv6Address complex type: */
class SOAP_CMAC tt__PrefixedIPv6Address
{
public:
	std::string Address;	/* required element of XSD type tt:IPv6Address */
	int PrefixLength;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PrefixedIPv6Address (435)
	virtual int soap_type(void) const { return 435; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PrefixedIPv6Address, default initialized and not managed by a soap context
	virtual tt__PrefixedIPv6Address *soap_alloc(void) const { return SOAP_NEW(tt__PrefixedIPv6Address); }
	         tt__PrefixedIPv6Address() { tt__PrefixedIPv6Address::soap_default(NULL); }
	virtual ~tt__PrefixedIPv6Address() { }
	friend SOAP_FMAC1 tt__PrefixedIPv6Address * SOAP_FMAC2 soap_instantiate_tt__PrefixedIPv6Address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1303 */
#ifndef SOAP_TYPE_tt__HostnameInformation
#define SOAP_TYPE_tt__HostnameInformation (436)
/* tt:HostnameInformation complex type: */
class SOAP_CMAC tt__HostnameInformation
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	std::string *Name;	/* optional element of XSD type xsd:token */
	tt__HostnameInformationExtension *Extension;	/* optional element of XSD type tt:HostnameInformationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__HostnameInformation (436)
	virtual int soap_type(void) const { return 436; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__HostnameInformation, default initialized and not managed by a soap context
	virtual tt__HostnameInformation *soap_alloc(void) const { return SOAP_NEW(tt__HostnameInformation); }
	         tt__HostnameInformation() { tt__HostnameInformation::soap_default(NULL); }
	virtual ~tt__HostnameInformation() { }
	friend SOAP_FMAC1 tt__HostnameInformation * SOAP_FMAC2 soap_instantiate_tt__HostnameInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1306 */
#ifndef SOAP_TYPE_tt__HostnameInformationExtension
#define SOAP_TYPE_tt__HostnameInformationExtension (437)
/* tt:HostnameInformationExtension complex type: */
class SOAP_CMAC tt__HostnameInformationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__HostnameInformationExtension (437)
	virtual int soap_type(void) const { return 437; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__HostnameInformationExtension, default initialized and not managed by a soap context
	virtual tt__HostnameInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__HostnameInformationExtension); }
	         tt__HostnameInformationExtension() { tt__HostnameInformationExtension::soap_default(NULL); }
	virtual ~tt__HostnameInformationExtension() { }
	friend SOAP_FMAC1 tt__HostnameInformationExtension * SOAP_FMAC2 soap_instantiate_tt__HostnameInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1309 */
#ifndef SOAP_TYPE_tt__DNSInformation
#define SOAP_TYPE_tt__DNSInformation (438)
/* tt:DNSInformation complex type: */
class SOAP_CMAC tt__DNSInformation
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	std::vector<std::string> SearchDomain;	/* optional element of XSD type xsd:token */
	std::vector<tt__IPAddress *> DNSFromDHCP;	/* optional element of XSD type tt:IPAddress */
	std::vector<tt__IPAddress *> DNSManual;	/* optional element of XSD type tt:IPAddress */
	tt__DNSInformationExtension *Extension;	/* optional element of XSD type tt:DNSInformationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DNSInformation (438)
	virtual int soap_type(void) const { return 438; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DNSInformation, default initialized and not managed by a soap context
	virtual tt__DNSInformation *soap_alloc(void) const { return SOAP_NEW(tt__DNSInformation); }
	         tt__DNSInformation() { tt__DNSInformation::soap_default(NULL); }
	virtual ~tt__DNSInformation() { }
	friend SOAP_FMAC1 tt__DNSInformation * SOAP_FMAC2 soap_instantiate_tt__DNSInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1312 */
#ifndef SOAP_TYPE_tt__DNSInformationExtension
#define SOAP_TYPE_tt__DNSInformationExtension (439)
/* tt:DNSInformationExtension complex type: */
class SOAP_CMAC tt__DNSInformationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DNSInformationExtension (439)
	virtual int soap_type(void) const { return 439; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DNSInformationExtension, default initialized and not managed by a soap context
	virtual tt__DNSInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__DNSInformationExtension); }
	         tt__DNSInformationExtension() { tt__DNSInformationExtension::soap_default(NULL); }
	virtual ~tt__DNSInformationExtension() { }
	friend SOAP_FMAC1 tt__DNSInformationExtension * SOAP_FMAC2 soap_instantiate_tt__DNSInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1315 */
#ifndef SOAP_TYPE_tt__NTPInformation
#define SOAP_TYPE_tt__NTPInformation (440)
/* tt:NTPInformation complex type: */
class SOAP_CMAC tt__NTPInformation
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	std::vector<tt__NetworkHost *> NTPFromDHCP;	/* optional element of XSD type tt:NetworkHost */
	std::vector<tt__NetworkHost *> NTPManual;	/* optional element of XSD type tt:NetworkHost */
	tt__NTPInformationExtension *Extension;	/* optional element of XSD type tt:NTPInformationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NTPInformation (440)
	virtual int soap_type(void) const { return 440; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NTPInformation, default initialized and not managed by a soap context
	virtual tt__NTPInformation *soap_alloc(void) const { return SOAP_NEW(tt__NTPInformation); }
	         tt__NTPInformation() { tt__NTPInformation::soap_default(NULL); }
	virtual ~tt__NTPInformation() { }
	friend SOAP_FMAC1 tt__NTPInformation * SOAP_FMAC2 soap_instantiate_tt__NTPInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1318 */
#ifndef SOAP_TYPE_tt__NTPInformationExtension
#define SOAP_TYPE_tt__NTPInformationExtension (441)
/* tt:NTPInformationExtension complex type: */
class SOAP_CMAC tt__NTPInformationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NTPInformationExtension (441)
	virtual int soap_type(void) const { return 441; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NTPInformationExtension, default initialized and not managed by a soap context
	virtual tt__NTPInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__NTPInformationExtension); }
	         tt__NTPInformationExtension() { tt__NTPInformationExtension::soap_default(NULL); }
	virtual ~tt__NTPInformationExtension() { }
	friend SOAP_FMAC1 tt__NTPInformationExtension * SOAP_FMAC2 soap_instantiate_tt__NTPInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1321 */
#ifndef SOAP_TYPE_tt__DynamicDNSInformation
#define SOAP_TYPE_tt__DynamicDNSInformation (442)
/* tt:DynamicDNSInformation complex type: */
class SOAP_CMAC tt__DynamicDNSInformation
{
public:
	enum tt__DynamicDNSType Type;	/* required element of XSD type tt:DynamicDNSType */
	std::string *Name;	/* optional element of XSD type tt:DNSName */
	LONG64 *TTL;	/* optional element of XSD type xsd:duration */
	tt__DynamicDNSInformationExtension *Extension;	/* optional element of XSD type tt:DynamicDNSInformationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DynamicDNSInformation (442)
	virtual int soap_type(void) const { return 442; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DynamicDNSInformation, default initialized and not managed by a soap context
	virtual tt__DynamicDNSInformation *soap_alloc(void) const { return SOAP_NEW(tt__DynamicDNSInformation); }
	         tt__DynamicDNSInformation() { tt__DynamicDNSInformation::soap_default(NULL); }
	virtual ~tt__DynamicDNSInformation() { }
	friend SOAP_FMAC1 tt__DynamicDNSInformation * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1324 */
#ifndef SOAP_TYPE_tt__DynamicDNSInformationExtension
#define SOAP_TYPE_tt__DynamicDNSInformationExtension (443)
/* tt:DynamicDNSInformationExtension complex type: */
class SOAP_CMAC tt__DynamicDNSInformationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DynamicDNSInformationExtension (443)
	virtual int soap_type(void) const { return 443; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DynamicDNSInformationExtension, default initialized and not managed by a soap context
	virtual tt__DynamicDNSInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__DynamicDNSInformationExtension); }
	         tt__DynamicDNSInformationExtension() { tt__DynamicDNSInformationExtension::soap_default(NULL); }
	virtual ~tt__DynamicDNSInformationExtension() { }
	friend SOAP_FMAC1 tt__DynamicDNSInformationExtension * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1327 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__NetworkInterfaceSetConfiguration (444)
/* tt:NetworkInterfaceSetConfiguration complex type: */
class SOAP_CMAC tt__NetworkInterfaceSetConfiguration
{
public:
	bool *Enabled;	/* optional element of XSD type xsd:boolean */
	tt__NetworkInterfaceConnectionSetting *Link;	/* optional element of XSD type tt:NetworkInterfaceConnectionSetting */
	int *MTU;	/* optional element of XSD type xsd:int */
	tt__IPv4NetworkInterfaceSetConfiguration *IPv4;	/* optional element of XSD type tt:IPv4NetworkInterfaceSetConfiguration */
	tt__IPv6NetworkInterfaceSetConfiguration *IPv6;	/* optional element of XSD type tt:IPv6NetworkInterfaceSetConfiguration */
	tt__NetworkInterfaceSetConfigurationExtension *Extension;	/* optional element of XSD type tt:NetworkInterfaceSetConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceSetConfiguration (444)
	virtual int soap_type(void) const { return 444; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceSetConfiguration); }
	         tt__NetworkInterfaceSetConfiguration() { tt__NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfiguration() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1330 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension (445)
/* tt:NetworkInterfaceSetConfigurationExtension complex type: */
class SOAP_CMAC tt__NetworkInterfaceSetConfigurationExtension
{
public:
	std::vector<tt__Dot3Configuration *> Dot3;	/* optional element of XSD type tt:Dot3Configuration */
	std::vector<tt__Dot11Configuration *> Dot11;	/* optional element of XSD type tt:Dot11Configuration */
	tt__NetworkInterfaceSetConfigurationExtension2 *Extension;	/* optional element of XSD type tt:NetworkInterfaceSetConfigurationExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension (445)
	virtual int soap_type(void) const { return 445; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceSetConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceSetConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceSetConfigurationExtension); }
	         tt__NetworkInterfaceSetConfigurationExtension() { tt__NetworkInterfaceSetConfigurationExtension::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfigurationExtension() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1333 */
#ifndef SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration (446)
/* tt:IPv6NetworkInterfaceSetConfiguration complex type: */
class SOAP_CMAC tt__IPv6NetworkInterfaceSetConfiguration
{
public:
	bool *Enabled;	/* optional element of XSD type xsd:boolean */
	bool *AcceptRouterAdvert;	/* optional element of XSD type xsd:boolean */
	std::vector<tt__PrefixedIPv6Address *> Manual;	/* optional element of XSD type tt:PrefixedIPv6Address */
	enum tt__IPv6DHCPConfiguration *DHCP;	/* optional element of XSD type tt:IPv6DHCPConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration (446)
	virtual int soap_type(void) const { return 446; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
	virtual tt__IPv6NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__IPv6NetworkInterfaceSetConfiguration); }
	         tt__IPv6NetworkInterfaceSetConfiguration() { tt__IPv6NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__IPv6NetworkInterfaceSetConfiguration() { }
	friend SOAP_FMAC1 tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1336 */
#ifndef SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration (447)
/* tt:IPv4NetworkInterfaceSetConfiguration complex type: */
class SOAP_CMAC tt__IPv4NetworkInterfaceSetConfiguration
{
public:
	bool *Enabled;	/* optional element of XSD type xsd:boolean */
	std::vector<tt__PrefixedIPv4Address *> Manual;	/* optional element of XSD type tt:PrefixedIPv4Address */
	bool *DHCP;	/* optional element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration (447)
	virtual int soap_type(void) const { return 447; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv4NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
	virtual tt__IPv4NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__IPv4NetworkInterfaceSetConfiguration); }
	         tt__IPv4NetworkInterfaceSetConfiguration() { tt__IPv4NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__IPv4NetworkInterfaceSetConfiguration() { }
	friend SOAP_FMAC1 tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1339 */
#ifndef SOAP_TYPE_tt__NetworkGateway
#define SOAP_TYPE_tt__NetworkGateway (448)
/* tt:NetworkGateway complex type: */
class SOAP_CMAC tt__NetworkGateway
{
public:
	std::vector<std::string> IPv4Address;	/* optional element of XSD type tt:IPv4Address */
	std::vector<std::string> IPv6Address;	/* optional element of XSD type tt:IPv6Address */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkGateway (448)
	virtual int soap_type(void) const { return 448; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkGateway, default initialized and not managed by a soap context
	virtual tt__NetworkGateway *soap_alloc(void) const { return SOAP_NEW(tt__NetworkGateway); }
	         tt__NetworkGateway() { tt__NetworkGateway::soap_default(NULL); }
	virtual ~tt__NetworkGateway() { }
	friend SOAP_FMAC1 tt__NetworkGateway * SOAP_FMAC2 soap_instantiate_tt__NetworkGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1342 */
#ifndef SOAP_TYPE_tt__NetworkZeroConfiguration
#define SOAP_TYPE_tt__NetworkZeroConfiguration (449)
/* tt:NetworkZeroConfiguration complex type: */
class SOAP_CMAC tt__NetworkZeroConfiguration
{
public:
	std::string InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	bool Enabled;	/* required element of XSD type xsd:boolean */
	std::vector<std::string> Addresses;	/* optional element of XSD type tt:IPv4Address */
	tt__NetworkZeroConfigurationExtension *Extension;	/* optional element of XSD type tt:NetworkZeroConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkZeroConfiguration (449)
	virtual int soap_type(void) const { return 449; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkZeroConfiguration, default initialized and not managed by a soap context
	virtual tt__NetworkZeroConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__NetworkZeroConfiguration); }
	         tt__NetworkZeroConfiguration() { tt__NetworkZeroConfiguration::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfiguration() { }
	friend SOAP_FMAC1 tt__NetworkZeroConfiguration * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1345 */
#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension (450)
/* Type tt__NetworkZeroConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkZeroConfigurationExtension complex type: */
class SOAP_CMAC tt__NetworkZeroConfigurationExtension
{
public:
	std::vector<tt__NetworkZeroConfiguration *> Additional;	/* optional element of XSD type tt:NetworkZeroConfiguration */
	tt__NetworkZeroConfigurationExtension2 *Extension;	/* optional element of XSD type tt:NetworkZeroConfigurationExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkZeroConfigurationExtension (450)
	virtual int soap_type(void) const { return 450; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkZeroConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__NetworkZeroConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkZeroConfigurationExtension); }
	         tt__NetworkZeroConfigurationExtension() { tt__NetworkZeroConfigurationExtension::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfigurationExtension() { }
	friend SOAP_FMAC1 tt__NetworkZeroConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1348 */
#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension2
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension2 (451)
/* tt:NetworkZeroConfigurationExtension2 complex type: */
class SOAP_CMAC tt__NetworkZeroConfigurationExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkZeroConfigurationExtension2 (451)
	virtual int soap_type(void) const { return 451; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkZeroConfigurationExtension2, default initialized and not managed by a soap context
	virtual tt__NetworkZeroConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__NetworkZeroConfigurationExtension2); }
	         tt__NetworkZeroConfigurationExtension2() { tt__NetworkZeroConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfigurationExtension2() { }
	friend SOAP_FMAC1 tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1351 */
#ifndef SOAP_TYPE_tt__IPAddressFilter
#define SOAP_TYPE_tt__IPAddressFilter (452)
/* tt:IPAddressFilter complex type: */
class SOAP_CMAC tt__IPAddressFilter
{
public:
	enum tt__IPAddressFilterType Type;	/* required element of XSD type tt:IPAddressFilterType */
	std::vector<tt__PrefixedIPv4Address *> IPv4Address;	/* optional element of XSD type tt:PrefixedIPv4Address */
	std::vector<tt__PrefixedIPv6Address *> IPv6Address;	/* optional element of XSD type tt:PrefixedIPv6Address */
	tt__IPAddressFilterExtension *Extension;	/* optional element of XSD type tt:IPAddressFilterExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPAddressFilter (452)
	virtual int soap_type(void) const { return 452; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPAddressFilter, default initialized and not managed by a soap context
	virtual tt__IPAddressFilter *soap_alloc(void) const { return SOAP_NEW(tt__IPAddressFilter); }
	         tt__IPAddressFilter() { tt__IPAddressFilter::soap_default(NULL); }
	virtual ~tt__IPAddressFilter() { }
	friend SOAP_FMAC1 tt__IPAddressFilter * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1354 */
#ifndef SOAP_TYPE_tt__IPAddressFilterExtension
#define SOAP_TYPE_tt__IPAddressFilterExtension (453)
/* tt:IPAddressFilterExtension complex type: */
class SOAP_CMAC tt__IPAddressFilterExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPAddressFilterExtension (453)
	virtual int soap_type(void) const { return 453; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPAddressFilterExtension, default initialized and not managed by a soap context
	virtual tt__IPAddressFilterExtension *soap_alloc(void) const { return SOAP_NEW(tt__IPAddressFilterExtension); }
	         tt__IPAddressFilterExtension() { tt__IPAddressFilterExtension::soap_default(NULL); }
	virtual ~tt__IPAddressFilterExtension() { }
	friend SOAP_FMAC1 tt__IPAddressFilterExtension * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilterExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1357 */
#ifndef SOAP_TYPE_tt__Dot11Configuration
#define SOAP_TYPE_tt__Dot11Configuration (454)
/* tt:Dot11Configuration complex type: */
class SOAP_CMAC tt__Dot11Configuration
{
public:
	xsd__hexBinary SSID;	/* required element of XSD type tt:Dot11SSIDType */
	enum tt__Dot11StationMode Mode;	/* required element of XSD type tt:Dot11StationMode */
	std::string Alias;	/* required element of XSD type tt:Name */
	std::string Priority;	/* required element of XSD type tt:NetworkInterfaceConfigPriority */
	tt__Dot11SecurityConfiguration *Security;	/* required element of XSD type tt:Dot11SecurityConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11Configuration (454)
	virtual int soap_type(void) const { return 454; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11Configuration, default initialized and not managed by a soap context
	virtual tt__Dot11Configuration *soap_alloc(void) const { return SOAP_NEW(tt__Dot11Configuration); }
	         tt__Dot11Configuration() { tt__Dot11Configuration::soap_default(NULL); }
	virtual ~tt__Dot11Configuration() { }
	friend SOAP_FMAC1 tt__Dot11Configuration * SOAP_FMAC2 soap_instantiate_tt__Dot11Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1360 */
#ifndef SOAP_TYPE_tt__Dot11SecurityConfiguration
#define SOAP_TYPE_tt__Dot11SecurityConfiguration (455)
/* tt:Dot11SecurityConfiguration complex type: */
class SOAP_CMAC tt__Dot11SecurityConfiguration
{
public:
	enum tt__Dot11SecurityMode Mode;	/* required element of XSD type tt:Dot11SecurityMode */
	enum tt__Dot11Cipher *Algorithm;	/* optional element of XSD type tt:Dot11Cipher */
	tt__Dot11PSKSet *PSK;	/* optional element of XSD type tt:Dot11PSKSet */
	std::string *Dot1X;	/* optional element of XSD type tt:ReferenceToken */
	tt__Dot11SecurityConfigurationExtension *Extension;	/* optional element of XSD type tt:Dot11SecurityConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11SecurityConfiguration (455)
	virtual int soap_type(void) const { return 455; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11SecurityConfiguration, default initialized and not managed by a soap context
	virtual tt__Dot11SecurityConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__Dot11SecurityConfiguration); }
	         tt__Dot11SecurityConfiguration() { tt__Dot11SecurityConfiguration::soap_default(NULL); }
	virtual ~tt__Dot11SecurityConfiguration() { }
	friend SOAP_FMAC1 tt__Dot11SecurityConfiguration * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1363 */
#ifndef SOAP_TYPE_tt__Dot11SecurityConfigurationExtension
#define SOAP_TYPE_tt__Dot11SecurityConfigurationExtension (456)
/* tt:Dot11SecurityConfigurationExtension complex type: */
class SOAP_CMAC tt__Dot11SecurityConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11SecurityConfigurationExtension (456)
	virtual int soap_type(void) const { return 456; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11SecurityConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__Dot11SecurityConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__Dot11SecurityConfigurationExtension); }
	         tt__Dot11SecurityConfigurationExtension() { tt__Dot11SecurityConfigurationExtension::soap_default(NULL); }
	virtual ~tt__Dot11SecurityConfigurationExtension() { }
	friend SOAP_FMAC1 tt__Dot11SecurityConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1366 */
#ifndef SOAP_TYPE_tt__Dot11PSKSet
#define SOAP_TYPE_tt__Dot11PSKSet (457)
/* tt:Dot11PSKSet complex type: */
class SOAP_CMAC tt__Dot11PSKSet
{
public:
	xsd__hexBinary *Key;	/* optional element of XSD type tt:Dot11PSK */
	std::string *Passphrase;	/* optional element of XSD type tt:Dot11PSKPassphrase */
	tt__Dot11PSKSetExtension *Extension;	/* optional element of XSD type tt:Dot11PSKSetExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11PSKSet (457)
	virtual int soap_type(void) const { return 457; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11PSKSet, default initialized and not managed by a soap context
	virtual tt__Dot11PSKSet *soap_alloc(void) const { return SOAP_NEW(tt__Dot11PSKSet); }
	         tt__Dot11PSKSet() { tt__Dot11PSKSet::soap_default(NULL); }
	virtual ~tt__Dot11PSKSet() { }
	friend SOAP_FMAC1 tt__Dot11PSKSet * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1369 */
#ifndef SOAP_TYPE_tt__Dot11PSKSetExtension
#define SOAP_TYPE_tt__Dot11PSKSetExtension (458)
/* tt:Dot11PSKSetExtension complex type: */
class SOAP_CMAC tt__Dot11PSKSetExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11PSKSetExtension (458)
	virtual int soap_type(void) const { return 458; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11PSKSetExtension, default initialized and not managed by a soap context
	virtual tt__Dot11PSKSetExtension *soap_alloc(void) const { return SOAP_NEW(tt__Dot11PSKSetExtension); }
	         tt__Dot11PSKSetExtension() { tt__Dot11PSKSetExtension::soap_default(NULL); }
	virtual ~tt__Dot11PSKSetExtension() { }
	friend SOAP_FMAC1 tt__Dot11PSKSetExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKSetExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1372 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2 (459)
/* tt:NetworkInterfaceSetConfigurationExtension2 complex type: */
class SOAP_CMAC tt__NetworkInterfaceSetConfigurationExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2 (459)
	virtual int soap_type(void) const { return 459; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceSetConfigurationExtension2, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceSetConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceSetConfigurationExtension2); }
	         tt__NetworkInterfaceSetConfigurationExtension2() { tt__NetworkInterfaceSetConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfigurationExtension2() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1375 */
#ifndef SOAP_TYPE_tt__Dot11Capabilities
#define SOAP_TYPE_tt__Dot11Capabilities (460)
/* tt:Dot11Capabilities complex type: */
class SOAP_CMAC tt__Dot11Capabilities
{
public:
	bool TKIP;	/* required element of XSD type xsd:boolean */
	bool ScanAvailableNetworks;	/* required element of XSD type xsd:boolean */
	bool MultipleConfiguration;	/* required element of XSD type xsd:boolean */
	bool AdHocStationMode;	/* required element of XSD type xsd:boolean */
	bool WEP;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11Capabilities (460)
	virtual int soap_type(void) const { return 460; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11Capabilities, default initialized and not managed by a soap context
	virtual tt__Dot11Capabilities *soap_alloc(void) const { return SOAP_NEW(tt__Dot11Capabilities); }
	         tt__Dot11Capabilities() { tt__Dot11Capabilities::soap_default(NULL); }
	virtual ~tt__Dot11Capabilities() { }
	friend SOAP_FMAC1 tt__Dot11Capabilities * SOAP_FMAC2 soap_instantiate_tt__Dot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1378 */
#ifndef SOAP_TYPE_tt__Dot11Status
#define SOAP_TYPE_tt__Dot11Status (461)
/* tt:Dot11Status complex type: */
class SOAP_CMAC tt__Dot11Status
{
public:
	xsd__hexBinary SSID;	/* required element of XSD type tt:Dot11SSIDType */
	std::string *BSSID;	/* optional element of XSD type xsd:string */
	enum tt__Dot11Cipher *PairCipher;	/* optional element of XSD type tt:Dot11Cipher */
	enum tt__Dot11Cipher *GroupCipher;	/* optional element of XSD type tt:Dot11Cipher */
	enum tt__Dot11SignalStrength *SignalStrength;	/* optional element of XSD type tt:Dot11SignalStrength */
	std::string ActiveConfigAlias;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11Status (461)
	virtual int soap_type(void) const { return 461; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11Status, default initialized and not managed by a soap context
	virtual tt__Dot11Status *soap_alloc(void) const { return SOAP_NEW(tt__Dot11Status); }
	         tt__Dot11Status() { tt__Dot11Status::soap_default(NULL); }
	virtual ~tt__Dot11Status() { }
	friend SOAP_FMAC1 tt__Dot11Status * SOAP_FMAC2 soap_instantiate_tt__Dot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1381 */
#ifndef SOAP_TYPE_tt__Dot11AvailableNetworks
#define SOAP_TYPE_tt__Dot11AvailableNetworks (462)
/* tt:Dot11AvailableNetworks complex type: */
class SOAP_CMAC tt__Dot11AvailableNetworks
{
public:
	xsd__hexBinary SSID;	/* required element of XSD type tt:Dot11SSIDType */
	std::string *BSSID;	/* optional element of XSD type xsd:string */
	std::vector<enum tt__Dot11AuthAndMangementSuite> AuthAndMangementSuite;	/* optional element of XSD type tt:Dot11AuthAndMangementSuite */
	std::vector<enum tt__Dot11Cipher> PairCipher;	/* optional element of XSD type tt:Dot11Cipher */
	std::vector<enum tt__Dot11Cipher> GroupCipher;	/* optional element of XSD type tt:Dot11Cipher */
	enum tt__Dot11SignalStrength *SignalStrength;	/* optional element of XSD type tt:Dot11SignalStrength */
	tt__Dot11AvailableNetworksExtension *Extension;	/* optional element of XSD type tt:Dot11AvailableNetworksExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11AvailableNetworks (462)
	virtual int soap_type(void) const { return 462; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11AvailableNetworks, default initialized and not managed by a soap context
	virtual tt__Dot11AvailableNetworks *soap_alloc(void) const { return SOAP_NEW(tt__Dot11AvailableNetworks); }
	         tt__Dot11AvailableNetworks() { tt__Dot11AvailableNetworks::soap_default(NULL); }
	virtual ~tt__Dot11AvailableNetworks() { }
	friend SOAP_FMAC1 tt__Dot11AvailableNetworks * SOAP_FMAC2 soap_instantiate_tt__Dot11AvailableNetworks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1384 */
#ifndef SOAP_TYPE_tt__Dot11AvailableNetworksExtension
#define SOAP_TYPE_tt__Dot11AvailableNetworksExtension (463)
/* tt:Dot11AvailableNetworksExtension complex type: */
class SOAP_CMAC tt__Dot11AvailableNetworksExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11AvailableNetworksExtension (463)
	virtual int soap_type(void) const { return 463; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11AvailableNetworksExtension, default initialized and not managed by a soap context
	virtual tt__Dot11AvailableNetworksExtension *soap_alloc(void) const { return SOAP_NEW(tt__Dot11AvailableNetworksExtension); }
	         tt__Dot11AvailableNetworksExtension() { tt__Dot11AvailableNetworksExtension::soap_default(NULL); }
	virtual ~tt__Dot11AvailableNetworksExtension() { }
	friend SOAP_FMAC1 tt__Dot11AvailableNetworksExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11AvailableNetworksExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1387 */
#ifndef SOAP_TYPE_tt__Capabilities
#define SOAP_TYPE_tt__Capabilities (464)
/* tt:Capabilities complex type: */
class SOAP_CMAC tt__Capabilities
{
public:
	tt__AnalyticsCapabilities *Analytics;	/* optional element of XSD type tt:AnalyticsCapabilities */
	tt__DeviceCapabilities *Device;	/* optional element of XSD type tt:DeviceCapabilities */
	tt__EventCapabilities *Events;	/* optional element of XSD type tt:EventCapabilities */
	tt__ImagingCapabilities *Imaging;	/* optional element of XSD type tt:ImagingCapabilities */
	tt__MediaCapabilities *Media;	/* optional element of XSD type tt:MediaCapabilities */
	tt__PTZCapabilities *PTZ;	/* optional element of XSD type tt:PTZCapabilities */
	tt__CapabilitiesExtension *Extension;	/* optional element of XSD type tt:CapabilitiesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Capabilities (464)
	virtual int soap_type(void) const { return 464; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Capabilities, default initialized and not managed by a soap context
	virtual tt__Capabilities *soap_alloc(void) const { return SOAP_NEW(tt__Capabilities); }
	         tt__Capabilities() { tt__Capabilities::soap_default(NULL); }
	virtual ~tt__Capabilities() { }
	friend SOAP_FMAC1 tt__Capabilities * SOAP_FMAC2 soap_instantiate_tt__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1390 */
#ifndef SOAP_TYPE_tt__CapabilitiesExtension
#define SOAP_TYPE_tt__CapabilitiesExtension (465)
/* tt:CapabilitiesExtension complex type: */
class SOAP_CMAC tt__CapabilitiesExtension
{
public:
	tt__DeviceIOCapabilities *DeviceIO;	/* optional element of XSD type tt:DeviceIOCapabilities */
	tt__DisplayCapabilities *Display;	/* optional element of XSD type tt:DisplayCapabilities */
	tt__RecordingCapabilities *Recording;	/* optional element of XSD type tt:RecordingCapabilities */
	tt__SearchCapabilities *Search;	/* optional element of XSD type tt:SearchCapabilities */
	tt__ReplayCapabilities *Replay;	/* optional element of XSD type tt:ReplayCapabilities */
	tt__ReceiverCapabilities *Receiver;	/* optional element of XSD type tt:ReceiverCapabilities */
	tt__AnalyticsDeviceCapabilities *AnalyticsDevice;	/* optional element of XSD type tt:AnalyticsDeviceCapabilities */
	tt__CapabilitiesExtension2 *Extensions;	/* optional element of XSD type tt:CapabilitiesExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CapabilitiesExtension (465)
	virtual int soap_type(void) const { return 465; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__CapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__CapabilitiesExtension); }
	         tt__CapabilitiesExtension() { tt__CapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__CapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__CapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__CapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1393 */
#ifndef SOAP_TYPE_tt__CapabilitiesExtension2
#define SOAP_TYPE_tt__CapabilitiesExtension2 (466)
/* tt:CapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__CapabilitiesExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CapabilitiesExtension2 (466)
	virtual int soap_type(void) const { return 466; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__CapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__CapabilitiesExtension2); }
	         tt__CapabilitiesExtension2() { tt__CapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__CapabilitiesExtension2() { }
	friend SOAP_FMAC1 tt__CapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__CapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1396 */
#ifndef SOAP_TYPE_tt__AnalyticsCapabilities
#define SOAP_TYPE_tt__AnalyticsCapabilities (467)
/* tt:AnalyticsCapabilities complex type: */
class SOAP_CMAC tt__AnalyticsCapabilities
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	bool RuleSupport;	/* required element of XSD type xsd:boolean */
	bool AnalyticsModuleSupport;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsCapabilities (467)
	virtual int soap_type(void) const { return 467; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsCapabilities, default initialized and not managed by a soap context
	virtual tt__AnalyticsCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsCapabilities); }
	         tt__AnalyticsCapabilities() { tt__AnalyticsCapabilities::soap_default(NULL); }
	virtual ~tt__AnalyticsCapabilities() { }
	friend SOAP_FMAC1 tt__AnalyticsCapabilities * SOAP_FMAC2 soap_instantiate_tt__AnalyticsCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1399 */
#ifndef SOAP_TYPE_tt__DeviceCapabilities
#define SOAP_TYPE_tt__DeviceCapabilities (468)
/* tt:DeviceCapabilities complex type: */
class SOAP_CMAC tt__DeviceCapabilities
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	tt__NetworkCapabilities *Network;	/* optional element of XSD type tt:NetworkCapabilities */
	tt__SystemCapabilities *System;	/* optional element of XSD type tt:SystemCapabilities */
	tt__IOCapabilities *IO;	/* optional element of XSD type tt:IOCapabilities */
	tt__SecurityCapabilities *Security;	/* optional element of XSD type tt:SecurityCapabilities */
	tt__DeviceCapabilitiesExtension *Extension;	/* optional element of XSD type tt:DeviceCapabilitiesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DeviceCapabilities (468)
	virtual int soap_type(void) const { return 468; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DeviceCapabilities, default initialized and not managed by a soap context
	virtual tt__DeviceCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__DeviceCapabilities); }
	         tt__DeviceCapabilities() { tt__DeviceCapabilities::soap_default(NULL); }
	virtual ~tt__DeviceCapabilities() { }
	friend SOAP_FMAC1 tt__DeviceCapabilities * SOAP_FMAC2 soap_instantiate_tt__DeviceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1402 */
#ifndef SOAP_TYPE_tt__DeviceCapabilitiesExtension
#define SOAP_TYPE_tt__DeviceCapabilitiesExtension (469)
/* tt:DeviceCapabilitiesExtension complex type: */
class SOAP_CMAC tt__DeviceCapabilitiesExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DeviceCapabilitiesExtension (469)
	virtual int soap_type(void) const { return 469; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DeviceCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__DeviceCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__DeviceCapabilitiesExtension); }
	         tt__DeviceCapabilitiesExtension() { tt__DeviceCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__DeviceCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__DeviceCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__DeviceCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1405 */
#ifndef SOAP_TYPE_tt__EventCapabilities
#define SOAP_TYPE_tt__EventCapabilities (470)
/* tt:EventCapabilities complex type: */
class SOAP_CMAC tt__EventCapabilities
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	bool WSSubscriptionPolicySupport;	/* required element of XSD type xsd:boolean */
	bool WSPullPointSupport;	/* required element of XSD type xsd:boolean */
	bool WSPausableSubscriptionManagerInterfaceSupport;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EventCapabilities (470)
	virtual int soap_type(void) const { return 470; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EventCapabilities, default initialized and not managed by a soap context
	virtual tt__EventCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__EventCapabilities); }
	         tt__EventCapabilities() { tt__EventCapabilities::soap_default(NULL); }
	virtual ~tt__EventCapabilities() { }
	friend SOAP_FMAC1 tt__EventCapabilities * SOAP_FMAC2 soap_instantiate_tt__EventCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1408 */
#ifndef SOAP_TYPE_tt__IOCapabilities
#define SOAP_TYPE_tt__IOCapabilities (471)
/* tt:IOCapabilities complex type: */
class SOAP_CMAC tt__IOCapabilities
{
public:
	int *InputConnectors;	/* optional element of XSD type xsd:int */
	int *RelayOutputs;	/* optional element of XSD type xsd:int */
	tt__IOCapabilitiesExtension *Extension;	/* optional element of XSD type tt:IOCapabilitiesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IOCapabilities (471)
	virtual int soap_type(void) const { return 471; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IOCapabilities, default initialized and not managed by a soap context
	virtual tt__IOCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__IOCapabilities); }
	         tt__IOCapabilities() { tt__IOCapabilities::soap_default(NULL); }
	virtual ~tt__IOCapabilities() { }
	friend SOAP_FMAC1 tt__IOCapabilities * SOAP_FMAC2 soap_instantiate_tt__IOCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1411 */
#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension
#define SOAP_TYPE_tt__IOCapabilitiesExtension (472)
/* tt:IOCapabilitiesExtension complex type: */
class SOAP_CMAC tt__IOCapabilitiesExtension
{
public:
	bool *Auxiliary;	/* optional element of XSD type xsd:boolean */
	std::vector<std::string> AuxiliaryCommands;	/* optional element of XSD type tt:AuxiliaryData */
	tt__IOCapabilitiesExtension2 *Extension;	/* required element of XSD type tt:IOCapabilitiesExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IOCapabilitiesExtension (472)
	virtual int soap_type(void) const { return 472; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IOCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__IOCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__IOCapabilitiesExtension); }
	         tt__IOCapabilitiesExtension() { tt__IOCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__IOCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__IOCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__IOCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1414 */
#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension2
#define SOAP_TYPE_tt__IOCapabilitiesExtension2 (473)
/* tt:IOCapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__IOCapabilitiesExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IOCapabilitiesExtension2 (473)
	virtual int soap_type(void) const { return 473; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IOCapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__IOCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__IOCapabilitiesExtension2); }
	         tt__IOCapabilitiesExtension2() { tt__IOCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__IOCapabilitiesExtension2() { }
	friend SOAP_FMAC1 tt__IOCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__IOCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1417 */
#ifndef SOAP_TYPE_tt__MediaCapabilities
#define SOAP_TYPE_tt__MediaCapabilities (474)
/* tt:MediaCapabilities complex type: */
class SOAP_CMAC tt__MediaCapabilities
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	tt__RealTimeStreamingCapabilities *StreamingCapabilities;	/* required element of XSD type tt:RealTimeStreamingCapabilities */
	tt__MediaCapabilitiesExtension *Extension;	/* optional element of XSD type tt:MediaCapabilitiesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MediaCapabilities (474)
	virtual int soap_type(void) const { return 474; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MediaCapabilities, default initialized and not managed by a soap context
	virtual tt__MediaCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__MediaCapabilities); }
	         tt__MediaCapabilities() { tt__MediaCapabilities::soap_default(NULL); }
	virtual ~tt__MediaCapabilities() { }
	friend SOAP_FMAC1 tt__MediaCapabilities * SOAP_FMAC2 soap_instantiate_tt__MediaCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1420 */
#ifndef SOAP_TYPE_tt__MediaCapabilitiesExtension
#define SOAP_TYPE_tt__MediaCapabilitiesExtension (475)
/* tt:MediaCapabilitiesExtension complex type: */
class SOAP_CMAC tt__MediaCapabilitiesExtension
{
public:
	tt__ProfileCapabilities *ProfileCapabilities;	/* required element of XSD type tt:ProfileCapabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MediaCapabilitiesExtension (475)
	virtual int soap_type(void) const { return 475; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MediaCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__MediaCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__MediaCapabilitiesExtension); }
	         tt__MediaCapabilitiesExtension() { tt__MediaCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__MediaCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__MediaCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__MediaCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1423 */
#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilities
#define SOAP_TYPE_tt__RealTimeStreamingCapabilities (476)
/* tt:RealTimeStreamingCapabilities complex type: */
class SOAP_CMAC tt__RealTimeStreamingCapabilities
{
public:
	bool *RTPMulticast;	/* optional element of XSD type xsd:boolean */
	bool *RTP_USCORETCP;	/* optional element of XSD type xsd:boolean */
	bool *RTP_USCORERTSP_USCORETCP;	/* optional element of XSD type xsd:boolean */
	tt__RealTimeStreamingCapabilitiesExtension *Extension;	/* optional element of XSD type tt:RealTimeStreamingCapabilitiesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RealTimeStreamingCapabilities (476)
	virtual int soap_type(void) const { return 476; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RealTimeStreamingCapabilities, default initialized and not managed by a soap context
	virtual tt__RealTimeStreamingCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__RealTimeStreamingCapabilities); }
	         tt__RealTimeStreamingCapabilities() { tt__RealTimeStreamingCapabilities::soap_default(NULL); }
	virtual ~tt__RealTimeStreamingCapabilities() { }
	friend SOAP_FMAC1 tt__RealTimeStreamingCapabilities * SOAP_FMAC2 soap_instantiate_tt__RealTimeStreamingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1426 */
#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension
#define SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension (477)
/* tt:RealTimeStreamingCapabilitiesExtension complex type: */
class SOAP_CMAC tt__RealTimeStreamingCapabilitiesExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension (477)
	virtual int soap_type(void) const { return 477; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RealTimeStreamingCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__RealTimeStreamingCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__RealTimeStreamingCapabilitiesExtension); }
	         tt__RealTimeStreamingCapabilitiesExtension() { tt__RealTimeStreamingCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__RealTimeStreamingCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1429 */
#ifndef SOAP_TYPE_tt__ProfileCapabilities
#define SOAP_TYPE_tt__ProfileCapabilities (478)
/* tt:ProfileCapabilities complex type: */
class SOAP_CMAC tt__ProfileCapabilities
{
public:
	int MaximumNumberOfProfiles;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ProfileCapabilities (478)
	virtual int soap_type(void) const { return 478; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ProfileCapabilities, default initialized and not managed by a soap context
	virtual tt__ProfileCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__ProfileCapabilities); }
	         tt__ProfileCapabilities() { tt__ProfileCapabilities::soap_default(NULL); }
	virtual ~tt__ProfileCapabilities() { }
	friend SOAP_FMAC1 tt__ProfileCapabilities * SOAP_FMAC2 soap_instantiate_tt__ProfileCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1432 */
#ifndef SOAP_TYPE_tt__NetworkCapabilities
#define SOAP_TYPE_tt__NetworkCapabilities (479)
/* tt:NetworkCapabilities complex type: */
class SOAP_CMAC tt__NetworkCapabilities
{
public:
	bool *IPFilter;	/* optional element of XSD type xsd:boolean */
	bool *ZeroConfiguration;	/* optional element of XSD type xsd:boolean */
	bool *IPVersion6;	/* optional element of XSD type xsd:boolean */
	bool *DynDNS;	/* optional element of XSD type xsd:boolean */
	tt__NetworkCapabilitiesExtension *Extension;	/* optional element of XSD type tt:NetworkCapabilitiesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkCapabilities (479)
	virtual int soap_type(void) const { return 479; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkCapabilities, default initialized and not managed by a soap context
	virtual tt__NetworkCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__NetworkCapabilities); }
	         tt__NetworkCapabilities() { tt__NetworkCapabilities::soap_default(NULL); }
	virtual ~tt__NetworkCapabilities() { }
	friend SOAP_FMAC1 tt__NetworkCapabilities * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1435 */
#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension (480)
/* tt:NetworkCapabilitiesExtension complex type: */
class SOAP_CMAC tt__NetworkCapabilitiesExtension
{
public:
	bool *Dot11Configuration;	/* optional element of XSD type xsd:boolean */
	tt__NetworkCapabilitiesExtension2 *Extension;	/* optional element of XSD type tt:NetworkCapabilitiesExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkCapabilitiesExtension (480)
	virtual int soap_type(void) const { return 480; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__NetworkCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkCapabilitiesExtension); }
	         tt__NetworkCapabilitiesExtension() { tt__NetworkCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__NetworkCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__NetworkCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1438 */
#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension2
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension2 (481)
/* tt:NetworkCapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__NetworkCapabilitiesExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkCapabilitiesExtension2 (481)
	virtual int soap_type(void) const { return 481; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkCapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__NetworkCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__NetworkCapabilitiesExtension2); }
	         tt__NetworkCapabilitiesExtension2() { tt__NetworkCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__NetworkCapabilitiesExtension2() { }
	friend SOAP_FMAC1 tt__NetworkCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1441 */
#ifndef SOAP_TYPE_tt__SecurityCapabilities
#define SOAP_TYPE_tt__SecurityCapabilities (482)
/* tt:SecurityCapabilities complex type: */
class SOAP_CMAC tt__SecurityCapabilities
{
public:
	bool TLS1_x002e1;	/* required element of XSD type xsd:boolean */
	bool TLS1_x002e2;	/* required element of XSD type xsd:boolean */
	bool OnboardKeyGeneration;	/* required element of XSD type xsd:boolean */
	bool AccessPolicyConfig;	/* required element of XSD type xsd:boolean */
	bool X_x002e509Token;	/* required element of XSD type xsd:boolean */
	bool SAMLToken;	/* required element of XSD type xsd:boolean */
	bool KerberosToken;	/* required element of XSD type xsd:boolean */
	bool RELToken;	/* required element of XSD type xsd:boolean */
	tt__SecurityCapabilitiesExtension *Extension;	/* optional element of XSD type tt:SecurityCapabilitiesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SecurityCapabilities (482)
	virtual int soap_type(void) const { return 482; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SecurityCapabilities, default initialized and not managed by a soap context
	virtual tt__SecurityCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__SecurityCapabilities); }
	         tt__SecurityCapabilities() { tt__SecurityCapabilities::soap_default(NULL); }
	virtual ~tt__SecurityCapabilities() { }
	friend SOAP_FMAC1 tt__SecurityCapabilities * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1444 */
#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension (483)
/* tt:SecurityCapabilitiesExtension complex type: */
class SOAP_CMAC tt__SecurityCapabilitiesExtension
{
public:
	bool TLS1_x002e0;	/* required element of XSD type xsd:boolean */
	tt__SecurityCapabilitiesExtension2 *Extension;	/* optional element of XSD type tt:SecurityCapabilitiesExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SecurityCapabilitiesExtension (483)
	virtual int soap_type(void) const { return 483; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SecurityCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__SecurityCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__SecurityCapabilitiesExtension); }
	         tt__SecurityCapabilitiesExtension() { tt__SecurityCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__SecurityCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__SecurityCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1447 */
#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension2
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension2 (484)
/* tt:SecurityCapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__SecurityCapabilitiesExtension2
{
public:
	bool Dot1X;	/* required element of XSD type xsd:boolean */
	std::vector<int> SupportedEAPMethod;	/* optional element of XSD type xsd:int */
	bool RemoteUserHandling;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SecurityCapabilitiesExtension2 (484)
	virtual int soap_type(void) const { return 484; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SecurityCapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__SecurityCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__SecurityCapabilitiesExtension2); }
	         tt__SecurityCapabilitiesExtension2() { tt__SecurityCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__SecurityCapabilitiesExtension2() { }
	friend SOAP_FMAC1 tt__SecurityCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1450 */
#ifndef SOAP_TYPE_tt__SystemCapabilities
#define SOAP_TYPE_tt__SystemCapabilities (485)
/* tt:SystemCapabilities complex type: */
class SOAP_CMAC tt__SystemCapabilities
{
public:
	bool DiscoveryResolve;	/* required element of XSD type xsd:boolean */
	bool DiscoveryBye;	/* required element of XSD type xsd:boolean */
	bool RemoteDiscovery;	/* required element of XSD type xsd:boolean */
	bool SystemBackup;	/* required element of XSD type xsd:boolean */
	bool SystemLogging;	/* required element of XSD type xsd:boolean */
	bool FirmwareUpgrade;	/* required element of XSD type xsd:boolean */
	std::vector<tt__OnvifVersion *> SupportedVersions;	/* required element of XSD type tt:OnvifVersion */
	tt__SystemCapabilitiesExtension *Extension;	/* optional element of XSD type tt:SystemCapabilitiesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemCapabilities (485)
	virtual int soap_type(void) const { return 485; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemCapabilities, default initialized and not managed by a soap context
	virtual tt__SystemCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__SystemCapabilities); }
	         tt__SystemCapabilities() { tt__SystemCapabilities::soap_default(NULL); }
	virtual ~tt__SystemCapabilities() { }
	friend SOAP_FMAC1 tt__SystemCapabilities * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1453 */
#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension
#define SOAP_TYPE_tt__SystemCapabilitiesExtension (486)
/* tt:SystemCapabilitiesExtension complex type: */
class SOAP_CMAC tt__SystemCapabilitiesExtension
{
public:
	bool *HttpFirmwareUpgrade;	/* optional element of XSD type xsd:boolean */
	bool *HttpSystemBackup;	/* optional element of XSD type xsd:boolean */
	bool *HttpSystemLogging;	/* optional element of XSD type xsd:boolean */
	bool *HttpSupportInformation;	/* optional element of XSD type xsd:boolean */
	tt__SystemCapabilitiesExtension2 *Extension;	/* optional element of XSD type tt:SystemCapabilitiesExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemCapabilitiesExtension (486)
	virtual int soap_type(void) const { return 486; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__SystemCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__SystemCapabilitiesExtension); }
	         tt__SystemCapabilitiesExtension() { tt__SystemCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__SystemCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__SystemCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1456 */
#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension2
#define SOAP_TYPE_tt__SystemCapabilitiesExtension2 (487)
/* tt:SystemCapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__SystemCapabilitiesExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemCapabilitiesExtension2 (487)
	virtual int soap_type(void) const { return 487; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemCapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__SystemCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__SystemCapabilitiesExtension2); }
	         tt__SystemCapabilitiesExtension2() { tt__SystemCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__SystemCapabilitiesExtension2() { }
	friend SOAP_FMAC1 tt__SystemCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1459 */
#ifndef SOAP_TYPE_tt__OnvifVersion
#define SOAP_TYPE_tt__OnvifVersion (488)
/* tt:OnvifVersion complex type: */
class SOAP_CMAC tt__OnvifVersion
{
public:
	int Major;	/* required element of XSD type xsd:int */
	int Minor;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OnvifVersion (488)
	virtual int soap_type(void) const { return 488; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OnvifVersion, default initialized and not managed by a soap context
	virtual tt__OnvifVersion *soap_alloc(void) const { return SOAP_NEW(tt__OnvifVersion); }
	         tt__OnvifVersion() { tt__OnvifVersion::soap_default(NULL); }
	virtual ~tt__OnvifVersion() { }
	friend SOAP_FMAC1 tt__OnvifVersion * SOAP_FMAC2 soap_instantiate_tt__OnvifVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1462 */
#ifndef SOAP_TYPE_tt__ImagingCapabilities
#define SOAP_TYPE_tt__ImagingCapabilities (489)
/* tt:ImagingCapabilities complex type: */
class SOAP_CMAC tt__ImagingCapabilities
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingCapabilities (489)
	virtual int soap_type(void) const { return 489; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingCapabilities, default initialized and not managed by a soap context
	virtual tt__ImagingCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__ImagingCapabilities); }
	         tt__ImagingCapabilities() { tt__ImagingCapabilities::soap_default(NULL); }
	virtual ~tt__ImagingCapabilities() { }
	friend SOAP_FMAC1 tt__ImagingCapabilities * SOAP_FMAC2 soap_instantiate_tt__ImagingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1465 */
#ifndef SOAP_TYPE_tt__PTZCapabilities
#define SOAP_TYPE_tt__PTZCapabilities (490)
/* tt:PTZCapabilities complex type: */
class SOAP_CMAC tt__PTZCapabilities
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZCapabilities (490)
	virtual int soap_type(void) const { return 490; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZCapabilities, default initialized and not managed by a soap context
	virtual tt__PTZCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__PTZCapabilities); }
	         tt__PTZCapabilities() { tt__PTZCapabilities::soap_default(NULL); }
	virtual ~tt__PTZCapabilities() { }
	friend SOAP_FMAC1 tt__PTZCapabilities * SOAP_FMAC2 soap_instantiate_tt__PTZCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1468 */
#ifndef SOAP_TYPE_tt__DeviceIOCapabilities
#define SOAP_TYPE_tt__DeviceIOCapabilities (491)
/* tt:DeviceIOCapabilities complex type: */
class SOAP_CMAC tt__DeviceIOCapabilities
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	int VideoSources;	/* required element of XSD type xsd:int */
	int VideoOutputs;	/* required element of XSD type xsd:int */
	int AudioSources;	/* required element of XSD type xsd:int */
	int AudioOutputs;	/* required element of XSD type xsd:int */
	int RelayOutputs;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DeviceIOCapabilities (491)
	virtual int soap_type(void) const { return 491; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DeviceIOCapabilities, default initialized and not managed by a soap context
	virtual tt__DeviceIOCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__DeviceIOCapabilities); }
	         tt__DeviceIOCapabilities() { tt__DeviceIOCapabilities::soap_default(NULL); }
	virtual ~tt__DeviceIOCapabilities() { }
	friend SOAP_FMAC1 tt__DeviceIOCapabilities * SOAP_FMAC2 soap_instantiate_tt__DeviceIOCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1471 */
#ifndef SOAP_TYPE_tt__DisplayCapabilities
#define SOAP_TYPE_tt__DisplayCapabilities (492)
/* tt:DisplayCapabilities complex type: */
class SOAP_CMAC tt__DisplayCapabilities
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	bool FixedLayout;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DisplayCapabilities (492)
	virtual int soap_type(void) const { return 492; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DisplayCapabilities, default initialized and not managed by a soap context
	virtual tt__DisplayCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__DisplayCapabilities); }
	         tt__DisplayCapabilities() { tt__DisplayCapabilities::soap_default(NULL); }
	virtual ~tt__DisplayCapabilities() { }
	friend SOAP_FMAC1 tt__DisplayCapabilities * SOAP_FMAC2 soap_instantiate_tt__DisplayCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1474 */
#ifndef SOAP_TYPE_tt__RecordingCapabilities
#define SOAP_TYPE_tt__RecordingCapabilities (493)
/* tt:RecordingCapabilities complex type: */
class SOAP_CMAC tt__RecordingCapabilities
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	bool ReceiverSource;	/* required element of XSD type xsd:boolean */
	bool MediaProfileSource;	/* required element of XSD type xsd:boolean */
	bool DynamicRecordings;	/* required element of XSD type xsd:boolean */
	bool DynamicTracks;	/* required element of XSD type xsd:boolean */
	int MaxStringLength;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingCapabilities (493)
	virtual int soap_type(void) const { return 493; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingCapabilities, default initialized and not managed by a soap context
	virtual tt__RecordingCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__RecordingCapabilities); }
	         tt__RecordingCapabilities() { tt__RecordingCapabilities::soap_default(NULL); }
	virtual ~tt__RecordingCapabilities() { }
	friend SOAP_FMAC1 tt__RecordingCapabilities * SOAP_FMAC2 soap_instantiate_tt__RecordingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1477 */
#ifndef SOAP_TYPE_tt__SearchCapabilities
#define SOAP_TYPE_tt__SearchCapabilities (494)
/* tt:SearchCapabilities complex type: */
class SOAP_CMAC tt__SearchCapabilities
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	bool MetadataSearch;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SearchCapabilities (494)
	virtual int soap_type(void) const { return 494; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SearchCapabilities, default initialized and not managed by a soap context
	virtual tt__SearchCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__SearchCapabilities); }
	         tt__SearchCapabilities() { tt__SearchCapabilities::soap_default(NULL); }
	virtual ~tt__SearchCapabilities() { }
	friend SOAP_FMAC1 tt__SearchCapabilities * SOAP_FMAC2 soap_instantiate_tt__SearchCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1480 */
#ifndef SOAP_TYPE_tt__ReplayCapabilities
#define SOAP_TYPE_tt__ReplayCapabilities (495)
/* tt:ReplayCapabilities complex type: */
class SOAP_CMAC tt__ReplayCapabilities
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReplayCapabilities (495)
	virtual int soap_type(void) const { return 495; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReplayCapabilities, default initialized and not managed by a soap context
	virtual tt__ReplayCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__ReplayCapabilities); }
	         tt__ReplayCapabilities() { tt__ReplayCapabilities::soap_default(NULL); }
	virtual ~tt__ReplayCapabilities() { }
	friend SOAP_FMAC1 tt__ReplayCapabilities * SOAP_FMAC2 soap_instantiate_tt__ReplayCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1483 */
#ifndef SOAP_TYPE_tt__ReceiverCapabilities
#define SOAP_TYPE_tt__ReceiverCapabilities (496)
/* tt:ReceiverCapabilities complex type: */
class SOAP_CMAC tt__ReceiverCapabilities
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	bool RTP_USCOREMulticast;	/* required element of XSD type xsd:boolean */
	bool RTP_USCORETCP;	/* required element of XSD type xsd:boolean */
	bool RTP_USCORERTSP_USCORETCP;	/* required element of XSD type xsd:boolean */
	int SupportedReceivers;	/* required element of XSD type xsd:int */
	int MaximumRTSPURILength;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReceiverCapabilities (496)
	virtual int soap_type(void) const { return 496; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReceiverCapabilities, default initialized and not managed by a soap context
	virtual tt__ReceiverCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__ReceiverCapabilities); }
	         tt__ReceiverCapabilities() { tt__ReceiverCapabilities::soap_default(NULL); }
	virtual ~tt__ReceiverCapabilities() { }
	friend SOAP_FMAC1 tt__ReceiverCapabilities * SOAP_FMAC2 soap_instantiate_tt__ReceiverCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1486 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceCapabilities
#define SOAP_TYPE_tt__AnalyticsDeviceCapabilities (497)
/* tt:AnalyticsDeviceCapabilities complex type: */
class SOAP_CMAC tt__AnalyticsDeviceCapabilities
{
public:
	std::string XAddr;	/* required element of XSD type xsd:anyURI */
	bool *RuleSupport;	/* optional element of XSD type xsd:boolean */
	tt__AnalyticsDeviceExtension *Extension;	/* optional element of XSD type tt:AnalyticsDeviceExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsDeviceCapabilities (497)
	virtual int soap_type(void) const { return 497; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsDeviceCapabilities, default initialized and not managed by a soap context
	virtual tt__AnalyticsDeviceCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsDeviceCapabilities); }
	         tt__AnalyticsDeviceCapabilities() { tt__AnalyticsDeviceCapabilities::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceCapabilities() { }
	friend SOAP_FMAC1 tt__AnalyticsDeviceCapabilities * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1489 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceExtension
#define SOAP_TYPE_tt__AnalyticsDeviceExtension (498)
/* tt:AnalyticsDeviceExtension complex type: */
class SOAP_CMAC tt__AnalyticsDeviceExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsDeviceExtension (498)
	virtual int soap_type(void) const { return 498; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsDeviceExtension, default initialized and not managed by a soap context
	virtual tt__AnalyticsDeviceExtension *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsDeviceExtension); }
	         tt__AnalyticsDeviceExtension() { tt__AnalyticsDeviceExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceExtension() { }
	friend SOAP_FMAC1 tt__AnalyticsDeviceExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1492 */
#ifndef SOAP_TYPE_tt__SystemLog
#define SOAP_TYPE_tt__SystemLog (499)
/* tt:SystemLog complex type: */
class SOAP_CMAC tt__SystemLog
{
public:
	tt__AttachmentData *Binary;	/* optional element of XSD type tt:AttachmentData */
	std::string *String;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemLog (499)
	virtual int soap_type(void) const { return 499; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemLog, default initialized and not managed by a soap context
	virtual tt__SystemLog *soap_alloc(void) const { return SOAP_NEW(tt__SystemLog); }
	         tt__SystemLog() { tt__SystemLog::soap_default(NULL); }
	virtual ~tt__SystemLog() { }
	friend SOAP_FMAC1 tt__SystemLog * SOAP_FMAC2 soap_instantiate_tt__SystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1495 */
#ifndef SOAP_TYPE_tt__SupportInformation
#define SOAP_TYPE_tt__SupportInformation (500)
/* tt:SupportInformation complex type: */
class SOAP_CMAC tt__SupportInformation
{
public:
	tt__AttachmentData *Binary;	/* optional element of XSD type tt:AttachmentData */
	std::string *String;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportInformation (500)
	virtual int soap_type(void) const { return 500; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportInformation, default initialized and not managed by a soap context
	virtual tt__SupportInformation *soap_alloc(void) const { return SOAP_NEW(tt__SupportInformation); }
	         tt__SupportInformation() { tt__SupportInformation::soap_default(NULL); }
	virtual ~tt__SupportInformation() { }
	friend SOAP_FMAC1 tt__SupportInformation * SOAP_FMAC2 soap_instantiate_tt__SupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1498 */
#ifndef SOAP_TYPE_tt__BinaryData
#define SOAP_TYPE_tt__BinaryData (501)
/* tt:BinaryData complex type: */
class SOAP_CMAC tt__BinaryData
{
public:
	xsd__base64Binary Data;	/* required element of XSD type xsd:base64Binary */
	char *xmime__contentType;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BinaryData (501)
	virtual int soap_type(void) const { return 501; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BinaryData, default initialized and not managed by a soap context
	virtual tt__BinaryData *soap_alloc(void) const { return SOAP_NEW(tt__BinaryData); }
	         tt__BinaryData() { tt__BinaryData::soap_default(NULL); }
	virtual ~tt__BinaryData() { }
	friend SOAP_FMAC1 tt__BinaryData * SOAP_FMAC2 soap_instantiate_tt__BinaryData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1501 */
#ifndef SOAP_TYPE_tt__AttachmentData
#define SOAP_TYPE_tt__AttachmentData (502)
/* tt:AttachmentData complex type: */
class SOAP_CMAC tt__AttachmentData
{
public:
	struct _xop__Include xop__Include;	/* required element of XSD type xop:Include */
	char *xmime__contentType;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AttachmentData (502)
	virtual int soap_type(void) const { return 502; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AttachmentData, default initialized and not managed by a soap context
	virtual tt__AttachmentData *soap_alloc(void) const { return SOAP_NEW(tt__AttachmentData); }
	         tt__AttachmentData() { tt__AttachmentData::soap_default(NULL); }
	virtual ~tt__AttachmentData() { }
	friend SOAP_FMAC1 tt__AttachmentData * SOAP_FMAC2 soap_instantiate_tt__AttachmentData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1504 */
#ifndef SOAP_TYPE_tt__BackupFile
#define SOAP_TYPE_tt__BackupFile (503)
/* tt:BackupFile complex type: */
class SOAP_CMAC tt__BackupFile
{
public:
	std::string Name;	/* required element of XSD type xsd:string */
	tt__AttachmentData *Data;	/* required element of XSD type tt:AttachmentData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BackupFile (503)
	virtual int soap_type(void) const { return 503; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BackupFile, default initialized and not managed by a soap context
	virtual tt__BackupFile *soap_alloc(void) const { return SOAP_NEW(tt__BackupFile); }
	         tt__BackupFile() { tt__BackupFile::soap_default(NULL); }
	virtual ~tt__BackupFile() { }
	friend SOAP_FMAC1 tt__BackupFile * SOAP_FMAC2 soap_instantiate_tt__BackupFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1507 */
#ifndef SOAP_TYPE_tt__SystemLogUriList
#define SOAP_TYPE_tt__SystemLogUriList (504)
/* tt:SystemLogUriList complex type: */
class SOAP_CMAC tt__SystemLogUriList
{
public:
	std::vector<tt__SystemLogUri *> SystemLog;	/* optional element of XSD type tt:SystemLogUri */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemLogUriList (504)
	virtual int soap_type(void) const { return 504; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemLogUriList, default initialized and not managed by a soap context
	virtual tt__SystemLogUriList *soap_alloc(void) const { return SOAP_NEW(tt__SystemLogUriList); }
	         tt__SystemLogUriList() { tt__SystemLogUriList::soap_default(NULL); }
	virtual ~tt__SystemLogUriList() { }
	friend SOAP_FMAC1 tt__SystemLogUriList * SOAP_FMAC2 soap_instantiate_tt__SystemLogUriList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1510 */
#ifndef SOAP_TYPE_tt__SystemLogUri
#define SOAP_TYPE_tt__SystemLogUri (505)
/* tt:SystemLogUri complex type: */
class SOAP_CMAC tt__SystemLogUri
{
public:
	enum tt__SystemLogType Type;	/* required element of XSD type tt:SystemLogType */
	std::string Uri;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemLogUri (505)
	virtual int soap_type(void) const { return 505; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemLogUri, default initialized and not managed by a soap context
	virtual tt__SystemLogUri *soap_alloc(void) const { return SOAP_NEW(tt__SystemLogUri); }
	         tt__SystemLogUri() { tt__SystemLogUri::soap_default(NULL); }
	virtual ~tt__SystemLogUri() { }
	friend SOAP_FMAC1 tt__SystemLogUri * SOAP_FMAC2 soap_instantiate_tt__SystemLogUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1513 */
#ifndef SOAP_TYPE_tt__SystemDateTime
#define SOAP_TYPE_tt__SystemDateTime (506)
/* tt:SystemDateTime complex type: */
class SOAP_CMAC tt__SystemDateTime
{
public:
	enum tt__SetDateTimeType DateTimeType;	/* required element of XSD type tt:SetDateTimeType */
	bool DaylightSavings;	/* required element of XSD type xsd:boolean */
	tt__TimeZone *TimeZone;	/* optional element of XSD type tt:TimeZone */
	tt__DateTime *UTCDateTime;	/* optional element of XSD type tt:DateTime */
	tt__DateTime *LocalDateTime;	/* optional element of XSD type tt:DateTime */
	tt__SystemDateTimeExtension *Extension;	/* optional element of XSD type tt:SystemDateTimeExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemDateTime (506)
	virtual int soap_type(void) const { return 506; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemDateTime, default initialized and not managed by a soap context
	virtual tt__SystemDateTime *soap_alloc(void) const { return SOAP_NEW(tt__SystemDateTime); }
	         tt__SystemDateTime() { tt__SystemDateTime::soap_default(NULL); }
	virtual ~tt__SystemDateTime() { }
	friend SOAP_FMAC1 tt__SystemDateTime * SOAP_FMAC2 soap_instantiate_tt__SystemDateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1516 */
#ifndef SOAP_TYPE_tt__SystemDateTimeExtension
#define SOAP_TYPE_tt__SystemDateTimeExtension (507)
/* tt:SystemDateTimeExtension complex type: */
class SOAP_CMAC tt__SystemDateTimeExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemDateTimeExtension (507)
	virtual int soap_type(void) const { return 507; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemDateTimeExtension, default initialized and not managed by a soap context
	virtual tt__SystemDateTimeExtension *soap_alloc(void) const { return SOAP_NEW(tt__SystemDateTimeExtension); }
	         tt__SystemDateTimeExtension() { tt__SystemDateTimeExtension::soap_default(NULL); }
	virtual ~tt__SystemDateTimeExtension() { }
	friend SOAP_FMAC1 tt__SystemDateTimeExtension * SOAP_FMAC2 soap_instantiate_tt__SystemDateTimeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1519 */
#ifndef SOAP_TYPE_tt__DateTime
#define SOAP_TYPE_tt__DateTime (508)
/* tt:DateTime complex type: */
class SOAP_CMAC tt__DateTime
{
public:
	tt__Time *Time;	/* required element of XSD type tt:Time */
	tt__Date *Date;	/* required element of XSD type tt:Date */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DateTime (508)
	virtual int soap_type(void) const { return 508; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DateTime, default initialized and not managed by a soap context
	virtual tt__DateTime *soap_alloc(void) const { return SOAP_NEW(tt__DateTime); }
	         tt__DateTime() { tt__DateTime::soap_default(NULL); }
	virtual ~tt__DateTime() { }
	friend SOAP_FMAC1 tt__DateTime * SOAP_FMAC2 soap_instantiate_tt__DateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1522 */
#ifndef SOAP_TYPE_tt__Date
#define SOAP_TYPE_tt__Date (509)
/* tt:Date complex type: */
class SOAP_CMAC tt__Date
{
public:
	int Year;	/* required element of XSD type xsd:int */
	int Month;	/* required element of XSD type xsd:int */
	int Day;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Date (509)
	virtual int soap_type(void) const { return 509; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Date, default initialized and not managed by a soap context
	virtual tt__Date *soap_alloc(void) const { return SOAP_NEW(tt__Date); }
	         tt__Date() { tt__Date::soap_default(NULL); }
	virtual ~tt__Date() { }
	friend SOAP_FMAC1 tt__Date * SOAP_FMAC2 soap_instantiate_tt__Date(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1525 */
#ifndef SOAP_TYPE_tt__Time
#define SOAP_TYPE_tt__Time (510)
/* tt:Time complex type: */
class SOAP_CMAC tt__Time
{
public:
	int Hour;	/* required element of XSD type xsd:int */
	int Minute;	/* required element of XSD type xsd:int */
	int Second;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Time (510)
	virtual int soap_type(void) const { return 510; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Time, default initialized and not managed by a soap context
	virtual tt__Time *soap_alloc(void) const { return SOAP_NEW(tt__Time); }
	         tt__Time() { tt__Time::soap_default(NULL); }
	virtual ~tt__Time() { }
	friend SOAP_FMAC1 tt__Time * SOAP_FMAC2 soap_instantiate_tt__Time(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1528 */
#ifndef SOAP_TYPE_tt__TimeZone
#define SOAP_TYPE_tt__TimeZone (511)
/* tt:TimeZone complex type: */
class SOAP_CMAC tt__TimeZone
{
public:
	std::string TZ;	/* required element of XSD type xsd:token */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TimeZone (511)
	virtual int soap_type(void) const { return 511; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TimeZone, default initialized and not managed by a soap context
	virtual tt__TimeZone *soap_alloc(void) const { return SOAP_NEW(tt__TimeZone); }
	         tt__TimeZone() { tt__TimeZone::soap_default(NULL); }
	virtual ~tt__TimeZone() { }
	friend SOAP_FMAC1 tt__TimeZone * SOAP_FMAC2 soap_instantiate_tt__TimeZone(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1531 */
#ifndef SOAP_TYPE_tt__GeoLocation
#define SOAP_TYPE_tt__GeoLocation (512)
/* tt:GeoLocation complex type: */
class SOAP_CMAC tt__GeoLocation
{
public:
	double *lon;	/* optional attribute of XSD type xsd:double */
	double *lat;	/* optional attribute of XSD type xsd:double */
	float *elevation;	/* optional attribute of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GeoLocation (512)
	virtual int soap_type(void) const { return 512; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GeoLocation, default initialized and not managed by a soap context
	virtual tt__GeoLocation *soap_alloc(void) const { return SOAP_NEW(tt__GeoLocation); }
	         tt__GeoLocation() { tt__GeoLocation::soap_default(NULL); }
	virtual ~tt__GeoLocation() { }
	friend SOAP_FMAC1 tt__GeoLocation * SOAP_FMAC2 soap_instantiate_tt__GeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1534 */
#ifndef SOAP_TYPE_tt__GeoOrientation
#define SOAP_TYPE_tt__GeoOrientation (513)
/* tt:GeoOrientation complex type: */
class SOAP_CMAC tt__GeoOrientation
{
public:
	float *roll;	/* optional attribute of XSD type xsd:float */
	float *pitch;	/* optional attribute of XSD type xsd:float */
	float *yaw;	/* optional attribute of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GeoOrientation (513)
	virtual int soap_type(void) const { return 513; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GeoOrientation, default initialized and not managed by a soap context
	virtual tt__GeoOrientation *soap_alloc(void) const { return SOAP_NEW(tt__GeoOrientation); }
	         tt__GeoOrientation() { tt__GeoOrientation::soap_default(NULL); }
	virtual ~tt__GeoOrientation() { }
	friend SOAP_FMAC1 tt__GeoOrientation * SOAP_FMAC2 soap_instantiate_tt__GeoOrientation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1537 */
#ifndef SOAP_TYPE_tt__LocalLocation
#define SOAP_TYPE_tt__LocalLocation (514)
/* tt:LocalLocation complex type: */
class SOAP_CMAC tt__LocalLocation
{
public:
	float *x;	/* optional attribute of XSD type xsd:float */
	float *y;	/* optional attribute of XSD type xsd:float */
	float *z;	/* optional attribute of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LocalLocation (514)
	virtual int soap_type(void) const { return 514; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LocalLocation, default initialized and not managed by a soap context
	virtual tt__LocalLocation *soap_alloc(void) const { return SOAP_NEW(tt__LocalLocation); }
	         tt__LocalLocation() { tt__LocalLocation::soap_default(NULL); }
	virtual ~tt__LocalLocation() { }
	friend SOAP_FMAC1 tt__LocalLocation * SOAP_FMAC2 soap_instantiate_tt__LocalLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1540 */
#ifndef SOAP_TYPE_tt__LocalOrientation
#define SOAP_TYPE_tt__LocalOrientation (515)
/* tt:LocalOrientation complex type: */
class SOAP_CMAC tt__LocalOrientation
{
public:
	float *pan;	/* optional attribute of XSD type xsd:float */
	float *tilt;	/* optional attribute of XSD type xsd:float */
	float *roll;	/* optional attribute of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LocalOrientation (515)
	virtual int soap_type(void) const { return 515; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LocalOrientation, default initialized and not managed by a soap context
	virtual tt__LocalOrientation *soap_alloc(void) const { return SOAP_NEW(tt__LocalOrientation); }
	         tt__LocalOrientation() { tt__LocalOrientation::soap_default(NULL); }
	virtual ~tt__LocalOrientation() { }
	friend SOAP_FMAC1 tt__LocalOrientation * SOAP_FMAC2 soap_instantiate_tt__LocalOrientation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1543 */
#ifndef SOAP_TYPE_tt__LocationEntity
#define SOAP_TYPE_tt__LocationEntity (516)
/* tt:LocationEntity complex type: */
class SOAP_CMAC tt__LocationEntity
{
public:
	tt__GeoLocation *GeoLocation;	/* optional element of XSD type tt:GeoLocation */
	tt__GeoOrientation *GeoOrientation;	/* optional element of XSD type tt:GeoOrientation */
	tt__LocalLocation *LocalLocation;	/* optional element of XSD type tt:LocalLocation */
	tt__LocalOrientation *LocalOrientation;	/* optional element of XSD type tt:LocalOrientation */
	std::string *Entity;	/* optional attribute of XSD type xsd:string */
	std::string *Token;	/* optional attribute of XSD type tt:ReferenceToken */
	bool *Fixed;	/* optional attribute of XSD type xsd:boolean */
	std::string *GeoSource;	/* optional attribute of XSD type xsd:anyURI */
	bool *AutoGeo;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LocationEntity (516)
	virtual int soap_type(void) const { return 516; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LocationEntity, default initialized and not managed by a soap context
	virtual tt__LocationEntity *soap_alloc(void) const { return SOAP_NEW(tt__LocationEntity); }
	         tt__LocationEntity() { tt__LocationEntity::soap_default(NULL); }
	virtual ~tt__LocationEntity() { }
	friend SOAP_FMAC1 tt__LocationEntity * SOAP_FMAC2 soap_instantiate_tt__LocationEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1546 */
#ifndef SOAP_TYPE_tt__RemoteUser
#define SOAP_TYPE_tt__RemoteUser (517)
/* tt:RemoteUser complex type: */
class SOAP_CMAC tt__RemoteUser
{
public:
	std::string Username;	/* required element of XSD type xsd:string */
	std::string *Password;	/* optional element of XSD type xsd:string */
	bool UseDerivedPassword;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RemoteUser (517)
	virtual int soap_type(void) const { return 517; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RemoteUser, default initialized and not managed by a soap context
	virtual tt__RemoteUser *soap_alloc(void) const { return SOAP_NEW(tt__RemoteUser); }
	         tt__RemoteUser() { tt__RemoteUser::soap_default(NULL); }
	virtual ~tt__RemoteUser() { }
	friend SOAP_FMAC1 tt__RemoteUser * SOAP_FMAC2 soap_instantiate_tt__RemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1549 */
#ifndef SOAP_TYPE_tt__User
#define SOAP_TYPE_tt__User (518)
/* tt:User complex type: */
class SOAP_CMAC tt__User
{
public:
	std::string Username;	/* required element of XSD type xsd:string */
	std::string *Password;	/* optional element of XSD type xsd:string */
	enum tt__UserLevel UserLevel;	/* required element of XSD type tt:UserLevel */
	tt__UserExtension *Extension;	/* optional element of XSD type tt:UserExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__User (518)
	virtual int soap_type(void) const { return 518; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__User, default initialized and not managed by a soap context
	virtual tt__User *soap_alloc(void) const { return SOAP_NEW(tt__User); }
	         tt__User() { tt__User::soap_default(NULL); }
	virtual ~tt__User() { }
	friend SOAP_FMAC1 tt__User * SOAP_FMAC2 soap_instantiate_tt__User(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1552 */
#ifndef SOAP_TYPE_tt__UserExtension
#define SOAP_TYPE_tt__UserExtension (519)
/* tt:UserExtension complex type: */
class SOAP_CMAC tt__UserExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__UserExtension (519)
	virtual int soap_type(void) const { return 519; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__UserExtension, default initialized and not managed by a soap context
	virtual tt__UserExtension *soap_alloc(void) const { return SOAP_NEW(tt__UserExtension); }
	         tt__UserExtension() { tt__UserExtension::soap_default(NULL); }
	virtual ~tt__UserExtension() { }
	friend SOAP_FMAC1 tt__UserExtension * SOAP_FMAC2 soap_instantiate_tt__UserExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1555 */
#ifndef SOAP_TYPE_tt__CertificateGenerationParameters
#define SOAP_TYPE_tt__CertificateGenerationParameters (520)
/* tt:CertificateGenerationParameters complex type: */
class SOAP_CMAC tt__CertificateGenerationParameters
{
public:
	std::string *CertificateID;	/* optional element of XSD type xsd:token */
	std::string *Subject;	/* optional element of XSD type xsd:string */
	std::string *ValidNotBefore;	/* optional element of XSD type xsd:token */
	std::string *ValidNotAfter;	/* optional element of XSD type xsd:token */
	tt__CertificateGenerationParametersExtension *Extension;	/* optional element of XSD type tt:CertificateGenerationParametersExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateGenerationParameters (520)
	virtual int soap_type(void) const { return 520; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateGenerationParameters, default initialized and not managed by a soap context
	virtual tt__CertificateGenerationParameters *soap_alloc(void) const { return SOAP_NEW(tt__CertificateGenerationParameters); }
	         tt__CertificateGenerationParameters() { tt__CertificateGenerationParameters::soap_default(NULL); }
	virtual ~tt__CertificateGenerationParameters() { }
	friend SOAP_FMAC1 tt__CertificateGenerationParameters * SOAP_FMAC2 soap_instantiate_tt__CertificateGenerationParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1558 */
#ifndef SOAP_TYPE_tt__CertificateGenerationParametersExtension
#define SOAP_TYPE_tt__CertificateGenerationParametersExtension (521)
/* tt:CertificateGenerationParametersExtension complex type: */
class SOAP_CMAC tt__CertificateGenerationParametersExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateGenerationParametersExtension (521)
	virtual int soap_type(void) const { return 521; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateGenerationParametersExtension, default initialized and not managed by a soap context
	virtual tt__CertificateGenerationParametersExtension *soap_alloc(void) const { return SOAP_NEW(tt__CertificateGenerationParametersExtension); }
	         tt__CertificateGenerationParametersExtension() { tt__CertificateGenerationParametersExtension::soap_default(NULL); }
	virtual ~tt__CertificateGenerationParametersExtension() { }
	friend SOAP_FMAC1 tt__CertificateGenerationParametersExtension * SOAP_FMAC2 soap_instantiate_tt__CertificateGenerationParametersExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1561 */
#ifndef SOAP_TYPE_tt__Certificate
#define SOAP_TYPE_tt__Certificate (522)
/* tt:Certificate complex type: */
class SOAP_CMAC tt__Certificate
{
public:
	std::string CertificateID;	/* required element of XSD type xsd:token */
	tt__BinaryData *Certificate;	/* required element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Certificate (522)
	virtual int soap_type(void) const { return 522; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Certificate, default initialized and not managed by a soap context
	virtual tt__Certificate *soap_alloc(void) const { return SOAP_NEW(tt__Certificate); }
	         tt__Certificate() { tt__Certificate::soap_default(NULL); }
	virtual ~tt__Certificate() { }
	friend SOAP_FMAC1 tt__Certificate * SOAP_FMAC2 soap_instantiate_tt__Certificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1564 */
#ifndef SOAP_TYPE_tt__CertificateStatus
#define SOAP_TYPE_tt__CertificateStatus (523)
/* tt:CertificateStatus complex type: */
class SOAP_CMAC tt__CertificateStatus
{
public:
	std::string CertificateID;	/* required element of XSD type xsd:token */
	bool Status;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateStatus (523)
	virtual int soap_type(void) const { return 523; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateStatus, default initialized and not managed by a soap context
	virtual tt__CertificateStatus *soap_alloc(void) const { return SOAP_NEW(tt__CertificateStatus); }
	         tt__CertificateStatus() { tt__CertificateStatus::soap_default(NULL); }
	virtual ~tt__CertificateStatus() { }
	friend SOAP_FMAC1 tt__CertificateStatus * SOAP_FMAC2 soap_instantiate_tt__CertificateStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1567 */
#ifndef SOAP_TYPE_tt__CertificateWithPrivateKey
#define SOAP_TYPE_tt__CertificateWithPrivateKey (524)
/* tt:CertificateWithPrivateKey complex type: */
class SOAP_CMAC tt__CertificateWithPrivateKey
{
public:
	std::string *CertificateID;	/* optional element of XSD type xsd:token */
	tt__BinaryData *Certificate;	/* required element of XSD type tt:BinaryData */
	tt__BinaryData *PrivateKey;	/* required element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateWithPrivateKey (524)
	virtual int soap_type(void) const { return 524; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateWithPrivateKey, default initialized and not managed by a soap context
	virtual tt__CertificateWithPrivateKey *soap_alloc(void) const { return SOAP_NEW(tt__CertificateWithPrivateKey); }
	         tt__CertificateWithPrivateKey() { tt__CertificateWithPrivateKey::soap_default(NULL); }
	virtual ~tt__CertificateWithPrivateKey() { }
	friend SOAP_FMAC1 tt__CertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate_tt__CertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1570 */
#ifndef SOAP_TYPE_tt__CertificateInformation
#define SOAP_TYPE_tt__CertificateInformation (525)
/* tt:CertificateInformation complex type: */
class SOAP_CMAC tt__CertificateInformation
{
public:
	std::string CertificateID;	/* required element of XSD type xsd:token */
	std::string *IssuerDN;	/* optional element of XSD type xsd:string */
	std::string *SubjectDN;	/* optional element of XSD type xsd:string */
	tt__CertificateUsage *KeyUsage;	/* optional element of XSD type tt:CertificateUsage */
	tt__CertificateUsage *ExtendedKeyUsage;	/* optional element of XSD type tt:CertificateUsage */
	int *KeyLength;	/* optional element of XSD type xsd:int */
	std::string *Version;	/* optional element of XSD type xsd:string */
	std::string *SerialNum;	/* optional element of XSD type xsd:string */
	std::string *SignatureAlgorithm;	/* optional element of XSD type xsd:string */
	tt__DateTimeRange *Validity;	/* optional element of XSD type tt:DateTimeRange */
	tt__CertificateInformationExtension *Extension;	/* optional element of XSD type tt:CertificateInformationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateInformation (525)
	virtual int soap_type(void) const { return 525; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateInformation, default initialized and not managed by a soap context
	virtual tt__CertificateInformation *soap_alloc(void) const { return SOAP_NEW(tt__CertificateInformation); }
	         tt__CertificateInformation() { tt__CertificateInformation::soap_default(NULL); }
	virtual ~tt__CertificateInformation() { }
	friend SOAP_FMAC1 tt__CertificateInformation * SOAP_FMAC2 soap_instantiate_tt__CertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1576 */
#ifndef SOAP_TYPE_tt__CertificateInformationExtension
#define SOAP_TYPE_tt__CertificateInformationExtension (527)
/* tt:CertificateInformationExtension complex type: */
class SOAP_CMAC tt__CertificateInformationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateInformationExtension (527)
	virtual int soap_type(void) const { return 527; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateInformationExtension, default initialized and not managed by a soap context
	virtual tt__CertificateInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__CertificateInformationExtension); }
	         tt__CertificateInformationExtension() { tt__CertificateInformationExtension::soap_default(NULL); }
	virtual ~tt__CertificateInformationExtension() { }
	friend SOAP_FMAC1 tt__CertificateInformationExtension * SOAP_FMAC2 soap_instantiate_tt__CertificateInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1579 */
#ifndef SOAP_TYPE_tt__Dot1XConfiguration
#define SOAP_TYPE_tt__Dot1XConfiguration (528)
/* tt:Dot1XConfiguration complex type: */
class SOAP_CMAC tt__Dot1XConfiguration
{
public:
	std::string Dot1XConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	std::string Identity;	/* required element of XSD type xsd:string */
	std::string *AnonymousID;	/* optional element of XSD type xsd:string */
	int EAPMethod;	/* required element of XSD type xsd:int */
	std::vector<std::string> CACertificateID;	/* optional element of XSD type xsd:token */
	tt__EAPMethodConfiguration *EAPMethodConfiguration;	/* optional element of XSD type tt:EAPMethodConfiguration */
	tt__Dot1XConfigurationExtension *Extension;	/* optional element of XSD type tt:Dot1XConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot1XConfiguration (528)
	virtual int soap_type(void) const { return 528; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot1XConfiguration, default initialized and not managed by a soap context
	virtual tt__Dot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__Dot1XConfiguration); }
	         tt__Dot1XConfiguration() { tt__Dot1XConfiguration::soap_default(NULL); }
	virtual ~tt__Dot1XConfiguration() { }
	friend SOAP_FMAC1 tt__Dot1XConfiguration * SOAP_FMAC2 soap_instantiate_tt__Dot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1582 */
#ifndef SOAP_TYPE_tt__Dot1XConfigurationExtension
#define SOAP_TYPE_tt__Dot1XConfigurationExtension (529)
/* tt:Dot1XConfigurationExtension complex type: */
class SOAP_CMAC tt__Dot1XConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot1XConfigurationExtension (529)
	virtual int soap_type(void) const { return 529; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot1XConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__Dot1XConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__Dot1XConfigurationExtension); }
	         tt__Dot1XConfigurationExtension() { tt__Dot1XConfigurationExtension::soap_default(NULL); }
	virtual ~tt__Dot1XConfigurationExtension() { }
	friend SOAP_FMAC1 tt__Dot1XConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__Dot1XConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1585 */
#ifndef SOAP_TYPE_tt__EAPMethodConfiguration
#define SOAP_TYPE_tt__EAPMethodConfiguration (530)
/* tt:EAPMethodConfiguration complex type: */
class SOAP_CMAC tt__EAPMethodConfiguration
{
public:
	tt__TLSConfiguration *TLSConfiguration;	/* optional element of XSD type tt:TLSConfiguration */
	std::string *Password;	/* optional element of XSD type xsd:string */
	tt__EapMethodExtension *Extension;	/* optional element of XSD type tt:EapMethodExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EAPMethodConfiguration (530)
	virtual int soap_type(void) const { return 530; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EAPMethodConfiguration, default initialized and not managed by a soap context
	virtual tt__EAPMethodConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__EAPMethodConfiguration); }
	         tt__EAPMethodConfiguration() { tt__EAPMethodConfiguration::soap_default(NULL); }
	virtual ~tt__EAPMethodConfiguration() { }
	friend SOAP_FMAC1 tt__EAPMethodConfiguration * SOAP_FMAC2 soap_instantiate_tt__EAPMethodConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1588 */
#ifndef SOAP_TYPE_tt__EapMethodExtension
#define SOAP_TYPE_tt__EapMethodExtension (531)
/* tt:EapMethodExtension complex type: */
class SOAP_CMAC tt__EapMethodExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EapMethodExtension (531)
	virtual int soap_type(void) const { return 531; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EapMethodExtension, default initialized and not managed by a soap context
	virtual tt__EapMethodExtension *soap_alloc(void) const { return SOAP_NEW(tt__EapMethodExtension); }
	         tt__EapMethodExtension() { tt__EapMethodExtension::soap_default(NULL); }
	virtual ~tt__EapMethodExtension() { }
	friend SOAP_FMAC1 tt__EapMethodExtension * SOAP_FMAC2 soap_instantiate_tt__EapMethodExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1591 */
#ifndef SOAP_TYPE_tt__TLSConfiguration
#define SOAP_TYPE_tt__TLSConfiguration (532)
/* tt:TLSConfiguration complex type: */
class SOAP_CMAC tt__TLSConfiguration
{
public:
	std::string CertificateID;	/* required element of XSD type xsd:token */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TLSConfiguration (532)
	virtual int soap_type(void) const { return 532; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TLSConfiguration, default initialized and not managed by a soap context
	virtual tt__TLSConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__TLSConfiguration); }
	         tt__TLSConfiguration() { tt__TLSConfiguration::soap_default(NULL); }
	virtual ~tt__TLSConfiguration() { }
	friend SOAP_FMAC1 tt__TLSConfiguration * SOAP_FMAC2 soap_instantiate_tt__TLSConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1594 */
#ifndef SOAP_TYPE_tt__GenericEapPwdConfigurationExtension
#define SOAP_TYPE_tt__GenericEapPwdConfigurationExtension (533)
/* tt:GenericEapPwdConfigurationExtension complex type: */
class SOAP_CMAC tt__GenericEapPwdConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GenericEapPwdConfigurationExtension (533)
	virtual int soap_type(void) const { return 533; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GenericEapPwdConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__GenericEapPwdConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__GenericEapPwdConfigurationExtension); }
	         tt__GenericEapPwdConfigurationExtension() { tt__GenericEapPwdConfigurationExtension::soap_default(NULL); }
	virtual ~tt__GenericEapPwdConfigurationExtension() { }
	friend SOAP_FMAC1 tt__GenericEapPwdConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__GenericEapPwdConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1597 */
#ifndef SOAP_TYPE_tt__RelayOutputSettings
#define SOAP_TYPE_tt__RelayOutputSettings (534)
/* tt:RelayOutputSettings complex type: */
class SOAP_CMAC tt__RelayOutputSettings
{
public:
	enum tt__RelayMode Mode;	/* required element of XSD type tt:RelayMode */
	LONG64 DelayTime;	/* external (custom serializer) */
	enum tt__RelayIdleState IdleState;	/* required element of XSD type tt:RelayIdleState */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelayOutputSettings (534)
	virtual int soap_type(void) const { return 534; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelayOutputSettings, default initialized and not managed by a soap context
	virtual tt__RelayOutputSettings *soap_alloc(void) const { return SOAP_NEW(tt__RelayOutputSettings); }
	         tt__RelayOutputSettings() { tt__RelayOutputSettings::soap_default(NULL); }
	virtual ~tt__RelayOutputSettings() { }
	friend SOAP_FMAC1 tt__RelayOutputSettings * SOAP_FMAC2 soap_instantiate_tt__RelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1609 */
#ifndef SOAP_TYPE_tt__PTZNodeExtension
#define SOAP_TYPE_tt__PTZNodeExtension (538)
/* tt:PTZNodeExtension complex type: */
class SOAP_CMAC tt__PTZNodeExtension
{
public:
	tt__PTZPresetTourSupported *SupportedPresetTour;	/* optional element of XSD type tt:PTZPresetTourSupported */
	tt__PTZNodeExtension2 *Extension;	/* optional element of XSD type tt:PTZNodeExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZNodeExtension (538)
	virtual int soap_type(void) const { return 538; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZNodeExtension, default initialized and not managed by a soap context
	virtual tt__PTZNodeExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZNodeExtension); }
	         tt__PTZNodeExtension() { tt__PTZNodeExtension::soap_default(NULL); }
	virtual ~tt__PTZNodeExtension() { }
	friend SOAP_FMAC1 tt__PTZNodeExtension * SOAP_FMAC2 soap_instantiate_tt__PTZNodeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1612 */
#ifndef SOAP_TYPE_tt__PTZNodeExtension2
#define SOAP_TYPE_tt__PTZNodeExtension2 (539)
/* tt:PTZNodeExtension2 complex type: */
class SOAP_CMAC tt__PTZNodeExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZNodeExtension2 (539)
	virtual int soap_type(void) const { return 539; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZNodeExtension2, default initialized and not managed by a soap context
	virtual tt__PTZNodeExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__PTZNodeExtension2); }
	         tt__PTZNodeExtension2() { tt__PTZNodeExtension2::soap_default(NULL); }
	virtual ~tt__PTZNodeExtension2() { }
	friend SOAP_FMAC1 tt__PTZNodeExtension2 * SOAP_FMAC2 soap_instantiate_tt__PTZNodeExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1615 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSupported
#define SOAP_TYPE_tt__PTZPresetTourSupported (540)
/* tt:PTZPresetTourSupported complex type: */
class SOAP_CMAC tt__PTZPresetTourSupported
{
public:
	int MaximumNumberOfPresetTours;	/* required element of XSD type xsd:int */
	std::vector<enum tt__PTZPresetTourOperation> PTZPresetTourOperation;	/* optional element of XSD type tt:PTZPresetTourOperation */
	tt__PTZPresetTourSupportedExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourSupportedExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSupported (540)
	virtual int soap_type(void) const { return 540; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSupported, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSupported *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSupported); }
	         tt__PTZPresetTourSupported() { tt__PTZPresetTourSupported::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSupported() { }
	friend SOAP_FMAC1 tt__PTZPresetTourSupported * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSupported(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1618 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSupportedExtension
#define SOAP_TYPE_tt__PTZPresetTourSupportedExtension (541)
/* tt:PTZPresetTourSupportedExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourSupportedExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSupportedExtension (541)
	virtual int soap_type(void) const { return 541; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSupportedExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSupportedExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSupportedExtension); }
	         tt__PTZPresetTourSupportedExtension() { tt__PTZPresetTourSupportedExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSupportedExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourSupportedExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSupportedExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1624 */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension
#define SOAP_TYPE_tt__PTZConfigurationExtension (543)
/* tt:PTZConfigurationExtension complex type: */
class SOAP_CMAC tt__PTZConfigurationExtension
{
public:
	tt__PTControlDirection *PTControlDirection;	/* optional element of XSD type tt:PTControlDirection */
	tt__PTZConfigurationExtension2 *Extension;	/* optional element of XSD type tt:PTZConfigurationExtension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfigurationExtension (543)
	virtual int soap_type(void) const { return 543; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__PTZConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfigurationExtension); }
	         tt__PTZConfigurationExtension() { tt__PTZConfigurationExtension::soap_default(NULL); }
	virtual ~tt__PTZConfigurationExtension() { }
	friend SOAP_FMAC1 tt__PTZConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1627 */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension2
#define SOAP_TYPE_tt__PTZConfigurationExtension2 (544)
/* tt:PTZConfigurationExtension2 complex type: */
class SOAP_CMAC tt__PTZConfigurationExtension2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfigurationExtension2 (544)
	virtual int soap_type(void) const { return 544; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfigurationExtension2, default initialized and not managed by a soap context
	virtual tt__PTZConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfigurationExtension2); }
	         tt__PTZConfigurationExtension2() { tt__PTZConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__PTZConfigurationExtension2() { }
	friend SOAP_FMAC1 tt__PTZConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1630 */
#ifndef SOAP_TYPE_tt__PTControlDirection
#define SOAP_TYPE_tt__PTControlDirection (545)
/* tt:PTControlDirection complex type: */
class SOAP_CMAC tt__PTControlDirection
{
public:
	tt__EFlip *EFlip;	/* optional element of XSD type tt:EFlip */
	tt__Reverse *Reverse;	/* optional element of XSD type tt:Reverse */
	tt__PTControlDirectionExtension *Extension;	/* optional element of XSD type tt:PTControlDirectionExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTControlDirection (545)
	virtual int soap_type(void) const { return 545; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTControlDirection, default initialized and not managed by a soap context
	virtual tt__PTControlDirection *soap_alloc(void) const { return SOAP_NEW(tt__PTControlDirection); }
	         tt__PTControlDirection() { tt__PTControlDirection::soap_default(NULL); }
	virtual ~tt__PTControlDirection() { }
	friend SOAP_FMAC1 tt__PTControlDirection * SOAP_FMAC2 soap_instantiate_tt__PTControlDirection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1633 */
#ifndef SOAP_TYPE_tt__PTControlDirectionExtension
#define SOAP_TYPE_tt__PTControlDirectionExtension (546)
/* tt:PTControlDirectionExtension complex type: */
class SOAP_CMAC tt__PTControlDirectionExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTControlDirectionExtension (546)
	virtual int soap_type(void) const { return 546; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTControlDirectionExtension, default initialized and not managed by a soap context
	virtual tt__PTControlDirectionExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTControlDirectionExtension); }
	         tt__PTControlDirectionExtension() { tt__PTControlDirectionExtension::soap_default(NULL); }
	virtual ~tt__PTControlDirectionExtension() { }
	friend SOAP_FMAC1 tt__PTControlDirectionExtension * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1636 */
#ifndef SOAP_TYPE_tt__EFlip
#define SOAP_TYPE_tt__EFlip (547)
/* tt:EFlip complex type: */
class SOAP_CMAC tt__EFlip
{
public:
	enum tt__EFlipMode Mode;	/* required element of XSD type tt:EFlipMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EFlip (547)
	virtual int soap_type(void) const { return 547; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EFlip, default initialized and not managed by a soap context
	virtual tt__EFlip *soap_alloc(void) const { return SOAP_NEW(tt__EFlip); }
	         tt__EFlip() { tt__EFlip::soap_default(NULL); }
	virtual ~tt__EFlip() { }
	friend SOAP_FMAC1 tt__EFlip * SOAP_FMAC2 soap_instantiate_tt__EFlip(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1639 */
#ifndef SOAP_TYPE_tt__Reverse
#define SOAP_TYPE_tt__Reverse (548)
/* tt:Reverse complex type: */
class SOAP_CMAC tt__Reverse
{
public:
	enum tt__ReverseMode Mode;	/* required element of XSD type tt:ReverseMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Reverse (548)
	virtual int soap_type(void) const { return 548; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Reverse, default initialized and not managed by a soap context
	virtual tt__Reverse *soap_alloc(void) const { return SOAP_NEW(tt__Reverse); }
	         tt__Reverse() { tt__Reverse::soap_default(NULL); }
	virtual ~tt__Reverse() { }
	friend SOAP_FMAC1 tt__Reverse * SOAP_FMAC2 soap_instantiate_tt__Reverse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1642 */
#ifndef SOAP_TYPE_tt__PTZConfigurationOptions
#define SOAP_TYPE_tt__PTZConfigurationOptions (549)
/* tt:PTZConfigurationOptions complex type: */
class SOAP_CMAC tt__PTZConfigurationOptions
{
public:
	tt__PTZSpaces *Spaces;	/* required element of XSD type tt:PTZSpaces */
	tt__DurationRange *PTZTimeout;	/* required element of XSD type tt:DurationRange */
	tt__PTControlDirectionOptions *PTControlDirection;	/* optional element of XSD type tt:PTControlDirectionOptions */
	tt__PTZConfigurationOptions2 *Extension;	/* optional element of XSD type tt:PTZConfigurationOptions2 */
	std::string *PTZRamps;	/* optional attribute of XSD type tt:IntAttrList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfigurationOptions (549)
	virtual int soap_type(void) const { return 549; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__PTZConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfigurationOptions); }
	         tt__PTZConfigurationOptions() { tt__PTZConfigurationOptions::soap_default(NULL); }
	virtual ~tt__PTZConfigurationOptions() { }
	friend SOAP_FMAC1 tt__PTZConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1645 */
#ifndef SOAP_TYPE_tt__PTZConfigurationOptions2
#define SOAP_TYPE_tt__PTZConfigurationOptions2 (550)
/* tt:PTZConfigurationOptions2 complex type: */
class SOAP_CMAC tt__PTZConfigurationOptions2
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfigurationOptions2 (550)
	virtual int soap_type(void) const { return 550; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfigurationOptions2, default initialized and not managed by a soap context
	virtual tt__PTZConfigurationOptions2 *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfigurationOptions2); }
	         tt__PTZConfigurationOptions2() { tt__PTZConfigurationOptions2::soap_default(NULL); }
	virtual ~tt__PTZConfigurationOptions2() { }
	friend SOAP_FMAC1 tt__PTZConfigurationOptions2 * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationOptions2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1648 */
#ifndef SOAP_TYPE_tt__PTControlDirectionOptions
#define SOAP_TYPE_tt__PTControlDirectionOptions (551)
/* tt:PTControlDirectionOptions complex type: */
class SOAP_CMAC tt__PTControlDirectionOptions
{
public:
	tt__EFlipOptions *EFlip;	/* optional element of XSD type tt:EFlipOptions */
	tt__ReverseOptions *Reverse;	/* optional element of XSD type tt:ReverseOptions */
	tt__PTControlDirectionOptionsExtension *Extension;	/* optional element of XSD type tt:PTControlDirectionOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTControlDirectionOptions (551)
	virtual int soap_type(void) const { return 551; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTControlDirectionOptions, default initialized and not managed by a soap context
	virtual tt__PTControlDirectionOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTControlDirectionOptions); }
	         tt__PTControlDirectionOptions() { tt__PTControlDirectionOptions::soap_default(NULL); }
	virtual ~tt__PTControlDirectionOptions() { }
	friend SOAP_FMAC1 tt__PTControlDirectionOptions * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1651 */
#ifndef SOAP_TYPE_tt__PTControlDirectionOptionsExtension
#define SOAP_TYPE_tt__PTControlDirectionOptionsExtension (552)
/* tt:PTControlDirectionOptionsExtension complex type: */
class SOAP_CMAC tt__PTControlDirectionOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTControlDirectionOptionsExtension (552)
	virtual int soap_type(void) const { return 552; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTControlDirectionOptionsExtension, default initialized and not managed by a soap context
	virtual tt__PTControlDirectionOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTControlDirectionOptionsExtension); }
	         tt__PTControlDirectionOptionsExtension() { tt__PTControlDirectionOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTControlDirectionOptionsExtension() { }
	friend SOAP_FMAC1 tt__PTControlDirectionOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1654 */
#ifndef SOAP_TYPE_tt__EFlipOptions
#define SOAP_TYPE_tt__EFlipOptions (553)
/* tt:EFlipOptions complex type: */
class SOAP_CMAC tt__EFlipOptions
{
public:
	std::vector<enum tt__EFlipMode> Mode;	/* optional element of XSD type tt:EFlipMode */
	tt__EFlipOptionsExtension *Extension;	/* optional element of XSD type tt:EFlipOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EFlipOptions (553)
	virtual int soap_type(void) const { return 553; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EFlipOptions, default initialized and not managed by a soap context
	virtual tt__EFlipOptions *soap_alloc(void) const { return SOAP_NEW(tt__EFlipOptions); }
	         tt__EFlipOptions() { tt__EFlipOptions::soap_default(NULL); }
	virtual ~tt__EFlipOptions() { }
	friend SOAP_FMAC1 tt__EFlipOptions * SOAP_FMAC2 soap_instantiate_tt__EFlipOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1657 */
#ifndef SOAP_TYPE_tt__EFlipOptionsExtension
#define SOAP_TYPE_tt__EFlipOptionsExtension (554)
/* tt:EFlipOptionsExtension complex type: */
class SOAP_CMAC tt__EFlipOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EFlipOptionsExtension (554)
	virtual int soap_type(void) const { return 554; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EFlipOptionsExtension, default initialized and not managed by a soap context
	virtual tt__EFlipOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__EFlipOptionsExtension); }
	         tt__EFlipOptionsExtension() { tt__EFlipOptionsExtension::soap_default(NULL); }
	virtual ~tt__EFlipOptionsExtension() { }
	friend SOAP_FMAC1 tt__EFlipOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__EFlipOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1660 */
#ifndef SOAP_TYPE_tt__ReverseOptions
#define SOAP_TYPE_tt__ReverseOptions (555)
/* tt:ReverseOptions complex type: */
class SOAP_CMAC tt__ReverseOptions
{
public:
	std::vector<enum tt__ReverseMode> Mode;	/* optional element of XSD type tt:ReverseMode */
	tt__ReverseOptionsExtension *Extension;	/* optional element of XSD type tt:ReverseOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReverseOptions (555)
	virtual int soap_type(void) const { return 555; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReverseOptions, default initialized and not managed by a soap context
	virtual tt__ReverseOptions *soap_alloc(void) const { return SOAP_NEW(tt__ReverseOptions); }
	         tt__ReverseOptions() { tt__ReverseOptions::soap_default(NULL); }
	virtual ~tt__ReverseOptions() { }
	friend SOAP_FMAC1 tt__ReverseOptions * SOAP_FMAC2 soap_instantiate_tt__ReverseOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1663 */
#ifndef SOAP_TYPE_tt__ReverseOptionsExtension
#define SOAP_TYPE_tt__ReverseOptionsExtension (556)
/* tt:ReverseOptionsExtension complex type: */
class SOAP_CMAC tt__ReverseOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReverseOptionsExtension (556)
	virtual int soap_type(void) const { return 556; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReverseOptionsExtension, default initialized and not managed by a soap context
	virtual tt__ReverseOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__ReverseOptionsExtension); }
	         tt__ReverseOptionsExtension() { tt__ReverseOptionsExtension::soap_default(NULL); }
	virtual ~tt__ReverseOptionsExtension() { }
	friend SOAP_FMAC1 tt__ReverseOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__ReverseOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1666 */
#ifndef SOAP_TYPE_tt__PanTiltLimits
#define SOAP_TYPE_tt__PanTiltLimits (557)
/* tt:PanTiltLimits complex type: */
class SOAP_CMAC tt__PanTiltLimits
{
public:
	tt__Space2DDescription *Range;	/* required element of XSD type tt:Space2DDescription */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PanTiltLimits (557)
	virtual int soap_type(void) const { return 557; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PanTiltLimits, default initialized and not managed by a soap context
	virtual tt__PanTiltLimits *soap_alloc(void) const { return SOAP_NEW(tt__PanTiltLimits); }
	         tt__PanTiltLimits() { tt__PanTiltLimits::soap_default(NULL); }
	virtual ~tt__PanTiltLimits() { }
	friend SOAP_FMAC1 tt__PanTiltLimits * SOAP_FMAC2 soap_instantiate_tt__PanTiltLimits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1669 */
#ifndef SOAP_TYPE_tt__ZoomLimits
#define SOAP_TYPE_tt__ZoomLimits (558)
/* tt:ZoomLimits complex type: */
class SOAP_CMAC tt__ZoomLimits
{
public:
	tt__Space1DDescription *Range;	/* required element of XSD type tt:Space1DDescription */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ZoomLimits (558)
	virtual int soap_type(void) const { return 558; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ZoomLimits, default initialized and not managed by a soap context
	virtual tt__ZoomLimits *soap_alloc(void) const { return SOAP_NEW(tt__ZoomLimits); }
	         tt__ZoomLimits() { tt__ZoomLimits::soap_default(NULL); }
	virtual ~tt__ZoomLimits() { }
	friend SOAP_FMAC1 tt__ZoomLimits * SOAP_FMAC2 soap_instantiate_tt__ZoomLimits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1672 */
#ifndef SOAP_TYPE_tt__PTZSpaces
#define SOAP_TYPE_tt__PTZSpaces (559)
/* tt:PTZSpaces complex type: */
class SOAP_CMAC tt__PTZSpaces
{
public:
	std::vector<tt__Space2DDescription *> AbsolutePanTiltPositionSpace;	/* optional element of XSD type tt:Space2DDescription */
	std::vector<tt__Space1DDescription *> AbsoluteZoomPositionSpace;	/* optional element of XSD type tt:Space1DDescription */
	std::vector<tt__Space2DDescription *> RelativePanTiltTranslationSpace;	/* optional element of XSD type tt:Space2DDescription */
	std::vector<tt__Space1DDescription *> RelativeZoomTranslationSpace;	/* optional element of XSD type tt:Space1DDescription */
	std::vector<tt__Space2DDescription *> ContinuousPanTiltVelocitySpace;	/* optional element of XSD type tt:Space2DDescription */
	std::vector<tt__Space1DDescription *> ContinuousZoomVelocitySpace;	/* optional element of XSD type tt:Space1DDescription */
	std::vector<tt__Space1DDescription *> PanTiltSpeedSpace;	/* optional element of XSD type tt:Space1DDescription */
	std::vector<tt__Space1DDescription *> ZoomSpeedSpace;	/* optional element of XSD type tt:Space1DDescription */
	tt__PTZSpacesExtension *Extension;	/* optional element of XSD type tt:PTZSpacesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZSpaces (559)
	virtual int soap_type(void) const { return 559; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZSpaces, default initialized and not managed by a soap context
	virtual tt__PTZSpaces *soap_alloc(void) const { return SOAP_NEW(tt__PTZSpaces); }
	         tt__PTZSpaces() { tt__PTZSpaces::soap_default(NULL); }
	virtual ~tt__PTZSpaces() { }
	friend SOAP_FMAC1 tt__PTZSpaces * SOAP_FMAC2 soap_instantiate_tt__PTZSpaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1675 */
#ifndef SOAP_TYPE_tt__PTZSpacesExtension
#define SOAP_TYPE_tt__PTZSpacesExtension (560)
/* tt:PTZSpacesExtension complex type: */
class SOAP_CMAC tt__PTZSpacesExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZSpacesExtension (560)
	virtual int soap_type(void) const { return 560; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZSpacesExtension, default initialized and not managed by a soap context
	virtual tt__PTZSpacesExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZSpacesExtension); }
	         tt__PTZSpacesExtension() { tt__PTZSpacesExtension::soap_default(NULL); }
	virtual ~tt__PTZSpacesExtension() { }
	friend SOAP_FMAC1 tt__PTZSpacesExtension * SOAP_FMAC2 soap_instantiate_tt__PTZSpacesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1678 */
#ifndef SOAP_TYPE_tt__Space2DDescription
#define SOAP_TYPE_tt__Space2DDescription (561)
/* tt:Space2DDescription complex type: */
class SOAP_CMAC tt__Space2DDescription
{
public:
	std::string URI;	/* required element of XSD type xsd:anyURI */
	tt__FloatRange *XRange;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *YRange;	/* required element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Space2DDescription (561)
	virtual int soap_type(void) const { return 561; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Space2DDescription, default initialized and not managed by a soap context
	virtual tt__Space2DDescription *soap_alloc(void) const { return SOAP_NEW(tt__Space2DDescription); }
	         tt__Space2DDescription() { tt__Space2DDescription::soap_default(NULL); }
	virtual ~tt__Space2DDescription() { }
	friend SOAP_FMAC1 tt__Space2DDescription * SOAP_FMAC2 soap_instantiate_tt__Space2DDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1681 */
#ifndef SOAP_TYPE_tt__Space1DDescription
#define SOAP_TYPE_tt__Space1DDescription (562)
/* tt:Space1DDescription complex type: */
class SOAP_CMAC tt__Space1DDescription
{
public:
	std::string URI;	/* required element of XSD type xsd:anyURI */
	tt__FloatRange *XRange;	/* required element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Space1DDescription (562)
	virtual int soap_type(void) const { return 562; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Space1DDescription, default initialized and not managed by a soap context
	virtual tt__Space1DDescription *soap_alloc(void) const { return SOAP_NEW(tt__Space1DDescription); }
	         tt__Space1DDescription() { tt__Space1DDescription::soap_default(NULL); }
	virtual ~tt__Space1DDescription() { }
	friend SOAP_FMAC1 tt__Space1DDescription * SOAP_FMAC2 soap_instantiate_tt__Space1DDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1684 */
#ifndef SOAP_TYPE_tt__PTZSpeed
#define SOAP_TYPE_tt__PTZSpeed (563)
/* tt:PTZSpeed complex type: */
class SOAP_CMAC tt__PTZSpeed
{
public:
	tt__Vector2D *PanTilt;	/* optional element of XSD type tt:Vector2D */
	tt__Vector1D *Zoom;	/* optional element of XSD type tt:Vector1D */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZSpeed (563)
	virtual int soap_type(void) const { return 563; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZSpeed, default initialized and not managed by a soap context
	virtual tt__PTZSpeed *soap_alloc(void) const { return SOAP_NEW(tt__PTZSpeed); }
	         tt__PTZSpeed() { tt__PTZSpeed::soap_default(NULL); }
	virtual ~tt__PTZSpeed() { }
	friend SOAP_FMAC1 tt__PTZSpeed * SOAP_FMAC2 soap_instantiate_tt__PTZSpeed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1687 */
#ifndef SOAP_TYPE_tt__PTZPreset
#define SOAP_TYPE_tt__PTZPreset (564)
/* tt:PTZPreset complex type: */
class SOAP_CMAC tt__PTZPreset
{
public:
	std::string *Name;	/* optional element of XSD type tt:Name */
	tt__PTZVector *PTZPosition;	/* optional element of XSD type tt:PTZVector */
	std::string *token;	/* optional attribute of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPreset (564)
	virtual int soap_type(void) const { return 564; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPreset, default initialized and not managed by a soap context
	virtual tt__PTZPreset *soap_alloc(void) const { return SOAP_NEW(tt__PTZPreset); }
	         tt__PTZPreset() { tt__PTZPreset::soap_default(NULL); }
	virtual ~tt__PTZPreset() { }
	friend SOAP_FMAC1 tt__PTZPreset * SOAP_FMAC2 soap_instantiate_tt__PTZPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1690 */
#ifndef SOAP_TYPE_tt__PresetTour
#define SOAP_TYPE_tt__PresetTour (565)
/* tt:PresetTour complex type: */
class SOAP_CMAC tt__PresetTour
{
public:
	std::string *Name;	/* optional element of XSD type tt:Name */
	tt__PTZPresetTourStatus *Status;	/* required element of XSD type tt:PTZPresetTourStatus */
	bool AutoStart;	/* required element of XSD type xsd:boolean */
	tt__PTZPresetTourStartingCondition *StartingCondition;	/* required element of XSD type tt:PTZPresetTourStartingCondition */
	std::vector<tt__PTZPresetTourSpot *> TourSpot;	/* optional element of XSD type tt:PTZPresetTourSpot */
	tt__PTZPresetTourExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourExtension */
	std::string *token;	/* optional attribute of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PresetTour (565)
	virtual int soap_type(void) const { return 565; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PresetTour, default initialized and not managed by a soap context
	virtual tt__PresetTour *soap_alloc(void) const { return SOAP_NEW(tt__PresetTour); }
	         tt__PresetTour() { tt__PresetTour::soap_default(NULL); }
	virtual ~tt__PresetTour() { }
	friend SOAP_FMAC1 tt__PresetTour * SOAP_FMAC2 soap_instantiate_tt__PresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1693 */
#ifndef SOAP_TYPE_tt__PTZPresetTourExtension
#define SOAP_TYPE_tt__PTZPresetTourExtension (566)
/* tt:PTZPresetTourExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourExtension (566)
	virtual int soap_type(void) const { return 566; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourExtension); }
	         tt__PTZPresetTourExtension() { tt__PTZPresetTourExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1696 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpot
#define SOAP_TYPE_tt__PTZPresetTourSpot (567)
/* tt:PTZPresetTourSpot complex type: */
class SOAP_CMAC tt__PTZPresetTourSpot
{
public:
	tt__PTZPresetTourPresetDetail *PresetDetail;	/* required element of XSD type tt:PTZPresetTourPresetDetail */
	tt__PTZSpeed *Speed;	/* optional element of XSD type tt:PTZSpeed */
	LONG64 *StayTime;	/* optional element of XSD type xsd:duration */
	tt__PTZPresetTourSpotExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourSpotExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSpot (567)
	virtual int soap_type(void) const { return 567; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSpot, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSpot *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSpot); }
	         tt__PTZPresetTourSpot() { tt__PTZPresetTourSpot::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSpot() { }
	friend SOAP_FMAC1 tt__PTZPresetTourSpot * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1699 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpotExtension
#define SOAP_TYPE_tt__PTZPresetTourSpotExtension (568)
/* tt:PTZPresetTourSpotExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourSpotExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSpotExtension (568)
	virtual int soap_type(void) const { return 568; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSpotExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSpotExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSpotExtension); }
	         tt__PTZPresetTourSpotExtension() { tt__PTZPresetTourSpotExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSpotExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourSpotExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpotExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:17357 */
#ifndef SOAP_TYPE__tt__union_PTZPresetTourPresetDetail
#define SOAP_TYPE__tt__union_PTZPresetTourPresetDetail (1291)
/* xsd:choice complex type: */
union _tt__union_PTZPresetTourPresetDetail
{
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken	(1)
	std::string *PresetToken;
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home	(2)
	bool Home;
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition	(3)
	tt__PTZVector *PTZPosition;
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension	(4)
	tt__PTZPresetTourTypeExtension *TypeExtension;
};
#endif

/* onvif.h:1702 */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetail
#define SOAP_TYPE_tt__PTZPresetTourPresetDetail (569)
/* Choice: */
class SOAP_CMAC tt__PTZPresetTourPresetDetail
{
public:
	int __union_PTZPresetTourPresetDetail;	/* union discriminant (of union defined below) */
	union _tt__union_PTZPresetTourPresetDetail union_PTZPresetTourPresetDetail;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourPresetDetail (569)
	virtual int soap_type(void) const { return 569; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourPresetDetail, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourPresetDetail *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourPresetDetail); }
	         tt__PTZPresetTourPresetDetail() { tt__PTZPresetTourPresetDetail::soap_default(NULL); }
	virtual ~tt__PTZPresetTourPresetDetail() { }
	friend SOAP_FMAC1 tt__PTZPresetTourPresetDetail * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetail(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1705 */
#ifndef SOAP_TYPE_tt__PTZPresetTourTypeExtension
#define SOAP_TYPE_tt__PTZPresetTourTypeExtension (570)
/* tt:PTZPresetTourTypeExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourTypeExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourTypeExtension (570)
	virtual int soap_type(void) const { return 570; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourTypeExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourTypeExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourTypeExtension); }
	         tt__PTZPresetTourTypeExtension() { tt__PTZPresetTourTypeExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourTypeExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourTypeExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourTypeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1708 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStatus
#define SOAP_TYPE_tt__PTZPresetTourStatus (571)
/* tt:PTZPresetTourStatus complex type: */
class SOAP_CMAC tt__PTZPresetTourStatus
{
public:
	enum tt__PTZPresetTourState State;	/* required element of XSD type tt:PTZPresetTourState */
	tt__PTZPresetTourSpot *CurrentTourSpot;	/* optional element of XSD type tt:PTZPresetTourSpot */
	tt__PTZPresetTourStatusExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourStatusExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStatus (571)
	virtual int soap_type(void) const { return 571; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStatus, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStatus *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStatus); }
	         tt__PTZPresetTourStatus() { tt__PTZPresetTourStatus::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStatus() { }
	friend SOAP_FMAC1 tt__PTZPresetTourStatus * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1711 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStatusExtension
#define SOAP_TYPE_tt__PTZPresetTourStatusExtension (572)
/* tt:PTZPresetTourStatusExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourStatusExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStatusExtension (572)
	virtual int soap_type(void) const { return 572; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStatusExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStatusExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStatusExtension); }
	         tt__PTZPresetTourStatusExtension() { tt__PTZPresetTourStatusExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStatusExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourStatusExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStatusExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1714 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingCondition
#define SOAP_TYPE_tt__PTZPresetTourStartingCondition (573)
/* tt:PTZPresetTourStartingCondition complex type: */
class SOAP_CMAC tt__PTZPresetTourStartingCondition
{
public:
	int *RecurringTime;	/* optional element of XSD type xsd:int */
	LONG64 *RecurringDuration;	/* optional element of XSD type xsd:duration */
	enum tt__PTZPresetTourDirection *Direction;	/* optional element of XSD type tt:PTZPresetTourDirection */
	tt__PTZPresetTourStartingConditionExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourStartingConditionExtension */
	bool *RandomPresetOrder;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStartingCondition (573)
	virtual int soap_type(void) const { return 573; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStartingCondition, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStartingCondition *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStartingCondition); }
	         tt__PTZPresetTourStartingCondition() { tt__PTZPresetTourStartingCondition::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingCondition() { }
	friend SOAP_FMAC1 tt__PTZPresetTourStartingCondition * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingCondition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1717 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension (574)
/* tt:PTZPresetTourStartingConditionExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourStartingConditionExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension (574)
	virtual int soap_type(void) const { return 574; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStartingConditionExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStartingConditionExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStartingConditionExtension); }
	         tt__PTZPresetTourStartingConditionExtension() { tt__PTZPresetTourStartingConditionExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingConditionExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourStartingConditionExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1720 */
#ifndef SOAP_TYPE_tt__PTZPresetTourOptions
#define SOAP_TYPE_tt__PTZPresetTourOptions (575)
/* tt:PTZPresetTourOptions complex type: */
class SOAP_CMAC tt__PTZPresetTourOptions
{
public:
	bool AutoStart;	/* required element of XSD type xsd:boolean */
	tt__PTZPresetTourStartingConditionOptions *StartingCondition;	/* required element of XSD type tt:PTZPresetTourStartingConditionOptions */
	tt__PTZPresetTourSpotOptions *TourSpot;	/* required element of XSD type tt:PTZPresetTourSpotOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourOptions (575)
	virtual int soap_type(void) const { return 575; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourOptions, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourOptions); }
	         tt__PTZPresetTourOptions() { tt__PTZPresetTourOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourOptions() { }
	friend SOAP_FMAC1 tt__PTZPresetTourOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1723 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpotOptions
#define SOAP_TYPE_tt__PTZPresetTourSpotOptions (576)
/* tt:PTZPresetTourSpotOptions complex type: */
class SOAP_CMAC tt__PTZPresetTourSpotOptions
{
public:
	tt__PTZPresetTourPresetDetailOptions *PresetDetail;	/* required element of XSD type tt:PTZPresetTourPresetDetailOptions */
	tt__DurationRange *StayTime;	/* required element of XSD type tt:DurationRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSpotOptions (576)
	virtual int soap_type(void) const { return 576; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSpotOptions, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSpotOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSpotOptions); }
	         tt__PTZPresetTourSpotOptions() { tt__PTZPresetTourSpotOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSpotOptions() { }
	friend SOAP_FMAC1 tt__PTZPresetTourSpotOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpotOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1726 */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions (577)
/* tt:PTZPresetTourPresetDetailOptions complex type: */
class SOAP_CMAC tt__PTZPresetTourPresetDetailOptions
{
public:
	std::vector<std::string> PresetToken;	/* optional element of XSD type tt:ReferenceToken */
	bool *Home;	/* optional element of XSD type xsd:boolean */
	tt__Space2DDescription *PanTiltPositionSpace;	/* optional element of XSD type tt:Space2DDescription */
	tt__Space1DDescription *ZoomPositionSpace;	/* optional element of XSD type tt:Space1DDescription */
	tt__PTZPresetTourPresetDetailOptionsExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourPresetDetailOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions (577)
	virtual int soap_type(void) const { return 577; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourPresetDetailOptions, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourPresetDetailOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourPresetDetailOptions); }
	         tt__PTZPresetTourPresetDetailOptions() { tt__PTZPresetTourPresetDetailOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourPresetDetailOptions() { }
	friend SOAP_FMAC1 tt__PTZPresetTourPresetDetailOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetailOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1729 */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension (578)
/* tt:PTZPresetTourPresetDetailOptionsExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourPresetDetailOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension (578)
	virtual int soap_type(void) const { return 578; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourPresetDetailOptionsExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourPresetDetailOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourPresetDetailOptionsExtension); }
	         tt__PTZPresetTourPresetDetailOptionsExtension() { tt__PTZPresetTourPresetDetailOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourPresetDetailOptionsExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourPresetDetailOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1732 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions (579)
/* tt:PTZPresetTourStartingConditionOptions complex type: */
class SOAP_CMAC tt__PTZPresetTourStartingConditionOptions
{
public:
	tt__IntRange *RecurringTime;	/* optional element of XSD type tt:IntRange */
	tt__DurationRange *RecurringDuration;	/* optional element of XSD type tt:DurationRange */
	std::vector<enum tt__PTZPresetTourDirection> Direction;	/* optional element of XSD type tt:PTZPresetTourDirection */
	tt__PTZPresetTourStartingConditionOptionsExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourStartingConditionOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions (579)
	virtual int soap_type(void) const { return 579; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStartingConditionOptions, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStartingConditionOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStartingConditionOptions); }
	         tt__PTZPresetTourStartingConditionOptions() { tt__PTZPresetTourStartingConditionOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingConditionOptions() { }
	friend SOAP_FMAC1 tt__PTZPresetTourStartingConditionOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1735 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension (580)
/* tt:PTZPresetTourStartingConditionOptionsExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourStartingConditionOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension (580)
	virtual int soap_type(void) const { return 580; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStartingConditionOptionsExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStartingConditionOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStartingConditionOptionsExtension); }
	         tt__PTZPresetTourStartingConditionOptionsExtension() { tt__PTZPresetTourStartingConditionOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingConditionOptionsExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourStartingConditionOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1738 */
#ifndef SOAP_TYPE_tt__ImagingStatus
#define SOAP_TYPE_tt__ImagingStatus (581)
/* tt:ImagingStatus complex type: */
class SOAP_CMAC tt__ImagingStatus
{
public:
	tt__FocusStatus *FocusStatus;	/* required element of XSD type tt:FocusStatus */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingStatus (581)
	virtual int soap_type(void) const { return 581; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingStatus, default initialized and not managed by a soap context
	virtual tt__ImagingStatus *soap_alloc(void) const { return SOAP_NEW(tt__ImagingStatus); }
	         tt__ImagingStatus() { tt__ImagingStatus::soap_default(NULL); }
	virtual ~tt__ImagingStatus() { }
	friend SOAP_FMAC1 tt__ImagingStatus * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1741 */
#ifndef SOAP_TYPE_tt__FocusStatus
#define SOAP_TYPE_tt__FocusStatus (582)
/* tt:FocusStatus complex type: */
class SOAP_CMAC tt__FocusStatus
{
public:
	float Position;	/* required element of XSD type xsd:float */
	enum tt__MoveStatus MoveStatus;	/* required element of XSD type tt:MoveStatus */
	std::string Error;	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusStatus (582)
	virtual int soap_type(void) const { return 582; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusStatus, default initialized and not managed by a soap context
	virtual tt__FocusStatus *soap_alloc(void) const { return SOAP_NEW(tt__FocusStatus); }
	         tt__FocusStatus() { tt__FocusStatus::soap_default(NULL); }
	virtual ~tt__FocusStatus() { }
	friend SOAP_FMAC1 tt__FocusStatus * SOAP_FMAC2 soap_instantiate_tt__FocusStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1744 */
#ifndef SOAP_TYPE_tt__FocusConfiguration
#define SOAP_TYPE_tt__FocusConfiguration (583)
/* tt:FocusConfiguration complex type: */
class SOAP_CMAC tt__FocusConfiguration
{
public:
	enum tt__AutoFocusMode AutoFocusMode;	/* required element of XSD type tt:AutoFocusMode */
	float DefaultSpeed;	/* required element of XSD type xsd:float */
	float NearLimit;	/* required element of XSD type xsd:float */
	float FarLimit;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusConfiguration (583)
	virtual int soap_type(void) const { return 583; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusConfiguration, default initialized and not managed by a soap context
	virtual tt__FocusConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__FocusConfiguration); }
	         tt__FocusConfiguration() { tt__FocusConfiguration::soap_default(NULL); }
	virtual ~tt__FocusConfiguration() { }
	friend SOAP_FMAC1 tt__FocusConfiguration * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1747 */
#ifndef SOAP_TYPE_tt__ImagingSettings
#define SOAP_TYPE_tt__ImagingSettings (584)
/* tt:ImagingSettings complex type: */
class SOAP_CMAC tt__ImagingSettings
{
public:
	tt__BacklightCompensation *BacklightCompensation;	/* optional element of XSD type tt:BacklightCompensation */
	float *Brightness;	/* optional element of XSD type xsd:float */
	float *ColorSaturation;	/* optional element of XSD type xsd:float */
	float *Contrast;	/* optional element of XSD type xsd:float */
	tt__Exposure *Exposure;	/* optional element of XSD type tt:Exposure */
	tt__FocusConfiguration *Focus;	/* optional element of XSD type tt:FocusConfiguration */
	enum tt__IrCutFilterMode *IrCutFilter;	/* optional element of XSD type tt:IrCutFilterMode */
	float *Sharpness;	/* optional element of XSD type xsd:float */
	tt__WideDynamicRange *WideDynamicRange;	/* optional element of XSD type tt:WideDynamicRange */
	tt__WhiteBalance *WhiteBalance;	/* optional element of XSD type tt:WhiteBalance */
	tt__ImagingSettingsExtension *Extension;	/* optional element of XSD type tt:ImagingSettingsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettings (584)
	virtual int soap_type(void) const { return 584; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettings, default initialized and not managed by a soap context
	virtual tt__ImagingSettings *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettings); }
	         tt__ImagingSettings() { tt__ImagingSettings::soap_default(NULL); }
	virtual ~tt__ImagingSettings() { }
	friend SOAP_FMAC1 tt__ImagingSettings * SOAP_FMAC2 soap_instantiate_tt__ImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1750 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension
#define SOAP_TYPE_tt__ImagingSettingsExtension (585)
/* tt:ImagingSettingsExtension complex type: */
class SOAP_CMAC tt__ImagingSettingsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettingsExtension (585)
	virtual int soap_type(void) const { return 585; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettingsExtension, default initialized and not managed by a soap context
	virtual tt__ImagingSettingsExtension *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettingsExtension); }
	         tt__ImagingSettingsExtension() { tt__ImagingSettingsExtension::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension() { }
	friend SOAP_FMAC1 tt__ImagingSettingsExtension * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1753 */
#ifndef SOAP_TYPE_tt__Exposure
#define SOAP_TYPE_tt__Exposure (586)
/* tt:Exposure complex type: */
class SOAP_CMAC tt__Exposure
{
public:
	enum tt__ExposureMode Mode;	/* required element of XSD type tt:ExposureMode */
	enum tt__ExposurePriority Priority;	/* required element of XSD type tt:ExposurePriority */
	tt__Rectangle *Window;	/* required element of XSD type tt:Rectangle */
	float MinExposureTime;	/* required element of XSD type xsd:float */
	float MaxExposureTime;	/* required element of XSD type xsd:float */
	float MinGain;	/* required element of XSD type xsd:float */
	float MaxGain;	/* required element of XSD type xsd:float */
	float MinIris;	/* required element of XSD type xsd:float */
	float MaxIris;	/* required element of XSD type xsd:float */
	float ExposureTime;	/* required element of XSD type xsd:float */
	float Gain;	/* required element of XSD type xsd:float */
	float Iris;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Exposure (586)
	virtual int soap_type(void) const { return 586; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Exposure, default initialized and not managed by a soap context
	virtual tt__Exposure *soap_alloc(void) const { return SOAP_NEW(tt__Exposure); }
	         tt__Exposure() { tt__Exposure::soap_default(NULL); }
	virtual ~tt__Exposure() { }
	friend SOAP_FMAC1 tt__Exposure * SOAP_FMAC2 soap_instantiate_tt__Exposure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1756 */
#ifndef SOAP_TYPE_tt__WideDynamicRange
#define SOAP_TYPE_tt__WideDynamicRange (587)
/* tt:WideDynamicRange complex type: */
class SOAP_CMAC tt__WideDynamicRange
{
public:
	enum tt__WideDynamicMode Mode;	/* required element of XSD type tt:WideDynamicMode */
	float Level;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WideDynamicRange (587)
	virtual int soap_type(void) const { return 587; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WideDynamicRange, default initialized and not managed by a soap context
	virtual tt__WideDynamicRange *soap_alloc(void) const { return SOAP_NEW(tt__WideDynamicRange); }
	         tt__WideDynamicRange() { tt__WideDynamicRange::soap_default(NULL); }
	virtual ~tt__WideDynamicRange() { }
	friend SOAP_FMAC1 tt__WideDynamicRange * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1759 */
#ifndef SOAP_TYPE_tt__BacklightCompensation
#define SOAP_TYPE_tt__BacklightCompensation (588)
/* tt:BacklightCompensation complex type: */
class SOAP_CMAC tt__BacklightCompensation
{
public:
	enum tt__BacklightCompensationMode Mode;	/* required element of XSD type tt:BacklightCompensationMode */
	float Level;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BacklightCompensation (588)
	virtual int soap_type(void) const { return 588; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BacklightCompensation, default initialized and not managed by a soap context
	virtual tt__BacklightCompensation *soap_alloc(void) const { return SOAP_NEW(tt__BacklightCompensation); }
	         tt__BacklightCompensation() { tt__BacklightCompensation::soap_default(NULL); }
	virtual ~tt__BacklightCompensation() { }
	friend SOAP_FMAC1 tt__BacklightCompensation * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1762 */
#ifndef SOAP_TYPE_tt__ImagingOptions
#define SOAP_TYPE_tt__ImagingOptions (589)
/* tt:ImagingOptions complex type: */
class SOAP_CMAC tt__ImagingOptions
{
public:
	tt__BacklightCompensationOptions *BacklightCompensation;	/* required element of XSD type tt:BacklightCompensationOptions */
	tt__FloatRange *Brightness;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *ColorSaturation;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Contrast;	/* required element of XSD type tt:FloatRange */
	tt__ExposureOptions *Exposure;	/* required element of XSD type tt:ExposureOptions */
	tt__FocusOptions *Focus;	/* required element of XSD type tt:FocusOptions */
	std::vector<enum tt__IrCutFilterMode> IrCutFilterModes;	/* required element of XSD type tt:IrCutFilterMode */
	tt__FloatRange *Sharpness;	/* required element of XSD type tt:FloatRange */
	tt__WideDynamicRangeOptions *WideDynamicRange;	/* required element of XSD type tt:WideDynamicRangeOptions */
	tt__WhiteBalanceOptions *WhiteBalance;	/* required element of XSD type tt:WhiteBalanceOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions (589)
	virtual int soap_type(void) const { return 589; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions, default initialized and not managed by a soap context
	virtual tt__ImagingOptions *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions); }
	         tt__ImagingOptions() { tt__ImagingOptions::soap_default(NULL); }
	virtual ~tt__ImagingOptions() { }
	friend SOAP_FMAC1 tt__ImagingOptions * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1765 */
#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions
#define SOAP_TYPE_tt__WideDynamicRangeOptions (590)
/* tt:WideDynamicRangeOptions complex type: */
class SOAP_CMAC tt__WideDynamicRangeOptions
{
public:
	std::vector<enum tt__WideDynamicMode> Mode;	/* required element of XSD type tt:WideDynamicMode */
	tt__FloatRange *Level;	/* required element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WideDynamicRangeOptions (590)
	virtual int soap_type(void) const { return 590; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WideDynamicRangeOptions, default initialized and not managed by a soap context
	virtual tt__WideDynamicRangeOptions *soap_alloc(void) const { return SOAP_NEW(tt__WideDynamicRangeOptions); }
	         tt__WideDynamicRangeOptions() { tt__WideDynamicRangeOptions::soap_default(NULL); }
	virtual ~tt__WideDynamicRangeOptions() { }
	friend SOAP_FMAC1 tt__WideDynamicRangeOptions * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRangeOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1768 */
#ifndef SOAP_TYPE_tt__BacklightCompensationOptions
#define SOAP_TYPE_tt__BacklightCompensationOptions (591)
/* tt:BacklightCompensationOptions complex type: */
class SOAP_CMAC tt__BacklightCompensationOptions
{
public:
	std::vector<enum tt__WideDynamicMode> Mode;	/* required element of XSD type tt:WideDynamicMode */
	tt__FloatRange *Level;	/* required element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BacklightCompensationOptions (591)
	virtual int soap_type(void) const { return 591; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BacklightCompensationOptions, default initialized and not managed by a soap context
	virtual tt__BacklightCompensationOptions *soap_alloc(void) const { return SOAP_NEW(tt__BacklightCompensationOptions); }
	         tt__BacklightCompensationOptions() { tt__BacklightCompensationOptions::soap_default(NULL); }
	virtual ~tt__BacklightCompensationOptions() { }
	friend SOAP_FMAC1 tt__BacklightCompensationOptions * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1771 */
#ifndef SOAP_TYPE_tt__FocusOptions
#define SOAP_TYPE_tt__FocusOptions (592)
/* tt:FocusOptions complex type: */
class SOAP_CMAC tt__FocusOptions
{
public:
	std::vector<enum tt__AutoFocusMode> AutoFocusModes;	/* optional element of XSD type tt:AutoFocusMode */
	tt__FloatRange *DefaultSpeed;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *NearLimit;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *FarLimit;	/* required element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusOptions (592)
	virtual int soap_type(void) const { return 592; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusOptions, default initialized and not managed by a soap context
	virtual tt__FocusOptions *soap_alloc(void) const { return SOAP_NEW(tt__FocusOptions); }
	         tt__FocusOptions() { tt__FocusOptions::soap_default(NULL); }
	virtual ~tt__FocusOptions() { }
	friend SOAP_FMAC1 tt__FocusOptions * SOAP_FMAC2 soap_instantiate_tt__FocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1774 */
#ifndef SOAP_TYPE_tt__ExposureOptions
#define SOAP_TYPE_tt__ExposureOptions (593)
/* tt:ExposureOptions complex type: */
class SOAP_CMAC tt__ExposureOptions
{
public:
	std::vector<enum tt__ExposureMode> Mode;	/* required element of XSD type tt:ExposureMode */
	std::vector<enum tt__ExposurePriority> Priority;	/* required element of XSD type tt:ExposurePriority */
	tt__FloatRange *MinExposureTime;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MaxExposureTime;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MinGain;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MaxGain;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MinIris;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MaxIris;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *ExposureTime;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Gain;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Iris;	/* required element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ExposureOptions (593)
	virtual int soap_type(void) const { return 593; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ExposureOptions, default initialized and not managed by a soap context
	virtual tt__ExposureOptions *soap_alloc(void) const { return SOAP_NEW(tt__ExposureOptions); }
	         tt__ExposureOptions() { tt__ExposureOptions::soap_default(NULL); }
	virtual ~tt__ExposureOptions() { }
	friend SOAP_FMAC1 tt__ExposureOptions * SOAP_FMAC2 soap_instantiate_tt__ExposureOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1777 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions
#define SOAP_TYPE_tt__WhiteBalanceOptions (594)
/* tt:WhiteBalanceOptions complex type: */
class SOAP_CMAC tt__WhiteBalanceOptions
{
public:
	std::vector<enum tt__WhiteBalanceMode> Mode;	/* required element of XSD type tt:WhiteBalanceMode */
	tt__FloatRange *YrGain;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *YbGain;	/* required element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalanceOptions (594)
	virtual int soap_type(void) const { return 594; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalanceOptions, default initialized and not managed by a soap context
	virtual tt__WhiteBalanceOptions *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalanceOptions); }
	         tt__WhiteBalanceOptions() { tt__WhiteBalanceOptions::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions() { }
	friend SOAP_FMAC1 tt__WhiteBalanceOptions * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1780 */
#ifndef SOAP_TYPE_tt__FocusMove
#define SOAP_TYPE_tt__FocusMove (595)
/* tt:FocusMove complex type: */
class SOAP_CMAC tt__FocusMove
{
public:
	tt__AbsoluteFocus *Absolute;	/* optional element of XSD type tt:AbsoluteFocus */
	tt__RelativeFocus *Relative;	/* optional element of XSD type tt:RelativeFocus */
	tt__ContinuousFocus *Continuous;	/* optional element of XSD type tt:ContinuousFocus */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusMove (595)
	virtual int soap_type(void) const { return 595; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusMove, default initialized and not managed by a soap context
	virtual tt__FocusMove *soap_alloc(void) const { return SOAP_NEW(tt__FocusMove); }
	         tt__FocusMove() { tt__FocusMove::soap_default(NULL); }
	virtual ~tt__FocusMove() { }
	friend SOAP_FMAC1 tt__FocusMove * SOAP_FMAC2 soap_instantiate_tt__FocusMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1783 */
#ifndef SOAP_TYPE_tt__AbsoluteFocus
#define SOAP_TYPE_tt__AbsoluteFocus (596)
/* tt:AbsoluteFocus complex type: */
class SOAP_CMAC tt__AbsoluteFocus
{
public:
	float Position;	/* required element of XSD type xsd:float */
	float *Speed;	/* optional element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AbsoluteFocus (596)
	virtual int soap_type(void) const { return 596; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AbsoluteFocus, default initialized and not managed by a soap context
	virtual tt__AbsoluteFocus *soap_alloc(void) const { return SOAP_NEW(tt__AbsoluteFocus); }
	         tt__AbsoluteFocus() { tt__AbsoluteFocus::soap_default(NULL); }
	virtual ~tt__AbsoluteFocus() { }
	friend SOAP_FMAC1 tt__AbsoluteFocus * SOAP_FMAC2 soap_instantiate_tt__AbsoluteFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1786 */
#ifndef SOAP_TYPE_tt__RelativeFocus
#define SOAP_TYPE_tt__RelativeFocus (597)
/* tt:RelativeFocus complex type: */
class SOAP_CMAC tt__RelativeFocus
{
public:
	float Distance;	/* required element of XSD type xsd:float */
	float *Speed;	/* optional element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelativeFocus (597)
	virtual int soap_type(void) const { return 597; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelativeFocus, default initialized and not managed by a soap context
	virtual tt__RelativeFocus *soap_alloc(void) const { return SOAP_NEW(tt__RelativeFocus); }
	         tt__RelativeFocus() { tt__RelativeFocus::soap_default(NULL); }
	virtual ~tt__RelativeFocus() { }
	friend SOAP_FMAC1 tt__RelativeFocus * SOAP_FMAC2 soap_instantiate_tt__RelativeFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1789 */
#ifndef SOAP_TYPE_tt__ContinuousFocus
#define SOAP_TYPE_tt__ContinuousFocus (598)
/* tt:ContinuousFocus complex type: */
class SOAP_CMAC tt__ContinuousFocus
{
public:
	float Speed;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ContinuousFocus (598)
	virtual int soap_type(void) const { return 598; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ContinuousFocus, default initialized and not managed by a soap context
	virtual tt__ContinuousFocus *soap_alloc(void) const { return SOAP_NEW(tt__ContinuousFocus); }
	         tt__ContinuousFocus() { tt__ContinuousFocus::soap_default(NULL); }
	virtual ~tt__ContinuousFocus() { }
	friend SOAP_FMAC1 tt__ContinuousFocus * SOAP_FMAC2 soap_instantiate_tt__ContinuousFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1792 */
#ifndef SOAP_TYPE_tt__MoveOptions
#define SOAP_TYPE_tt__MoveOptions (599)
/* tt:MoveOptions complex type: */
class SOAP_CMAC tt__MoveOptions
{
public:
	tt__AbsoluteFocusOptions *Absolute;	/* optional element of XSD type tt:AbsoluteFocusOptions */
	tt__RelativeFocusOptions *Relative;	/* optional element of XSD type tt:RelativeFocusOptions */
	tt__ContinuousFocusOptions *Continuous;	/* optional element of XSD type tt:ContinuousFocusOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MoveOptions (599)
	virtual int soap_type(void) const { return 599; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MoveOptions, default initialized and not managed by a soap context
	virtual tt__MoveOptions *soap_alloc(void) const { return SOAP_NEW(tt__MoveOptions); }
	         tt__MoveOptions() { tt__MoveOptions::soap_default(NULL); }
	virtual ~tt__MoveOptions() { }
	friend SOAP_FMAC1 tt__MoveOptions * SOAP_FMAC2 soap_instantiate_tt__MoveOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1795 */
#ifndef SOAP_TYPE_tt__AbsoluteFocusOptions
#define SOAP_TYPE_tt__AbsoluteFocusOptions (600)
/* tt:AbsoluteFocusOptions complex type: */
class SOAP_CMAC tt__AbsoluteFocusOptions
{
public:
	tt__FloatRange *Position;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Speed;	/* optional element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AbsoluteFocusOptions (600)
	virtual int soap_type(void) const { return 600; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AbsoluteFocusOptions, default initialized and not managed by a soap context
	virtual tt__AbsoluteFocusOptions *soap_alloc(void) const { return SOAP_NEW(tt__AbsoluteFocusOptions); }
	         tt__AbsoluteFocusOptions() { tt__AbsoluteFocusOptions::soap_default(NULL); }
	virtual ~tt__AbsoluteFocusOptions() { }
	friend SOAP_FMAC1 tt__AbsoluteFocusOptions * SOAP_FMAC2 soap_instantiate_tt__AbsoluteFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1798 */
#ifndef SOAP_TYPE_tt__RelativeFocusOptions
#define SOAP_TYPE_tt__RelativeFocusOptions (601)
/* tt:RelativeFocusOptions complex type: */
class SOAP_CMAC tt__RelativeFocusOptions
{
public:
	tt__FloatRange *Distance;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Speed;	/* required element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelativeFocusOptions (601)
	virtual int soap_type(void) const { return 601; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelativeFocusOptions, default initialized and not managed by a soap context
	virtual tt__RelativeFocusOptions *soap_alloc(void) const { return SOAP_NEW(tt__RelativeFocusOptions); }
	         tt__RelativeFocusOptions() { tt__RelativeFocusOptions::soap_default(NULL); }
	virtual ~tt__RelativeFocusOptions() { }
	friend SOAP_FMAC1 tt__RelativeFocusOptions * SOAP_FMAC2 soap_instantiate_tt__RelativeFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1801 */
#ifndef SOAP_TYPE_tt__ContinuousFocusOptions
#define SOAP_TYPE_tt__ContinuousFocusOptions (602)
/* tt:ContinuousFocusOptions complex type: */
class SOAP_CMAC tt__ContinuousFocusOptions
{
public:
	tt__FloatRange *Speed;	/* required element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ContinuousFocusOptions (602)
	virtual int soap_type(void) const { return 602; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ContinuousFocusOptions, default initialized and not managed by a soap context
	virtual tt__ContinuousFocusOptions *soap_alloc(void) const { return SOAP_NEW(tt__ContinuousFocusOptions); }
	         tt__ContinuousFocusOptions() { tt__ContinuousFocusOptions::soap_default(NULL); }
	virtual ~tt__ContinuousFocusOptions() { }
	friend SOAP_FMAC1 tt__ContinuousFocusOptions * SOAP_FMAC2 soap_instantiate_tt__ContinuousFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1804 */
#ifndef SOAP_TYPE_tt__WhiteBalance
#define SOAP_TYPE_tt__WhiteBalance (603)
/* tt:WhiteBalance complex type: */
class SOAP_CMAC tt__WhiteBalance
{
public:
	enum tt__WhiteBalanceMode Mode;	/* required element of XSD type tt:WhiteBalanceMode */
	float CrGain;	/* required element of XSD type xsd:float */
	float CbGain;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalance (603)
	virtual int soap_type(void) const { return 603; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalance, default initialized and not managed by a soap context
	virtual tt__WhiteBalance *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalance); }
	         tt__WhiteBalance() { tt__WhiteBalance::soap_default(NULL); }
	virtual ~tt__WhiteBalance() { }
	friend SOAP_FMAC1 tt__WhiteBalance * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1807 */
#ifndef SOAP_TYPE_tt__ImagingStatus20
#define SOAP_TYPE_tt__ImagingStatus20 (604)
/* tt:ImagingStatus20 complex type: */
class SOAP_CMAC tt__ImagingStatus20
{
public:
	tt__FocusStatus20 *FocusStatus20;	/* optional element of XSD type tt:FocusStatus20 */
	tt__ImagingStatus20Extension *Extension;	/* optional element of XSD type tt:ImagingStatus20Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingStatus20 (604)
	virtual int soap_type(void) const { return 604; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingStatus20, default initialized and not managed by a soap context
	virtual tt__ImagingStatus20 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingStatus20); }
	         tt__ImagingStatus20() { tt__ImagingStatus20::soap_default(NULL); }
	virtual ~tt__ImagingStatus20() { }
	friend SOAP_FMAC1 tt__ImagingStatus20 * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1810 */
#ifndef SOAP_TYPE_tt__ImagingStatus20Extension
#define SOAP_TYPE_tt__ImagingStatus20Extension (605)
/* tt:ImagingStatus20Extension complex type: */
class SOAP_CMAC tt__ImagingStatus20Extension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingStatus20Extension (605)
	virtual int soap_type(void) const { return 605; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingStatus20Extension, default initialized and not managed by a soap context
	virtual tt__ImagingStatus20Extension *soap_alloc(void) const { return SOAP_NEW(tt__ImagingStatus20Extension); }
	         tt__ImagingStatus20Extension() { tt__ImagingStatus20Extension::soap_default(NULL); }
	virtual ~tt__ImagingStatus20Extension() { }
	friend SOAP_FMAC1 tt__ImagingStatus20Extension * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1813 */
#ifndef SOAP_TYPE_tt__FocusStatus20
#define SOAP_TYPE_tt__FocusStatus20 (606)
/* tt:FocusStatus20 complex type: */
class SOAP_CMAC tt__FocusStatus20
{
public:
	float Position;	/* required element of XSD type xsd:float */
	enum tt__MoveStatus MoveStatus;	/* required element of XSD type tt:MoveStatus */
	std::string *Error;	/* optional element of XSD type xsd:string */
	tt__FocusStatus20Extension *Extension;	/* optional element of XSD type tt:FocusStatus20Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusStatus20 (606)
	virtual int soap_type(void) const { return 606; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusStatus20, default initialized and not managed by a soap context
	virtual tt__FocusStatus20 *soap_alloc(void) const { return SOAP_NEW(tt__FocusStatus20); }
	         tt__FocusStatus20() { tt__FocusStatus20::soap_default(NULL); }
	virtual ~tt__FocusStatus20() { }
	friend SOAP_FMAC1 tt__FocusStatus20 * SOAP_FMAC2 soap_instantiate_tt__FocusStatus20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1816 */
#ifndef SOAP_TYPE_tt__FocusStatus20Extension
#define SOAP_TYPE_tt__FocusStatus20Extension (607)
/* tt:FocusStatus20Extension complex type: */
class SOAP_CMAC tt__FocusStatus20Extension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusStatus20Extension (607)
	virtual int soap_type(void) const { return 607; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusStatus20Extension, default initialized and not managed by a soap context
	virtual tt__FocusStatus20Extension *soap_alloc(void) const { return SOAP_NEW(tt__FocusStatus20Extension); }
	         tt__FocusStatus20Extension() { tt__FocusStatus20Extension::soap_default(NULL); }
	virtual ~tt__FocusStatus20Extension() { }
	friend SOAP_FMAC1 tt__FocusStatus20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusStatus20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1819 */
#ifndef SOAP_TYPE_tt__ImagingSettings20
#define SOAP_TYPE_tt__ImagingSettings20 (608)
/* tt:ImagingSettings20 complex type: */
class SOAP_CMAC tt__ImagingSettings20
{
public:
	tt__BacklightCompensation20 *BacklightCompensation;	/* optional element of XSD type tt:BacklightCompensation20 */
	float *Brightness;	/* optional element of XSD type xsd:float */
	float *ColorSaturation;	/* optional element of XSD type xsd:float */
	float *Contrast;	/* optional element of XSD type xsd:float */
	tt__Exposure20 *Exposure;	/* optional element of XSD type tt:Exposure20 */
	tt__FocusConfiguration20 *Focus;	/* optional element of XSD type tt:FocusConfiguration20 */
	enum tt__IrCutFilterMode *IrCutFilter;	/* optional element of XSD type tt:IrCutFilterMode */
	float *Sharpness;	/* optional element of XSD type xsd:float */
	tt__WideDynamicRange20 *WideDynamicRange;	/* optional element of XSD type tt:WideDynamicRange20 */
	tt__WhiteBalance20 *WhiteBalance;	/* optional element of XSD type tt:WhiteBalance20 */
	tt__ImagingSettingsExtension20 *Extension;	/* optional element of XSD type tt:ImagingSettingsExtension20 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettings20 (608)
	virtual int soap_type(void) const { return 608; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettings20, default initialized and not managed by a soap context
	virtual tt__ImagingSettings20 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettings20); }
	         tt__ImagingSettings20() { tt__ImagingSettings20::soap_default(NULL); }
	virtual ~tt__ImagingSettings20() { }
	friend SOAP_FMAC1 tt__ImagingSettings20 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettings20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1822 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension20
#define SOAP_TYPE_tt__ImagingSettingsExtension20 (609)
/* tt:ImagingSettingsExtension20 complex type: */
class SOAP_CMAC tt__ImagingSettingsExtension20
{
public:
	tt__ImageStabilization *ImageStabilization;	/* optional element of XSD type tt:ImageStabilization */
	tt__ImagingSettingsExtension202 *Extension;	/* optional element of XSD type tt:ImagingSettingsExtension202 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettingsExtension20 (609)
	virtual int soap_type(void) const { return 609; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettingsExtension20, default initialized and not managed by a soap context
	virtual tt__ImagingSettingsExtension20 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettingsExtension20); }
	         tt__ImagingSettingsExtension20() { tt__ImagingSettingsExtension20::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension20() { }
	friend SOAP_FMAC1 tt__ImagingSettingsExtension20 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1825 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension202
#define SOAP_TYPE_tt__ImagingSettingsExtension202 (610)
/* tt:ImagingSettingsExtension202 complex type: */
class SOAP_CMAC tt__ImagingSettingsExtension202
{
public:
	std::vector<tt__IrCutFilterAutoAdjustment *> IrCutFilterAutoAdjustment;	/* optional element of XSD type tt:IrCutFilterAutoAdjustment */
	tt__ImagingSettingsExtension203 *Extension;	/* optional element of XSD type tt:ImagingSettingsExtension203 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettingsExtension202 (610)
	virtual int soap_type(void) const { return 610; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettingsExtension202, default initialized and not managed by a soap context
	virtual tt__ImagingSettingsExtension202 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettingsExtension202); }
	         tt__ImagingSettingsExtension202() { tt__ImagingSettingsExtension202::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension202() { }
	friend SOAP_FMAC1 tt__ImagingSettingsExtension202 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension202(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1828 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension203
#define SOAP_TYPE_tt__ImagingSettingsExtension203 (611)
/* tt:ImagingSettingsExtension203 complex type: */
class SOAP_CMAC tt__ImagingSettingsExtension203
{
public:
	tt__ToneCompensation *ToneCompensation;	/* optional element of XSD type tt:ToneCompensation */
	tt__Defogging *Defogging;	/* optional element of XSD type tt:Defogging */
	tt__NoiseReduction *NoiseReduction;	/* optional element of XSD type tt:NoiseReduction */
	tt__ImagingSettingsExtension204 *Extension;	/* optional element of XSD type tt:ImagingSettingsExtension204 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettingsExtension203 (611)
	virtual int soap_type(void) const { return 611; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettingsExtension203, default initialized and not managed by a soap context
	virtual tt__ImagingSettingsExtension203 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettingsExtension203); }
	         tt__ImagingSettingsExtension203() { tt__ImagingSettingsExtension203::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension203() { }
	friend SOAP_FMAC1 tt__ImagingSettingsExtension203 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension203(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1831 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension204
#define SOAP_TYPE_tt__ImagingSettingsExtension204 (612)
/* tt:ImagingSettingsExtension204 complex type: */
class SOAP_CMAC tt__ImagingSettingsExtension204
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettingsExtension204 (612)
	virtual int soap_type(void) const { return 612; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettingsExtension204, default initialized and not managed by a soap context
	virtual tt__ImagingSettingsExtension204 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettingsExtension204); }
	         tt__ImagingSettingsExtension204() { tt__ImagingSettingsExtension204::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension204() { }
	friend SOAP_FMAC1 tt__ImagingSettingsExtension204 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension204(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1834 */
#ifndef SOAP_TYPE_tt__ImageStabilization
#define SOAP_TYPE_tt__ImageStabilization (613)
/* tt:ImageStabilization complex type: */
class SOAP_CMAC tt__ImageStabilization
{
public:
	enum tt__ImageStabilizationMode Mode;	/* required element of XSD type tt:ImageStabilizationMode */
	float *Level;	/* optional element of XSD type xsd:float */
	tt__ImageStabilizationExtension *Extension;	/* optional element of XSD type tt:ImageStabilizationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImageStabilization (613)
	virtual int soap_type(void) const { return 613; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImageStabilization, default initialized and not managed by a soap context
	virtual tt__ImageStabilization *soap_alloc(void) const { return SOAP_NEW(tt__ImageStabilization); }
	         tt__ImageStabilization() { tt__ImageStabilization::soap_default(NULL); }
	virtual ~tt__ImageStabilization() { }
	friend SOAP_FMAC1 tt__ImageStabilization * SOAP_FMAC2 soap_instantiate_tt__ImageStabilization(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1837 */
#ifndef SOAP_TYPE_tt__ImageStabilizationExtension
#define SOAP_TYPE_tt__ImageStabilizationExtension (614)
/* tt:ImageStabilizationExtension complex type: */
class SOAP_CMAC tt__ImageStabilizationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImageStabilizationExtension (614)
	virtual int soap_type(void) const { return 614; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImageStabilizationExtension, default initialized and not managed by a soap context
	virtual tt__ImageStabilizationExtension *soap_alloc(void) const { return SOAP_NEW(tt__ImageStabilizationExtension); }
	         tt__ImageStabilizationExtension() { tt__ImageStabilizationExtension::soap_default(NULL); }
	virtual ~tt__ImageStabilizationExtension() { }
	friend SOAP_FMAC1 tt__ImageStabilizationExtension * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1840 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustment
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustment (615)
/* tt:IrCutFilterAutoAdjustment complex type: */
class SOAP_CMAC tt__IrCutFilterAutoAdjustment
{
public:
	std::string BoundaryType;	/* required element of XSD type xsd:string */
	float *BoundaryOffset;	/* optional element of XSD type xsd:float */
	LONG64 *ResponseTime;	/* optional element of XSD type xsd:duration */
	tt__IrCutFilterAutoAdjustmentExtension *Extension;	/* optional element of XSD type tt:IrCutFilterAutoAdjustmentExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IrCutFilterAutoAdjustment (615)
	virtual int soap_type(void) const { return 615; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IrCutFilterAutoAdjustment, default initialized and not managed by a soap context
	virtual tt__IrCutFilterAutoAdjustment *soap_alloc(void) const { return SOAP_NEW(tt__IrCutFilterAutoAdjustment); }
	         tt__IrCutFilterAutoAdjustment() { tt__IrCutFilterAutoAdjustment::soap_default(NULL); }
	virtual ~tt__IrCutFilterAutoAdjustment() { }
	friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustment * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1843 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension (616)
/* tt:IrCutFilterAutoAdjustmentExtension complex type: */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension (616)
	virtual int soap_type(void) const { return 616; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IrCutFilterAutoAdjustmentExtension, default initialized and not managed by a soap context
	virtual tt__IrCutFilterAutoAdjustmentExtension *soap_alloc(void) const { return SOAP_NEW(tt__IrCutFilterAutoAdjustmentExtension); }
	         tt__IrCutFilterAutoAdjustmentExtension() { tt__IrCutFilterAutoAdjustmentExtension::soap_default(NULL); }
	virtual ~tt__IrCutFilterAutoAdjustmentExtension() { }
	friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustmentExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1846 */
#ifndef SOAP_TYPE_tt__WideDynamicRange20
#define SOAP_TYPE_tt__WideDynamicRange20 (617)
/* tt:WideDynamicRange20 complex type: */
class SOAP_CMAC tt__WideDynamicRange20
{
public:
	enum tt__WideDynamicMode Mode;	/* required element of XSD type tt:WideDynamicMode */
	float *Level;	/* optional element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WideDynamicRange20 (617)
	virtual int soap_type(void) const { return 617; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WideDynamicRange20, default initialized and not managed by a soap context
	virtual tt__WideDynamicRange20 *soap_alloc(void) const { return SOAP_NEW(tt__WideDynamicRange20); }
	         tt__WideDynamicRange20() { tt__WideDynamicRange20::soap_default(NULL); }
	virtual ~tt__WideDynamicRange20() { }
	friend SOAP_FMAC1 tt__WideDynamicRange20 * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRange20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1849 */
#ifndef SOAP_TYPE_tt__BacklightCompensation20
#define SOAP_TYPE_tt__BacklightCompensation20 (618)
/* tt:BacklightCompensation20 complex type: */
class SOAP_CMAC tt__BacklightCompensation20
{
public:
	enum tt__BacklightCompensationMode Mode;	/* required element of XSD type tt:BacklightCompensationMode */
	float *Level;	/* optional element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BacklightCompensation20 (618)
	virtual int soap_type(void) const { return 618; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BacklightCompensation20, default initialized and not managed by a soap context
	virtual tt__BacklightCompensation20 *soap_alloc(void) const { return SOAP_NEW(tt__BacklightCompensation20); }
	         tt__BacklightCompensation20() { tt__BacklightCompensation20::soap_default(NULL); }
	virtual ~tt__BacklightCompensation20() { }
	friend SOAP_FMAC1 tt__BacklightCompensation20 * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensation20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1852 */
#ifndef SOAP_TYPE_tt__Exposure20
#define SOAP_TYPE_tt__Exposure20 (619)
/* tt:Exposure20 complex type: */
class SOAP_CMAC tt__Exposure20
{
public:
	enum tt__ExposureMode Mode;	/* required element of XSD type tt:ExposureMode */
	enum tt__ExposurePriority *Priority;	/* optional element of XSD type tt:ExposurePriority */
	tt__Rectangle *Window;	/* optional element of XSD type tt:Rectangle */
	float *MinExposureTime;	/* optional element of XSD type xsd:float */
	float *MaxExposureTime;	/* optional element of XSD type xsd:float */
	float *MinGain;	/* optional element of XSD type xsd:float */
	float *MaxGain;	/* optional element of XSD type xsd:float */
	float *MinIris;	/* optional element of XSD type xsd:float */
	float *MaxIris;	/* optional element of XSD type xsd:float */
	float *ExposureTime;	/* optional element of XSD type xsd:float */
	float *Gain;	/* optional element of XSD type xsd:float */
	float *Iris;	/* optional element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Exposure20 (619)
	virtual int soap_type(void) const { return 619; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Exposure20, default initialized and not managed by a soap context
	virtual tt__Exposure20 *soap_alloc(void) const { return SOAP_NEW(tt__Exposure20); }
	         tt__Exposure20() { tt__Exposure20::soap_default(NULL); }
	virtual ~tt__Exposure20() { }
	friend SOAP_FMAC1 tt__Exposure20 * SOAP_FMAC2 soap_instantiate_tt__Exposure20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1855 */
#ifndef SOAP_TYPE_tt__ToneCompensation
#define SOAP_TYPE_tt__ToneCompensation (620)
/* tt:ToneCompensation complex type: */
class SOAP_CMAC tt__ToneCompensation
{
public:
	std::string Mode;	/* required element of XSD type xsd:string */
	float *Level;	/* optional element of XSD type xsd:float */
	tt__ToneCompensationExtension *Extension;	/* optional element of XSD type tt:ToneCompensationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ToneCompensation (620)
	virtual int soap_type(void) const { return 620; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ToneCompensation, default initialized and not managed by a soap context
	virtual tt__ToneCompensation *soap_alloc(void) const { return SOAP_NEW(tt__ToneCompensation); }
	         tt__ToneCompensation() { tt__ToneCompensation::soap_default(NULL); }
	virtual ~tt__ToneCompensation() { }
	friend SOAP_FMAC1 tt__ToneCompensation * SOAP_FMAC2 soap_instantiate_tt__ToneCompensation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1858 */
#ifndef SOAP_TYPE_tt__ToneCompensationExtension
#define SOAP_TYPE_tt__ToneCompensationExtension (621)
/* tt:ToneCompensationExtension complex type: */
class SOAP_CMAC tt__ToneCompensationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ToneCompensationExtension (621)
	virtual int soap_type(void) const { return 621; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ToneCompensationExtension, default initialized and not managed by a soap context
	virtual tt__ToneCompensationExtension *soap_alloc(void) const { return SOAP_NEW(tt__ToneCompensationExtension); }
	         tt__ToneCompensationExtension() { tt__ToneCompensationExtension::soap_default(NULL); }
	virtual ~tt__ToneCompensationExtension() { }
	friend SOAP_FMAC1 tt__ToneCompensationExtension * SOAP_FMAC2 soap_instantiate_tt__ToneCompensationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1861 */
#ifndef SOAP_TYPE_tt__Defogging
#define SOAP_TYPE_tt__Defogging (622)
/* tt:Defogging complex type: */
class SOAP_CMAC tt__Defogging
{
public:
	std::string Mode;	/* required element of XSD type xsd:string */
	float *Level;	/* optional element of XSD type xsd:float */
	tt__DefoggingExtension *Extension;	/* optional element of XSD type tt:DefoggingExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Defogging (622)
	virtual int soap_type(void) const { return 622; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Defogging, default initialized and not managed by a soap context
	virtual tt__Defogging *soap_alloc(void) const { return SOAP_NEW(tt__Defogging); }
	         tt__Defogging() { tt__Defogging::soap_default(NULL); }
	virtual ~tt__Defogging() { }
	friend SOAP_FMAC1 tt__Defogging * SOAP_FMAC2 soap_instantiate_tt__Defogging(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1864 */
#ifndef SOAP_TYPE_tt__DefoggingExtension
#define SOAP_TYPE_tt__DefoggingExtension (623)
/* tt:DefoggingExtension complex type: */
class SOAP_CMAC tt__DefoggingExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DefoggingExtension (623)
	virtual int soap_type(void) const { return 623; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DefoggingExtension, default initialized and not managed by a soap context
	virtual tt__DefoggingExtension *soap_alloc(void) const { return SOAP_NEW(tt__DefoggingExtension); }
	         tt__DefoggingExtension() { tt__DefoggingExtension::soap_default(NULL); }
	virtual ~tt__DefoggingExtension() { }
	friend SOAP_FMAC1 tt__DefoggingExtension * SOAP_FMAC2 soap_instantiate_tt__DefoggingExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1867 */
#ifndef SOAP_TYPE_tt__NoiseReduction
#define SOAP_TYPE_tt__NoiseReduction (624)
/* tt:NoiseReduction complex type: */
class SOAP_CMAC tt__NoiseReduction
{
public:
	float Level;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NoiseReduction (624)
	virtual int soap_type(void) const { return 624; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NoiseReduction, default initialized and not managed by a soap context
	virtual tt__NoiseReduction *soap_alloc(void) const { return SOAP_NEW(tt__NoiseReduction); }
	         tt__NoiseReduction() { tt__NoiseReduction::soap_default(NULL); }
	virtual ~tt__NoiseReduction() { }
	friend SOAP_FMAC1 tt__NoiseReduction * SOAP_FMAC2 soap_instantiate_tt__NoiseReduction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1870 */
#ifndef SOAP_TYPE_tt__ImagingOptions20
#define SOAP_TYPE_tt__ImagingOptions20 (625)
/* tt:ImagingOptions20 complex type: */
class SOAP_CMAC tt__ImagingOptions20
{
public:
	tt__BacklightCompensationOptions20 *BacklightCompensation;	/* optional element of XSD type tt:BacklightCompensationOptions20 */
	tt__FloatRange *Brightness;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *ColorSaturation;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *Contrast;	/* optional element of XSD type tt:FloatRange */
	tt__ExposureOptions20 *Exposure;	/* optional element of XSD type tt:ExposureOptions20 */
	tt__FocusOptions20 *Focus;	/* optional element of XSD type tt:FocusOptions20 */
	std::vector<enum tt__IrCutFilterMode> IrCutFilterModes;	/* optional element of XSD type tt:IrCutFilterMode */
	tt__FloatRange *Sharpness;	/* optional element of XSD type tt:FloatRange */
	tt__WideDynamicRangeOptions20 *WideDynamicRange;	/* optional element of XSD type tt:WideDynamicRangeOptions20 */
	tt__WhiteBalanceOptions20 *WhiteBalance;	/* optional element of XSD type tt:WhiteBalanceOptions20 */
	tt__ImagingOptions20Extension *Extension;	/* optional element of XSD type tt:ImagingOptions20Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions20 (625)
	virtual int soap_type(void) const { return 625; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions20, default initialized and not managed by a soap context
	virtual tt__ImagingOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions20); }
	         tt__ImagingOptions20() { tt__ImagingOptions20::soap_default(NULL); }
	virtual ~tt__ImagingOptions20() { }
	friend SOAP_FMAC1 tt__ImagingOptions20 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1873 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension
#define SOAP_TYPE_tt__ImagingOptions20Extension (626)
/* tt:ImagingOptions20Extension complex type: */
class SOAP_CMAC tt__ImagingOptions20Extension
{
public:
	tt__ImageStabilizationOptions *ImageStabilization;	/* optional element of XSD type tt:ImageStabilizationOptions */
	tt__ImagingOptions20Extension2 *Extension;	/* optional element of XSD type tt:ImagingOptions20Extension2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions20Extension (626)
	virtual int soap_type(void) const { return 626; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions20Extension, default initialized and not managed by a soap context
	virtual tt__ImagingOptions20Extension *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions20Extension); }
	         tt__ImagingOptions20Extension() { tt__ImagingOptions20Extension::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension() { }
	friend SOAP_FMAC1 tt__ImagingOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1876 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension2
#define SOAP_TYPE_tt__ImagingOptions20Extension2 (627)
/* tt:ImagingOptions20Extension2 complex type: */
class SOAP_CMAC tt__ImagingOptions20Extension2
{
public:
	tt__IrCutFilterAutoAdjustmentOptions *IrCutFilterAutoAdjustment;	/* optional element of XSD type tt:IrCutFilterAutoAdjustmentOptions */
	tt__ImagingOptions20Extension3 *Extension;	/* optional element of XSD type tt:ImagingOptions20Extension3 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions20Extension2 (627)
	virtual int soap_type(void) const { return 627; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions20Extension2, default initialized and not managed by a soap context
	virtual tt__ImagingOptions20Extension2 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions20Extension2); }
	         tt__ImagingOptions20Extension2() { tt__ImagingOptions20Extension2::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension2() { }
	friend SOAP_FMAC1 tt__ImagingOptions20Extension2 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1879 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension3
#define SOAP_TYPE_tt__ImagingOptions20Extension3 (628)
/* tt:ImagingOptions20Extension3 complex type: */
class SOAP_CMAC tt__ImagingOptions20Extension3
{
public:
	tt__ToneCompensationOptions *ToneCompensationOptions;	/* optional element of XSD type tt:ToneCompensationOptions */
	tt__DefoggingOptions *DefoggingOptions;	/* optional element of XSD type tt:DefoggingOptions */
	tt__NoiseReductionOptions *NoiseReductionOptions;	/* optional element of XSD type tt:NoiseReductionOptions */
	tt__ImagingOptions20Extension4 *Extension;	/* optional element of XSD type tt:ImagingOptions20Extension4 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions20Extension3 (628)
	virtual int soap_type(void) const { return 628; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions20Extension3, default initialized and not managed by a soap context
	virtual tt__ImagingOptions20Extension3 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions20Extension3); }
	         tt__ImagingOptions20Extension3() { tt__ImagingOptions20Extension3::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension3() { }
	friend SOAP_FMAC1 tt__ImagingOptions20Extension3 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1882 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension4
#define SOAP_TYPE_tt__ImagingOptions20Extension4 (629)
/* tt:ImagingOptions20Extension4 complex type: */
class SOAP_CMAC tt__ImagingOptions20Extension4
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions20Extension4 (629)
	virtual int soap_type(void) const { return 629; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions20Extension4, default initialized and not managed by a soap context
	virtual tt__ImagingOptions20Extension4 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions20Extension4); }
	         tt__ImagingOptions20Extension4() { tt__ImagingOptions20Extension4::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension4() { }
	friend SOAP_FMAC1 tt__ImagingOptions20Extension4 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension4(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1885 */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptions
#define SOAP_TYPE_tt__ImageStabilizationOptions (630)
/* tt:ImageStabilizationOptions complex type: */
class SOAP_CMAC tt__ImageStabilizationOptions
{
public:
	std::vector<enum tt__ImageStabilizationMode> Mode;	/* required element of XSD type tt:ImageStabilizationMode */
	tt__FloatRange *Level;	/* optional element of XSD type tt:FloatRange */
	tt__ImageStabilizationOptionsExtension *Extension;	/* optional element of XSD type tt:ImageStabilizationOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImageStabilizationOptions (630)
	virtual int soap_type(void) const { return 630; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImageStabilizationOptions, default initialized and not managed by a soap context
	virtual tt__ImageStabilizationOptions *soap_alloc(void) const { return SOAP_NEW(tt__ImageStabilizationOptions); }
	         tt__ImageStabilizationOptions() { tt__ImageStabilizationOptions::soap_default(NULL); }
	virtual ~tt__ImageStabilizationOptions() { }
	friend SOAP_FMAC1 tt__ImageStabilizationOptions * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1888 */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptionsExtension
#define SOAP_TYPE_tt__ImageStabilizationOptionsExtension (631)
/* tt:ImageStabilizationOptionsExtension complex type: */
class SOAP_CMAC tt__ImageStabilizationOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImageStabilizationOptionsExtension (631)
	virtual int soap_type(void) const { return 631; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImageStabilizationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__ImageStabilizationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__ImageStabilizationOptionsExtension); }
	         tt__ImageStabilizationOptionsExtension() { tt__ImageStabilizationOptionsExtension::soap_default(NULL); }
	virtual ~tt__ImageStabilizationOptionsExtension() { }
	friend SOAP_FMAC1 tt__ImageStabilizationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1891 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions (632)
/* tt:IrCutFilterAutoAdjustmentOptions complex type: */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentOptions
{
public:
	std::vector<std::string> BoundaryType;	/* required element of XSD type xsd:string */
	bool *BoundaryOffset;	/* optional element of XSD type xsd:boolean */
	tt__DurationRange *ResponseTimeRange;	/* optional element of XSD type tt:DurationRange */
	tt__IrCutFilterAutoAdjustmentOptionsExtension *Extension;	/* optional element of XSD type tt:IrCutFilterAutoAdjustmentOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions (632)
	virtual int soap_type(void) const { return 632; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IrCutFilterAutoAdjustmentOptions, default initialized and not managed by a soap context
	virtual tt__IrCutFilterAutoAdjustmentOptions *soap_alloc(void) const { return SOAP_NEW(tt__IrCutFilterAutoAdjustmentOptions); }
	         tt__IrCutFilterAutoAdjustmentOptions() { tt__IrCutFilterAutoAdjustmentOptions::soap_default(NULL); }
	virtual ~tt__IrCutFilterAutoAdjustmentOptions() { }
	friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustmentOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1894 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension (633)
/* tt:IrCutFilterAutoAdjustmentOptionsExtension complex type: */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension (633)
	virtual int soap_type(void) const { return 633; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IrCutFilterAutoAdjustmentOptionsExtension, default initialized and not managed by a soap context
	virtual tt__IrCutFilterAutoAdjustmentOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__IrCutFilterAutoAdjustmentOptionsExtension); }
	         tt__IrCutFilterAutoAdjustmentOptionsExtension() { tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_default(NULL); }
	virtual ~tt__IrCutFilterAutoAdjustmentOptionsExtension() { }
	friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1897 */
#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions20
#define SOAP_TYPE_tt__WideDynamicRangeOptions20 (634)
/* tt:WideDynamicRangeOptions20 complex type: */
class SOAP_CMAC tt__WideDynamicRangeOptions20
{
public:
	std::vector<enum tt__WideDynamicMode> Mode;	/* required element of XSD type tt:WideDynamicMode */
	tt__FloatRange *Level;	/* optional element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WideDynamicRangeOptions20 (634)
	virtual int soap_type(void) const { return 634; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WideDynamicRangeOptions20, default initialized and not managed by a soap context
	virtual tt__WideDynamicRangeOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__WideDynamicRangeOptions20); }
	         tt__WideDynamicRangeOptions20() { tt__WideDynamicRangeOptions20::soap_default(NULL); }
	virtual ~tt__WideDynamicRangeOptions20() { }
	friend SOAP_FMAC1 tt__WideDynamicRangeOptions20 * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRangeOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1900 */
#ifndef SOAP_TYPE_tt__BacklightCompensationOptions20
#define SOAP_TYPE_tt__BacklightCompensationOptions20 (635)
/* tt:BacklightCompensationOptions20 complex type: */
class SOAP_CMAC tt__BacklightCompensationOptions20
{
public:
	std::vector<enum tt__BacklightCompensationMode> Mode;	/* required element of XSD type tt:BacklightCompensationMode */
	tt__FloatRange *Level;	/* optional element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BacklightCompensationOptions20 (635)
	virtual int soap_type(void) const { return 635; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BacklightCompensationOptions20, default initialized and not managed by a soap context
	virtual tt__BacklightCompensationOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__BacklightCompensationOptions20); }
	         tt__BacklightCompensationOptions20() { tt__BacklightCompensationOptions20::soap_default(NULL); }
	virtual ~tt__BacklightCompensationOptions20() { }
	friend SOAP_FMAC1 tt__BacklightCompensationOptions20 * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensationOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1903 */
#ifndef SOAP_TYPE_tt__ExposureOptions20
#define SOAP_TYPE_tt__ExposureOptions20 (636)
/* tt:ExposureOptions20 complex type: */
class SOAP_CMAC tt__ExposureOptions20
{
public:
	std::vector<enum tt__ExposureMode> Mode;	/* required element of XSD type tt:ExposureMode */
	std::vector<enum tt__ExposurePriority> Priority;	/* optional element of XSD type tt:ExposurePriority */
	tt__FloatRange *MinExposureTime;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MaxExposureTime;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MinGain;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MaxGain;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MinIris;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MaxIris;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *ExposureTime;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *Gain;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *Iris;	/* optional element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ExposureOptions20 (636)
	virtual int soap_type(void) const { return 636; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ExposureOptions20, default initialized and not managed by a soap context
	virtual tt__ExposureOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__ExposureOptions20); }
	         tt__ExposureOptions20() { tt__ExposureOptions20::soap_default(NULL); }
	virtual ~tt__ExposureOptions20() { }
	friend SOAP_FMAC1 tt__ExposureOptions20 * SOAP_FMAC2 soap_instantiate_tt__ExposureOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1906 */
#ifndef SOAP_TYPE_tt__MoveOptions20
#define SOAP_TYPE_tt__MoveOptions20 (637)
/* tt:MoveOptions20 complex type: */
class SOAP_CMAC tt__MoveOptions20
{
public:
	tt__AbsoluteFocusOptions *Absolute;	/* optional element of XSD type tt:AbsoluteFocusOptions */
	tt__RelativeFocusOptions20 *Relative;	/* optional element of XSD type tt:RelativeFocusOptions20 */
	tt__ContinuousFocusOptions *Continuous;	/* optional element of XSD type tt:ContinuousFocusOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MoveOptions20 (637)
	virtual int soap_type(void) const { return 637; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MoveOptions20, default initialized and not managed by a soap context
	virtual tt__MoveOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__MoveOptions20); }
	         tt__MoveOptions20() { tt__MoveOptions20::soap_default(NULL); }
	virtual ~tt__MoveOptions20() { }
	friend SOAP_FMAC1 tt__MoveOptions20 * SOAP_FMAC2 soap_instantiate_tt__MoveOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1909 */
#ifndef SOAP_TYPE_tt__RelativeFocusOptions20
#define SOAP_TYPE_tt__RelativeFocusOptions20 (638)
/* tt:RelativeFocusOptions20 complex type: */
class SOAP_CMAC tt__RelativeFocusOptions20
{
public:
	tt__FloatRange *Distance;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Speed;	/* optional element of XSD type tt:FloatRange */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelativeFocusOptions20 (638)
	virtual int soap_type(void) const { return 638; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelativeFocusOptions20, default initialized and not managed by a soap context
	virtual tt__RelativeFocusOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__RelativeFocusOptions20); }
	         tt__RelativeFocusOptions20() { tt__RelativeFocusOptions20::soap_default(NULL); }
	virtual ~tt__RelativeFocusOptions20() { }
	friend SOAP_FMAC1 tt__RelativeFocusOptions20 * SOAP_FMAC2 soap_instantiate_tt__RelativeFocusOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1912 */
#ifndef SOAP_TYPE_tt__WhiteBalance20
#define SOAP_TYPE_tt__WhiteBalance20 (639)
/* tt:WhiteBalance20 complex type: */
class SOAP_CMAC tt__WhiteBalance20
{
public:
	enum tt__WhiteBalanceMode Mode;	/* required element of XSD type tt:WhiteBalanceMode */
	float *CrGain;	/* optional element of XSD type xsd:float */
	float *CbGain;	/* optional element of XSD type xsd:float */
	tt__WhiteBalance20Extension *Extension;	/* optional element of XSD type tt:WhiteBalance20Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalance20 (639)
	virtual int soap_type(void) const { return 639; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalance20, default initialized and not managed by a soap context
	virtual tt__WhiteBalance20 *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalance20); }
	         tt__WhiteBalance20() { tt__WhiteBalance20::soap_default(NULL); }
	virtual ~tt__WhiteBalance20() { }
	friend SOAP_FMAC1 tt__WhiteBalance20 * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1915 */
#ifndef SOAP_TYPE_tt__WhiteBalance20Extension
#define SOAP_TYPE_tt__WhiteBalance20Extension (640)
/* tt:WhiteBalance20Extension complex type: */
class SOAP_CMAC tt__WhiteBalance20Extension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalance20Extension (640)
	virtual int soap_type(void) const { return 640; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalance20Extension, default initialized and not managed by a soap context
	virtual tt__WhiteBalance20Extension *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalance20Extension); }
	         tt__WhiteBalance20Extension() { tt__WhiteBalance20Extension::soap_default(NULL); }
	virtual ~tt__WhiteBalance20Extension() { }
	friend SOAP_FMAC1 tt__WhiteBalance20Extension * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1918 */
#ifndef SOAP_TYPE_tt__FocusConfiguration20
#define SOAP_TYPE_tt__FocusConfiguration20 (641)
/* tt:FocusConfiguration20 complex type: */
class SOAP_CMAC tt__FocusConfiguration20
{
public:
	enum tt__AutoFocusMode AutoFocusMode;	/* required element of XSD type tt:AutoFocusMode */
	float *DefaultSpeed;	/* optional element of XSD type xsd:float */
	float *NearLimit;	/* optional element of XSD type xsd:float */
	float *FarLimit;	/* optional element of XSD type xsd:float */
	tt__FocusConfiguration20Extension *Extension;	/* optional element of XSD type tt:FocusConfiguration20Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusConfiguration20 (641)
	virtual int soap_type(void) const { return 641; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusConfiguration20, default initialized and not managed by a soap context
	virtual tt__FocusConfiguration20 *soap_alloc(void) const { return SOAP_NEW(tt__FocusConfiguration20); }
	         tt__FocusConfiguration20() { tt__FocusConfiguration20::soap_default(NULL); }
	virtual ~tt__FocusConfiguration20() { }
	friend SOAP_FMAC1 tt__FocusConfiguration20 * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1921 */
#ifndef SOAP_TYPE_tt__FocusConfiguration20Extension
#define SOAP_TYPE_tt__FocusConfiguration20Extension (642)
/* tt:FocusConfiguration20Extension complex type: */
class SOAP_CMAC tt__FocusConfiguration20Extension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusConfiguration20Extension (642)
	virtual int soap_type(void) const { return 642; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusConfiguration20Extension, default initialized and not managed by a soap context
	virtual tt__FocusConfiguration20Extension *soap_alloc(void) const { return SOAP_NEW(tt__FocusConfiguration20Extension); }
	         tt__FocusConfiguration20Extension() { tt__FocusConfiguration20Extension::soap_default(NULL); }
	virtual ~tt__FocusConfiguration20Extension() { }
	friend SOAP_FMAC1 tt__FocusConfiguration20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1924 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20
#define SOAP_TYPE_tt__WhiteBalanceOptions20 (643)
/* tt:WhiteBalanceOptions20 complex type: */
class SOAP_CMAC tt__WhiteBalanceOptions20
{
public:
	std::vector<enum tt__WhiteBalanceMode> Mode;	/* required element of XSD type tt:WhiteBalanceMode */
	tt__FloatRange *YrGain;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *YbGain;	/* optional element of XSD type tt:FloatRange */
	tt__WhiteBalanceOptions20Extension *Extension;	/* optional element of XSD type tt:WhiteBalanceOptions20Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalanceOptions20 (643)
	virtual int soap_type(void) const { return 643; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalanceOptions20, default initialized and not managed by a soap context
	virtual tt__WhiteBalanceOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalanceOptions20); }
	         tt__WhiteBalanceOptions20() { tt__WhiteBalanceOptions20::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions20() { }
	friend SOAP_FMAC1 tt__WhiteBalanceOptions20 * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1927 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20Extension
#define SOAP_TYPE_tt__WhiteBalanceOptions20Extension (644)
/* tt:WhiteBalanceOptions20Extension complex type: */
class SOAP_CMAC tt__WhiteBalanceOptions20Extension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalanceOptions20Extension (644)
	virtual int soap_type(void) const { return 644; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalanceOptions20Extension, default initialized and not managed by a soap context
	virtual tt__WhiteBalanceOptions20Extension *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalanceOptions20Extension); }
	         tt__WhiteBalanceOptions20Extension() { tt__WhiteBalanceOptions20Extension::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions20Extension() { }
	friend SOAP_FMAC1 tt__WhiteBalanceOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1930 */
#ifndef SOAP_TYPE_tt__FocusOptions20
#define SOAP_TYPE_tt__FocusOptions20 (645)
/* tt:FocusOptions20 complex type: */
class SOAP_CMAC tt__FocusOptions20
{
public:
	std::vector<enum tt__AutoFocusMode> AutoFocusModes;	/* optional element of XSD type tt:AutoFocusMode */
	tt__FloatRange *DefaultSpeed;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *NearLimit;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *FarLimit;	/* optional element of XSD type tt:FloatRange */
	tt__FocusOptions20Extension *Extension;	/* optional element of XSD type tt:FocusOptions20Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusOptions20 (645)
	virtual int soap_type(void) const { return 645; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusOptions20, default initialized and not managed by a soap context
	virtual tt__FocusOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__FocusOptions20); }
	         tt__FocusOptions20() { tt__FocusOptions20::soap_default(NULL); }
	virtual ~tt__FocusOptions20() { }
	friend SOAP_FMAC1 tt__FocusOptions20 * SOAP_FMAC2 soap_instantiate_tt__FocusOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1933 */
#ifndef SOAP_TYPE_tt__FocusOptions20Extension
#define SOAP_TYPE_tt__FocusOptions20Extension (646)
/* tt:FocusOptions20Extension complex type: */
class SOAP_CMAC tt__FocusOptions20Extension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusOptions20Extension (646)
	virtual int soap_type(void) const { return 646; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusOptions20Extension, default initialized and not managed by a soap context
	virtual tt__FocusOptions20Extension *soap_alloc(void) const { return SOAP_NEW(tt__FocusOptions20Extension); }
	         tt__FocusOptions20Extension() { tt__FocusOptions20Extension::soap_default(NULL); }
	virtual ~tt__FocusOptions20Extension() { }
	friend SOAP_FMAC1 tt__FocusOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1936 */
#ifndef SOAP_TYPE_tt__ToneCompensationOptions
#define SOAP_TYPE_tt__ToneCompensationOptions (647)
/* tt:ToneCompensationOptions complex type: */
class SOAP_CMAC tt__ToneCompensationOptions
{
public:
	std::vector<std::string> Mode;	/* required element of XSD type xsd:string */
	bool Level;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ToneCompensationOptions (647)
	virtual int soap_type(void) const { return 647; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ToneCompensationOptions, default initialized and not managed by a soap context
	virtual tt__ToneCompensationOptions *soap_alloc(void) const { return SOAP_NEW(tt__ToneCompensationOptions); }
	         tt__ToneCompensationOptions() { tt__ToneCompensationOptions::soap_default(NULL); }
	virtual ~tt__ToneCompensationOptions() { }
	friend SOAP_FMAC1 tt__ToneCompensationOptions * SOAP_FMAC2 soap_instantiate_tt__ToneCompensationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1939 */
#ifndef SOAP_TYPE_tt__DefoggingOptions
#define SOAP_TYPE_tt__DefoggingOptions (648)
/* tt:DefoggingOptions complex type: */
class SOAP_CMAC tt__DefoggingOptions
{
public:
	std::vector<std::string> Mode;	/* required element of XSD type xsd:string */
	bool Level;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DefoggingOptions (648)
	virtual int soap_type(void) const { return 648; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DefoggingOptions, default initialized and not managed by a soap context
	virtual tt__DefoggingOptions *soap_alloc(void) const { return SOAP_NEW(tt__DefoggingOptions); }
	         tt__DefoggingOptions() { tt__DefoggingOptions::soap_default(NULL); }
	virtual ~tt__DefoggingOptions() { }
	friend SOAP_FMAC1 tt__DefoggingOptions * SOAP_FMAC2 soap_instantiate_tt__DefoggingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1942 */
#ifndef SOAP_TYPE_tt__NoiseReductionOptions
#define SOAP_TYPE_tt__NoiseReductionOptions (649)
/* tt:NoiseReductionOptions complex type: */
class SOAP_CMAC tt__NoiseReductionOptions
{
public:
	bool Level;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NoiseReductionOptions (649)
	virtual int soap_type(void) const { return 649; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NoiseReductionOptions, default initialized and not managed by a soap context
	virtual tt__NoiseReductionOptions *soap_alloc(void) const { return SOAP_NEW(tt__NoiseReductionOptions); }
	         tt__NoiseReductionOptions() { tt__NoiseReductionOptions::soap_default(NULL); }
	virtual ~tt__NoiseReductionOptions() { }
	friend SOAP_FMAC1 tt__NoiseReductionOptions * SOAP_FMAC2 soap_instantiate_tt__NoiseReductionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1945 */
#ifndef SOAP_TYPE_tt__MessageExtension
#define SOAP_TYPE_tt__MessageExtension (650)
/* tt:MessageExtension complex type: */
class SOAP_CMAC tt__MessageExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MessageExtension (650)
	virtual int soap_type(void) const { return 650; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MessageExtension, default initialized and not managed by a soap context
	virtual tt__MessageExtension *soap_alloc(void) const { return SOAP_NEW(tt__MessageExtension); }
	         tt__MessageExtension() { tt__MessageExtension::soap_default(NULL); }
	virtual ~tt__MessageExtension() { }
	friend SOAP_FMAC1 tt__MessageExtension * SOAP_FMAC2 soap_instantiate_tt__MessageExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:20178 */
#ifndef SOAP_TYPE__tt__ItemList_SimpleItem
#define SOAP_TYPE__tt__ItemList_SimpleItem (1373)
/* tt:ItemList-SimpleItem complex type: */
class SOAP_CMAC _tt__ItemList_SimpleItem
{
public:
	std::string Name;	/* required attribute of XSD type xsd:string */
	std::string Value;	/* required attribute of XSD type xsd:anySimpleType */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ItemList_SimpleItem (1373)
	virtual int soap_type(void) const { return 1373; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ItemList_SimpleItem, default initialized and not managed by a soap context
	virtual _tt__ItemList_SimpleItem *soap_alloc(void) const { return SOAP_NEW(_tt__ItemList_SimpleItem); }
	         _tt__ItemList_SimpleItem() { _tt__ItemList_SimpleItem::soap_default(NULL); }
	virtual ~_tt__ItemList_SimpleItem() { }
	friend SOAP_FMAC1 _tt__ItemList_SimpleItem * SOAP_FMAC2 soap_instantiate__tt__ItemList_SimpleItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:20206 */
#ifndef SOAP_TYPE__tt__ItemList_ElementItem
#define SOAP_TYPE__tt__ItemList_ElementItem (1376)
/* tt:ItemList-ElementItem complex type: */
class SOAP_CMAC _tt__ItemList_ElementItem
{
public:
	std::string Name;	/* required attribute of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ItemList_ElementItem (1376)
	virtual int soap_type(void) const { return 1376; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ItemList_ElementItem, default initialized and not managed by a soap context
	virtual _tt__ItemList_ElementItem *soap_alloc(void) const { return SOAP_NEW(_tt__ItemList_ElementItem); }
	         _tt__ItemList_ElementItem() { _tt__ItemList_ElementItem::soap_default(NULL); }
	virtual ~_tt__ItemList_ElementItem() { }
	friend SOAP_FMAC1 _tt__ItemList_ElementItem * SOAP_FMAC2 soap_instantiate__tt__ItemList_ElementItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1948 */
#ifndef SOAP_TYPE_tt__ItemList
#define SOAP_TYPE_tt__ItemList (651)
/* tt:ItemList complex type: */
class SOAP_CMAC tt__ItemList
{
public:
	std::vector<_tt__ItemList_SimpleItem> *SimpleItem;	/* optional element of XSD type tt:ItemList-SimpleItem */
	std::vector<_tt__ItemList_ElementItem> *ElementItem;	/* optional element of XSD type tt:ItemList-ElementItem */
	tt__ItemListExtension *Extension;	/* optional element of XSD type tt:ItemListExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ItemList (651)
	virtual int soap_type(void) const { return 651; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ItemList, default initialized and not managed by a soap context
	virtual tt__ItemList *soap_alloc(void) const { return SOAP_NEW(tt__ItemList); }
	         tt__ItemList() { tt__ItemList::soap_default(NULL); }
	virtual ~tt__ItemList() { }
	friend SOAP_FMAC1 tt__ItemList * SOAP_FMAC2 soap_instantiate_tt__ItemList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1951 */
#ifndef SOAP_TYPE_tt__ItemListExtension
#define SOAP_TYPE_tt__ItemListExtension (652)
/* tt:ItemListExtension complex type: */
class SOAP_CMAC tt__ItemListExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ItemListExtension (652)
	virtual int soap_type(void) const { return 652; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ItemListExtension, default initialized and not managed by a soap context
	virtual tt__ItemListExtension *soap_alloc(void) const { return SOAP_NEW(tt__ItemListExtension); }
	         tt__ItemListExtension() { tt__ItemListExtension::soap_default(NULL); }
	virtual ~tt__ItemListExtension() { }
	friend SOAP_FMAC1 tt__ItemListExtension * SOAP_FMAC2 soap_instantiate_tt__ItemListExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1954 */
#ifndef SOAP_TYPE_tt__MessageDescription
#define SOAP_TYPE_tt__MessageDescription (653)
/* tt:MessageDescription complex type: */
class SOAP_CMAC tt__MessageDescription
{
public:
	tt__ItemListDescription *Source;	/* optional element of XSD type tt:ItemListDescription */
	tt__ItemListDescription *Key;	/* optional element of XSD type tt:ItemListDescription */
	tt__ItemListDescription *Data;	/* optional element of XSD type tt:ItemListDescription */
	tt__MessageDescriptionExtension *Extension;	/* optional element of XSD type tt:MessageDescriptionExtension */
	bool *IsProperty;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MessageDescription (653)
	virtual int soap_type(void) const { return 653; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MessageDescription, default initialized and not managed by a soap context
	virtual tt__MessageDescription *soap_alloc(void) const { return SOAP_NEW(tt__MessageDescription); }
	         tt__MessageDescription() { tt__MessageDescription::soap_default(NULL); }
	virtual ~tt__MessageDescription() { }
	friend SOAP_FMAC1 tt__MessageDescription * SOAP_FMAC2 soap_instantiate_tt__MessageDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1957 */
#ifndef SOAP_TYPE_tt__MessageDescriptionExtension
#define SOAP_TYPE_tt__MessageDescriptionExtension (654)
/* tt:MessageDescriptionExtension complex type: */
class SOAP_CMAC tt__MessageDescriptionExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MessageDescriptionExtension (654)
	virtual int soap_type(void) const { return 654; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MessageDescriptionExtension, default initialized and not managed by a soap context
	virtual tt__MessageDescriptionExtension *soap_alloc(void) const { return SOAP_NEW(tt__MessageDescriptionExtension); }
	         tt__MessageDescriptionExtension() { tt__MessageDescriptionExtension::soap_default(NULL); }
	virtual ~tt__MessageDescriptionExtension() { }
	friend SOAP_FMAC1 tt__MessageDescriptionExtension * SOAP_FMAC2 soap_instantiate_tt__MessageDescriptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:20359 */
#ifndef SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription
#define SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription (1382)
/* tt:ItemListDescription-SimpleItemDescription complex type: */
class SOAP_CMAC _tt__ItemListDescription_SimpleItemDescription
{
public:
	std::string Name;	/* required attribute of XSD type xsd:string */
	std::string Type;	/* required attribute of XSD type xsd:QName */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription (1382)
	virtual int soap_type(void) const { return 1382; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ItemListDescription_SimpleItemDescription, default initialized and not managed by a soap context
	virtual _tt__ItemListDescription_SimpleItemDescription *soap_alloc(void) const { return SOAP_NEW(_tt__ItemListDescription_SimpleItemDescription); }
	         _tt__ItemListDescription_SimpleItemDescription() { _tt__ItemListDescription_SimpleItemDescription::soap_default(NULL); }
	virtual ~_tt__ItemListDescription_SimpleItemDescription() { }
	friend SOAP_FMAC1 _tt__ItemListDescription_SimpleItemDescription * SOAP_FMAC2 soap_instantiate__tt__ItemListDescription_SimpleItemDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:20384 */
#ifndef SOAP_TYPE__tt__ItemListDescription_ElementItemDescription
#define SOAP_TYPE__tt__ItemListDescription_ElementItemDescription (1385)
/* tt:ItemListDescription-ElementItemDescription complex type: */
class SOAP_CMAC _tt__ItemListDescription_ElementItemDescription
{
public:
	std::string Name;	/* required attribute of XSD type xsd:string */
	std::string Type;	/* required attribute of XSD type xsd:QName */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ItemListDescription_ElementItemDescription (1385)
	virtual int soap_type(void) const { return 1385; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ItemListDescription_ElementItemDescription, default initialized and not managed by a soap context
	virtual _tt__ItemListDescription_ElementItemDescription *soap_alloc(void) const { return SOAP_NEW(_tt__ItemListDescription_ElementItemDescription); }
	         _tt__ItemListDescription_ElementItemDescription() { _tt__ItemListDescription_ElementItemDescription::soap_default(NULL); }
	virtual ~_tt__ItemListDescription_ElementItemDescription() { }
	friend SOAP_FMAC1 _tt__ItemListDescription_ElementItemDescription * SOAP_FMAC2 soap_instantiate__tt__ItemListDescription_ElementItemDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1960 */
#ifndef SOAP_TYPE_tt__ItemListDescription
#define SOAP_TYPE_tt__ItemListDescription (655)
/* tt:ItemListDescription complex type: */
class SOAP_CMAC tt__ItemListDescription
{
public:
	std::vector<_tt__ItemListDescription_SimpleItemDescription> *SimpleItemDescription;	/* optional element of XSD type tt:ItemListDescription-SimpleItemDescription */
	std::vector<_tt__ItemListDescription_ElementItemDescription> *ElementItemDescription;	/* optional element of XSD type tt:ItemListDescription-ElementItemDescription */
	tt__ItemListDescriptionExtension *Extension;	/* optional element of XSD type tt:ItemListDescriptionExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ItemListDescription (655)
	virtual int soap_type(void) const { return 655; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ItemListDescription, default initialized and not managed by a soap context
	virtual tt__ItemListDescription *soap_alloc(void) const { return SOAP_NEW(tt__ItemListDescription); }
	         tt__ItemListDescription() { tt__ItemListDescription::soap_default(NULL); }
	virtual ~tt__ItemListDescription() { }
	friend SOAP_FMAC1 tt__ItemListDescription * SOAP_FMAC2 soap_instantiate_tt__ItemListDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1963 */
#ifndef SOAP_TYPE_tt__ItemListDescriptionExtension
#define SOAP_TYPE_tt__ItemListDescriptionExtension (656)
/* tt:ItemListDescriptionExtension complex type: */
class SOAP_CMAC tt__ItemListDescriptionExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ItemListDescriptionExtension (656)
	virtual int soap_type(void) const { return 656; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ItemListDescriptionExtension, default initialized and not managed by a soap context
	virtual tt__ItemListDescriptionExtension *soap_alloc(void) const { return SOAP_NEW(tt__ItemListDescriptionExtension); }
	         tt__ItemListDescriptionExtension() { tt__ItemListDescriptionExtension::soap_default(NULL); }
	virtual ~tt__ItemListDescriptionExtension() { }
	friend SOAP_FMAC1 tt__ItemListDescriptionExtension * SOAP_FMAC2 soap_instantiate_tt__ItemListDescriptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1966 */
#ifndef SOAP_TYPE_tt__Polyline
#define SOAP_TYPE_tt__Polyline (657)
/* tt:Polyline complex type: */
class SOAP_CMAC tt__Polyline
{
public:
	std::vector<tt__Vector *> Point;	/* required element of XSD type tt:Vector */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Polyline (657)
	virtual int soap_type(void) const { return 657; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Polyline, default initialized and not managed by a soap context
	virtual tt__Polyline *soap_alloc(void) const { return SOAP_NEW(tt__Polyline); }
	         tt__Polyline() { tt__Polyline::soap_default(NULL); }
	virtual ~tt__Polyline() { }
	friend SOAP_FMAC1 tt__Polyline * SOAP_FMAC2 soap_instantiate_tt__Polyline(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1969 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsEngineConfiguration (658)
/* tt:AnalyticsEngineConfiguration complex type: */
class SOAP_CMAC tt__AnalyticsEngineConfiguration
{
public:
	std::vector<tt__Config *> AnalyticsModule;	/* optional element of XSD type tt:Config */
	tt__AnalyticsEngineConfigurationExtension *Extension;	/* optional element of XSD type tt:AnalyticsEngineConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineConfiguration (658)
	virtual int soap_type(void) const { return 658; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineConfiguration, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineConfiguration); }
	         tt__AnalyticsEngineConfiguration() { tt__AnalyticsEngineConfiguration::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineConfiguration() { }
	friend SOAP_FMAC1 tt__AnalyticsEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1972 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension (659)
/* tt:AnalyticsEngineConfigurationExtension complex type: */
class SOAP_CMAC tt__AnalyticsEngineConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension (659)
	virtual int soap_type(void) const { return 659; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineConfigurationExtension); }
	         tt__AnalyticsEngineConfigurationExtension() { tt__AnalyticsEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineConfigurationExtension() { }
	friend SOAP_FMAC1 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1975 */
#ifndef SOAP_TYPE_tt__RuleEngineConfiguration
#define SOAP_TYPE_tt__RuleEngineConfiguration (660)
/* tt:RuleEngineConfiguration complex type: */
class SOAP_CMAC tt__RuleEngineConfiguration
{
public:
	std::vector<tt__Config *> Rule;	/* optional element of XSD type tt:Config */
	tt__RuleEngineConfigurationExtension *Extension;	/* optional element of XSD type tt:RuleEngineConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RuleEngineConfiguration (660)
	virtual int soap_type(void) const { return 660; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RuleEngineConfiguration, default initialized and not managed by a soap context
	virtual tt__RuleEngineConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__RuleEngineConfiguration); }
	         tt__RuleEngineConfiguration() { tt__RuleEngineConfiguration::soap_default(NULL); }
	virtual ~tt__RuleEngineConfiguration() { }
	friend SOAP_FMAC1 tt__RuleEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__RuleEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1978 */
#ifndef SOAP_TYPE_tt__RuleEngineConfigurationExtension
#define SOAP_TYPE_tt__RuleEngineConfigurationExtension (661)
/* tt:RuleEngineConfigurationExtension complex type: */
class SOAP_CMAC tt__RuleEngineConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RuleEngineConfigurationExtension (661)
	virtual int soap_type(void) const { return 661; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RuleEngineConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__RuleEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__RuleEngineConfigurationExtension); }
	         tt__RuleEngineConfigurationExtension() { tt__RuleEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__RuleEngineConfigurationExtension() { }
	friend SOAP_FMAC1 tt__RuleEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__RuleEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1981 */
#ifndef SOAP_TYPE_tt__Config
#define SOAP_TYPE_tt__Config (662)
/* tt:Config complex type: */
class SOAP_CMAC tt__Config
{
public:
	tt__ItemList *Parameters;	/* required element of XSD type tt:ItemList */
	std::string Name;	/* required attribute of XSD type xsd:string */
	std::string Type;	/* required attribute of XSD type xsd:QName */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Config (662)
	virtual int soap_type(void) const { return 662; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Config, default initialized and not managed by a soap context
	virtual tt__Config *soap_alloc(void) const { return SOAP_NEW(tt__Config); }
	         tt__Config() { tt__Config::soap_default(NULL); }
	virtual ~tt__Config() { }
	friend SOAP_FMAC1 tt__Config * SOAP_FMAC2 soap_instantiate_tt__Config(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:20626 */
#ifndef SOAP_TYPE__tt__ConfigDescription_Messages
#define SOAP_TYPE__tt__ConfigDescription_Messages (1396)
/* tt:ConfigDescription-Messages complex type: */
class SOAP_CMAC _tt__ConfigDescription_Messages
{
public:
	tt__ItemListDescription *Source;	/* optional element of XSD type tt:ItemListDescription */
	tt__ItemListDescription *Key;	/* optional element of XSD type tt:ItemListDescription */
	tt__ItemListDescription *Data;	/* optional element of XSD type tt:ItemListDescription */
	tt__MessageDescriptionExtension *Extension;	/* optional element of XSD type tt:MessageDescriptionExtension */
	bool *IsProperty;	/* optional attribute of XSD type xsd:boolean */
	std::string ParentTopic;	/* required element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ConfigDescription_Messages (1396)
	virtual int soap_type(void) const { return 1396; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ConfigDescription_Messages, default initialized and not managed by a soap context
	virtual _tt__ConfigDescription_Messages *soap_alloc(void) const { return SOAP_NEW(_tt__ConfigDescription_Messages); }
	         _tt__ConfigDescription_Messages() { _tt__ConfigDescription_Messages::soap_default(NULL); }
	virtual ~_tt__ConfigDescription_Messages() { }
	friend SOAP_FMAC1 _tt__ConfigDescription_Messages * SOAP_FMAC2 soap_instantiate__tt__ConfigDescription_Messages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1984 */
#ifndef SOAP_TYPE_tt__ConfigDescription
#define SOAP_TYPE_tt__ConfigDescription (663)
/* tt:ConfigDescription complex type: */
class SOAP_CMAC tt__ConfigDescription
{
public:
	tt__ItemListDescription *Parameters;	/* required element of XSD type tt:ItemListDescription */
	std::vector<_tt__ConfigDescription_Messages> *Messages;	/* optional element of XSD type tt:ConfigDescription-Messages */
	tt__ConfigDescriptionExtension *Extension;	/* optional element of XSD type tt:ConfigDescriptionExtension */
	std::string Name;	/* required attribute of XSD type xsd:QName */
	bool *fixed;	/* optional attribute of XSD type xsd:boolean */
	std::string *maxInstances;	/* optional attribute of XSD type xsd:integer */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ConfigDescription (663)
	virtual int soap_type(void) const { return 663; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ConfigDescription, default initialized and not managed by a soap context
	virtual tt__ConfigDescription *soap_alloc(void) const { return SOAP_NEW(tt__ConfigDescription); }
	         tt__ConfigDescription() { tt__ConfigDescription::soap_default(NULL); }
	virtual ~tt__ConfigDescription() { }
	friend SOAP_FMAC1 tt__ConfigDescription * SOAP_FMAC2 soap_instantiate_tt__ConfigDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1987 */
#ifndef SOAP_TYPE_tt__ConfigDescriptionExtension
#define SOAP_TYPE_tt__ConfigDescriptionExtension (664)
/* tt:ConfigDescriptionExtension complex type: */
class SOAP_CMAC tt__ConfigDescriptionExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ConfigDescriptionExtension (664)
	virtual int soap_type(void) const { return 664; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ConfigDescriptionExtension, default initialized and not managed by a soap context
	virtual tt__ConfigDescriptionExtension *soap_alloc(void) const { return SOAP_NEW(tt__ConfigDescriptionExtension); }
	         tt__ConfigDescriptionExtension() { tt__ConfigDescriptionExtension::soap_default(NULL); }
	virtual ~tt__ConfigDescriptionExtension() { }
	friend SOAP_FMAC1 tt__ConfigDescriptionExtension * SOAP_FMAC2 soap_instantiate_tt__ConfigDescriptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1990 */
#ifndef SOAP_TYPE_tt__SupportedRules
#define SOAP_TYPE_tt__SupportedRules (665)
/* tt:SupportedRules complex type: */
class SOAP_CMAC tt__SupportedRules
{
public:
	std::vector<std::string> RuleContentSchemaLocation;	/* optional element of XSD type xsd:anyURI */
	std::vector<tt__ConfigDescription *> RuleDescription;	/* optional element of XSD type tt:ConfigDescription */
	tt__SupportedRulesExtension *Extension;	/* optional element of XSD type tt:SupportedRulesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportedRules (665)
	virtual int soap_type(void) const { return 665; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportedRules, default initialized and not managed by a soap context
	virtual tt__SupportedRules *soap_alloc(void) const { return SOAP_NEW(tt__SupportedRules); }
	         tt__SupportedRules() { tt__SupportedRules::soap_default(NULL); }
	virtual ~tt__SupportedRules() { }
	friend SOAP_FMAC1 tt__SupportedRules * SOAP_FMAC2 soap_instantiate_tt__SupportedRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1993 */
#ifndef SOAP_TYPE_tt__SupportedRulesExtension
#define SOAP_TYPE_tt__SupportedRulesExtension (666)
/* tt:SupportedRulesExtension complex type: */
class SOAP_CMAC tt__SupportedRulesExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportedRulesExtension (666)
	virtual int soap_type(void) const { return 666; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportedRulesExtension, default initialized and not managed by a soap context
	virtual tt__SupportedRulesExtension *soap_alloc(void) const { return SOAP_NEW(tt__SupportedRulesExtension); }
	         tt__SupportedRulesExtension() { tt__SupportedRulesExtension::soap_default(NULL); }
	virtual ~tt__SupportedRulesExtension() { }
	friend SOAP_FMAC1 tt__SupportedRulesExtension * SOAP_FMAC2 soap_instantiate_tt__SupportedRulesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1996 */
#ifndef SOAP_TYPE_tt__SupportedAnalyticsModules
#define SOAP_TYPE_tt__SupportedAnalyticsModules (667)
/* tt:SupportedAnalyticsModules complex type: */
class SOAP_CMAC tt__SupportedAnalyticsModules
{
public:
	std::vector<std::string> AnalyticsModuleContentSchemaLocation;	/* optional element of XSD type xsd:anyURI */
	std::vector<tt__ConfigDescription *> AnalyticsModuleDescription;	/* optional element of XSD type tt:ConfigDescription */
	tt__SupportedAnalyticsModulesExtension *Extension;	/* optional element of XSD type tt:SupportedAnalyticsModulesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportedAnalyticsModules (667)
	virtual int soap_type(void) const { return 667; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportedAnalyticsModules, default initialized and not managed by a soap context
	virtual tt__SupportedAnalyticsModules *soap_alloc(void) const { return SOAP_NEW(tt__SupportedAnalyticsModules); }
	         tt__SupportedAnalyticsModules() { tt__SupportedAnalyticsModules::soap_default(NULL); }
	virtual ~tt__SupportedAnalyticsModules() { }
	friend SOAP_FMAC1 tt__SupportedAnalyticsModules * SOAP_FMAC2 soap_instantiate_tt__SupportedAnalyticsModules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1999 */
#ifndef SOAP_TYPE_tt__SupportedAnalyticsModulesExtension
#define SOAP_TYPE_tt__SupportedAnalyticsModulesExtension (668)
/* tt:SupportedAnalyticsModulesExtension complex type: */
class SOAP_CMAC tt__SupportedAnalyticsModulesExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportedAnalyticsModulesExtension (668)
	virtual int soap_type(void) const { return 668; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportedAnalyticsModulesExtension, default initialized and not managed by a soap context
	virtual tt__SupportedAnalyticsModulesExtension *soap_alloc(void) const { return SOAP_NEW(tt__SupportedAnalyticsModulesExtension); }
	         tt__SupportedAnalyticsModulesExtension() { tt__SupportedAnalyticsModulesExtension::soap_default(NULL); }
	virtual ~tt__SupportedAnalyticsModulesExtension() { }
	friend SOAP_FMAC1 tt__SupportedAnalyticsModulesExtension * SOAP_FMAC2 soap_instantiate_tt__SupportedAnalyticsModulesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2002 */
#ifndef SOAP_TYPE_tt__PolygonConfiguration
#define SOAP_TYPE_tt__PolygonConfiguration (669)
/* tt:PolygonConfiguration complex type: */
class SOAP_CMAC tt__PolygonConfiguration
{
public:
	tt__Polygon *Polygon;	/* required element of XSD type tt:Polygon */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PolygonConfiguration (669)
	virtual int soap_type(void) const { return 669; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PolygonConfiguration, default initialized and not managed by a soap context
	virtual tt__PolygonConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__PolygonConfiguration); }
	         tt__PolygonConfiguration() { tt__PolygonConfiguration::soap_default(NULL); }
	virtual ~tt__PolygonConfiguration() { }
	friend SOAP_FMAC1 tt__PolygonConfiguration * SOAP_FMAC2 soap_instantiate_tt__PolygonConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2005 */
#ifndef SOAP_TYPE_tt__PolylineArray
#define SOAP_TYPE_tt__PolylineArray (670)
/* tt:PolylineArray complex type: */
class SOAP_CMAC tt__PolylineArray
{
public:
	std::vector<tt__Polyline *> Segment;	/* required element of XSD type tt:Polyline */
	tt__PolylineArrayExtension *Extension;	/* optional element of XSD type tt:PolylineArrayExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PolylineArray (670)
	virtual int soap_type(void) const { return 670; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PolylineArray, default initialized and not managed by a soap context
	virtual tt__PolylineArray *soap_alloc(void) const { return SOAP_NEW(tt__PolylineArray); }
	         tt__PolylineArray() { tt__PolylineArray::soap_default(NULL); }
	virtual ~tt__PolylineArray() { }
	friend SOAP_FMAC1 tt__PolylineArray * SOAP_FMAC2 soap_instantiate_tt__PolylineArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2008 */
#ifndef SOAP_TYPE_tt__PolylineArrayExtension
#define SOAP_TYPE_tt__PolylineArrayExtension (671)
/* tt:PolylineArrayExtension complex type: */
class SOAP_CMAC tt__PolylineArrayExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PolylineArrayExtension (671)
	virtual int soap_type(void) const { return 671; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PolylineArrayExtension, default initialized and not managed by a soap context
	virtual tt__PolylineArrayExtension *soap_alloc(void) const { return SOAP_NEW(tt__PolylineArrayExtension); }
	         tt__PolylineArrayExtension() { tt__PolylineArrayExtension::soap_default(NULL); }
	virtual ~tt__PolylineArrayExtension() { }
	friend SOAP_FMAC1 tt__PolylineArrayExtension * SOAP_FMAC2 soap_instantiate_tt__PolylineArrayExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2011 */
#ifndef SOAP_TYPE_tt__PolylineArrayConfiguration
#define SOAP_TYPE_tt__PolylineArrayConfiguration (672)
/* tt:PolylineArrayConfiguration complex type: */
class SOAP_CMAC tt__PolylineArrayConfiguration
{
public:
	tt__PolylineArray *PolylineArray;	/* required element of XSD type tt:PolylineArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PolylineArrayConfiguration (672)
	virtual int soap_type(void) const { return 672; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PolylineArrayConfiguration, default initialized and not managed by a soap context
	virtual tt__PolylineArrayConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__PolylineArrayConfiguration); }
	         tt__PolylineArrayConfiguration() { tt__PolylineArrayConfiguration::soap_default(NULL); }
	virtual ~tt__PolylineArrayConfiguration() { }
	friend SOAP_FMAC1 tt__PolylineArrayConfiguration * SOAP_FMAC2 soap_instantiate_tt__PolylineArrayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2014 */
#ifndef SOAP_TYPE_tt__MotionExpression
#define SOAP_TYPE_tt__MotionExpression (673)
/* tt:MotionExpression complex type: */
class SOAP_CMAC tt__MotionExpression
{
public:
	std::string Expression;	/* required element of XSD type xsd:string */
	std::string *Type;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MotionExpression (673)
	virtual int soap_type(void) const { return 673; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MotionExpression, default initialized and not managed by a soap context
	virtual tt__MotionExpression *soap_alloc(void) const { return SOAP_NEW(tt__MotionExpression); }
	         tt__MotionExpression() { tt__MotionExpression::soap_default(NULL); }
	virtual ~tt__MotionExpression() { }
	friend SOAP_FMAC1 tt__MotionExpression * SOAP_FMAC2 soap_instantiate_tt__MotionExpression(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2017 */
#ifndef SOAP_TYPE_tt__MotionExpressionConfiguration
#define SOAP_TYPE_tt__MotionExpressionConfiguration (674)
/* tt:MotionExpressionConfiguration complex type: */
class SOAP_CMAC tt__MotionExpressionConfiguration
{
public:
	tt__MotionExpression *MotionExpression;	/* required element of XSD type tt:MotionExpression */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MotionExpressionConfiguration (674)
	virtual int soap_type(void) const { return 674; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MotionExpressionConfiguration, default initialized and not managed by a soap context
	virtual tt__MotionExpressionConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__MotionExpressionConfiguration); }
	         tt__MotionExpressionConfiguration() { tt__MotionExpressionConfiguration::soap_default(NULL); }
	virtual ~tt__MotionExpressionConfiguration() { }
	friend SOAP_FMAC1 tt__MotionExpressionConfiguration * SOAP_FMAC2 soap_instantiate_tt__MotionExpressionConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2020 */
#ifndef SOAP_TYPE_tt__CellLayout
#define SOAP_TYPE_tt__CellLayout (675)
/* tt:CellLayout complex type: */
class SOAP_CMAC tt__CellLayout
{
public:
	tt__Transformation *Transformation;	/* required element of XSD type tt:Transformation */
	std::string Columns;	/* required attribute of XSD type xsd:integer */
	std::string Rows;	/* required attribute of XSD type xsd:integer */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CellLayout (675)
	virtual int soap_type(void) const { return 675; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CellLayout, default initialized and not managed by a soap context
	virtual tt__CellLayout *soap_alloc(void) const { return SOAP_NEW(tt__CellLayout); }
	         tt__CellLayout() { tt__CellLayout::soap_default(NULL); }
	virtual ~tt__CellLayout() { }
	friend SOAP_FMAC1 tt__CellLayout * SOAP_FMAC2 soap_instantiate_tt__CellLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2023 */
#ifndef SOAP_TYPE_tt__PaneConfiguration
#define SOAP_TYPE_tt__PaneConfiguration (676)
/* tt:PaneConfiguration complex type: */
class SOAP_CMAC tt__PaneConfiguration
{
public:
	std::string *PaneName;	/* optional element of XSD type xsd:string */
	std::string *AudioOutputToken;	/* optional element of XSD type tt:ReferenceToken */
	std::string *AudioSourceToken;	/* optional element of XSD type tt:ReferenceToken */
	tt__AudioEncoderConfiguration *AudioEncoderConfiguration;	/* optional element of XSD type tt:AudioEncoderConfiguration */
	std::string *ReceiverToken;	/* optional element of XSD type tt:ReferenceToken */
	std::string Token;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PaneConfiguration (676)
	virtual int soap_type(void) const { return 676; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PaneConfiguration, default initialized and not managed by a soap context
	virtual tt__PaneConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__PaneConfiguration); }
	         tt__PaneConfiguration() { tt__PaneConfiguration::soap_default(NULL); }
	virtual ~tt__PaneConfiguration() { }
	friend SOAP_FMAC1 tt__PaneConfiguration * SOAP_FMAC2 soap_instantiate_tt__PaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2026 */
#ifndef SOAP_TYPE_tt__PaneLayout
#define SOAP_TYPE_tt__PaneLayout (677)
/* tt:PaneLayout complex type: */
class SOAP_CMAC tt__PaneLayout
{
public:
	std::string Pane;	/* required element of XSD type tt:ReferenceToken */
	tt__Rectangle *Area;	/* required element of XSD type tt:Rectangle */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PaneLayout (677)
	virtual int soap_type(void) const { return 677; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PaneLayout, default initialized and not managed by a soap context
	virtual tt__PaneLayout *soap_alloc(void) const { return SOAP_NEW(tt__PaneLayout); }
	         tt__PaneLayout() { tt__PaneLayout::soap_default(NULL); }
	virtual ~tt__PaneLayout() { }
	friend SOAP_FMAC1 tt__PaneLayout * SOAP_FMAC2 soap_instantiate_tt__PaneLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2029 */
#ifndef SOAP_TYPE_tt__Layout
#define SOAP_TYPE_tt__Layout (678)
/* tt:Layout complex type: */
class SOAP_CMAC tt__Layout
{
public:
	std::vector<tt__PaneLayout *> PaneLayout;	/* required element of XSD type tt:PaneLayout */
	tt__LayoutExtension *Extension;	/* optional element of XSD type tt:LayoutExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Layout (678)
	virtual int soap_type(void) const { return 678; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Layout, default initialized and not managed by a soap context
	virtual tt__Layout *soap_alloc(void) const { return SOAP_NEW(tt__Layout); }
	         tt__Layout() { tt__Layout::soap_default(NULL); }
	virtual ~tt__Layout() { }
	friend SOAP_FMAC1 tt__Layout * SOAP_FMAC2 soap_instantiate_tt__Layout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2032 */
#ifndef SOAP_TYPE_tt__LayoutExtension
#define SOAP_TYPE_tt__LayoutExtension (679)
/* tt:LayoutExtension complex type: */
class SOAP_CMAC tt__LayoutExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LayoutExtension (679)
	virtual int soap_type(void) const { return 679; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LayoutExtension, default initialized and not managed by a soap context
	virtual tt__LayoutExtension *soap_alloc(void) const { return SOAP_NEW(tt__LayoutExtension); }
	         tt__LayoutExtension() { tt__LayoutExtension::soap_default(NULL); }
	virtual ~tt__LayoutExtension() { }
	friend SOAP_FMAC1 tt__LayoutExtension * SOAP_FMAC2 soap_instantiate_tt__LayoutExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2035 */
#ifndef SOAP_TYPE_tt__CodingCapabilities
#define SOAP_TYPE_tt__CodingCapabilities (680)
/* tt:CodingCapabilities complex type: */
class SOAP_CMAC tt__CodingCapabilities
{
public:
	tt__AudioEncoderConfigurationOptions *AudioEncodingCapabilities;	/* optional element of XSD type tt:AudioEncoderConfigurationOptions */
	tt__AudioDecoderConfigurationOptions *AudioDecodingCapabilities;	/* optional element of XSD type tt:AudioDecoderConfigurationOptions */
	tt__VideoDecoderConfigurationOptions *VideoDecodingCapabilities;	/* required element of XSD type tt:VideoDecoderConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CodingCapabilities (680)
	virtual int soap_type(void) const { return 680; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CodingCapabilities, default initialized and not managed by a soap context
	virtual tt__CodingCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__CodingCapabilities); }
	         tt__CodingCapabilities() { tt__CodingCapabilities::soap_default(NULL); }
	virtual ~tt__CodingCapabilities() { }
	friend SOAP_FMAC1 tt__CodingCapabilities * SOAP_FMAC2 soap_instantiate_tt__CodingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2038 */
#ifndef SOAP_TYPE_tt__LayoutOptions
#define SOAP_TYPE_tt__LayoutOptions (681)
/* tt:LayoutOptions complex type: */
class SOAP_CMAC tt__LayoutOptions
{
public:
	std::vector<tt__PaneLayoutOptions *> PaneLayoutOptions;	/* required element of XSD type tt:PaneLayoutOptions */
	tt__LayoutOptionsExtension *Extension;	/* optional element of XSD type tt:LayoutOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LayoutOptions (681)
	virtual int soap_type(void) const { return 681; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LayoutOptions, default initialized and not managed by a soap context
	virtual tt__LayoutOptions *soap_alloc(void) const { return SOAP_NEW(tt__LayoutOptions); }
	         tt__LayoutOptions() { tt__LayoutOptions::soap_default(NULL); }
	virtual ~tt__LayoutOptions() { }
	friend SOAP_FMAC1 tt__LayoutOptions * SOAP_FMAC2 soap_instantiate_tt__LayoutOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2041 */
#ifndef SOAP_TYPE_tt__LayoutOptionsExtension
#define SOAP_TYPE_tt__LayoutOptionsExtension (682)
/* tt:LayoutOptionsExtension complex type: */
class SOAP_CMAC tt__LayoutOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LayoutOptionsExtension (682)
	virtual int soap_type(void) const { return 682; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LayoutOptionsExtension, default initialized and not managed by a soap context
	virtual tt__LayoutOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__LayoutOptionsExtension); }
	         tt__LayoutOptionsExtension() { tt__LayoutOptionsExtension::soap_default(NULL); }
	virtual ~tt__LayoutOptionsExtension() { }
	friend SOAP_FMAC1 tt__LayoutOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__LayoutOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2044 */
#ifndef SOAP_TYPE_tt__PaneLayoutOptions
#define SOAP_TYPE_tt__PaneLayoutOptions (683)
/* tt:PaneLayoutOptions complex type: */
class SOAP_CMAC tt__PaneLayoutOptions
{
public:
	std::vector<tt__Rectangle *> Area;	/* required element of XSD type tt:Rectangle */
	tt__PaneOptionExtension *Extension;	/* optional element of XSD type tt:PaneOptionExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PaneLayoutOptions (683)
	virtual int soap_type(void) const { return 683; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PaneLayoutOptions, default initialized and not managed by a soap context
	virtual tt__PaneLayoutOptions *soap_alloc(void) const { return SOAP_NEW(tt__PaneLayoutOptions); }
	         tt__PaneLayoutOptions() { tt__PaneLayoutOptions::soap_default(NULL); }
	virtual ~tt__PaneLayoutOptions() { }
	friend SOAP_FMAC1 tt__PaneLayoutOptions * SOAP_FMAC2 soap_instantiate_tt__PaneLayoutOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2047 */
#ifndef SOAP_TYPE_tt__PaneOptionExtension
#define SOAP_TYPE_tt__PaneOptionExtension (684)
/* tt:PaneOptionExtension complex type: */
class SOAP_CMAC tt__PaneOptionExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PaneOptionExtension (684)
	virtual int soap_type(void) const { return 684; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PaneOptionExtension, default initialized and not managed by a soap context
	virtual tt__PaneOptionExtension *soap_alloc(void) const { return SOAP_NEW(tt__PaneOptionExtension); }
	         tt__PaneOptionExtension() { tt__PaneOptionExtension::soap_default(NULL); }
	virtual ~tt__PaneOptionExtension() { }
	friend SOAP_FMAC1 tt__PaneOptionExtension * SOAP_FMAC2 soap_instantiate_tt__PaneOptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2050 */
#ifndef SOAP_TYPE_tt__Receiver
#define SOAP_TYPE_tt__Receiver (685)
/* tt:Receiver complex type: */
class SOAP_CMAC tt__Receiver
{
public:
	std::string Token;	/* required element of XSD type tt:ReferenceToken */
	tt__ReceiverConfiguration *Configuration;	/* required element of XSD type tt:ReceiverConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Receiver (685)
	virtual int soap_type(void) const { return 685; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Receiver, default initialized and not managed by a soap context
	virtual tt__Receiver *soap_alloc(void) const { return SOAP_NEW(tt__Receiver); }
	         tt__Receiver() { tt__Receiver::soap_default(NULL); }
	virtual ~tt__Receiver() { }
	friend SOAP_FMAC1 tt__Receiver * SOAP_FMAC2 soap_instantiate_tt__Receiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2053 */
#ifndef SOAP_TYPE_tt__ReceiverConfiguration
#define SOAP_TYPE_tt__ReceiverConfiguration (686)
/* tt:ReceiverConfiguration complex type: */
class SOAP_CMAC tt__ReceiverConfiguration
{
public:
	enum tt__ReceiverMode Mode;	/* required element of XSD type tt:ReceiverMode */
	std::string MediaUri;	/* required element of XSD type xsd:anyURI */
	tt__StreamSetup *StreamSetup;	/* required element of XSD type tt:StreamSetup */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReceiverConfiguration (686)
	virtual int soap_type(void) const { return 686; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReceiverConfiguration, default initialized and not managed by a soap context
	virtual tt__ReceiverConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__ReceiverConfiguration); }
	         tt__ReceiverConfiguration() { tt__ReceiverConfiguration::soap_default(NULL); }
	virtual ~tt__ReceiverConfiguration() { }
	friend SOAP_FMAC1 tt__ReceiverConfiguration * SOAP_FMAC2 soap_instantiate_tt__ReceiverConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2056 */
#ifndef SOAP_TYPE_tt__ReceiverStateInformation
#define SOAP_TYPE_tt__ReceiverStateInformation (687)
/* tt:ReceiverStateInformation complex type: */
class SOAP_CMAC tt__ReceiverStateInformation
{
public:
	enum tt__ReceiverState State;	/* required element of XSD type tt:ReceiverState */
	bool AutoCreated;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReceiverStateInformation (687)
	virtual int soap_type(void) const { return 687; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReceiverStateInformation, default initialized and not managed by a soap context
	virtual tt__ReceiverStateInformation *soap_alloc(void) const { return SOAP_NEW(tt__ReceiverStateInformation); }
	         tt__ReceiverStateInformation() { tt__ReceiverStateInformation::soap_default(NULL); }
	virtual ~tt__ReceiverStateInformation() { }
	friend SOAP_FMAC1 tt__ReceiverStateInformation * SOAP_FMAC2 soap_instantiate_tt__ReceiverStateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2059 */
#ifndef SOAP_TYPE_tt__SourceReference
#define SOAP_TYPE_tt__SourceReference (688)
/* tt:SourceReference complex type: */
class SOAP_CMAC tt__SourceReference
{
public:
	std::string Token;	/* required element of XSD type tt:ReferenceToken */
	std::string Type;	/* optional attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SourceReference (688)
	virtual int soap_type(void) const { return 688; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SourceReference, default initialized and not managed by a soap context
	virtual tt__SourceReference *soap_alloc(void) const { return SOAP_NEW(tt__SourceReference); }
	         tt__SourceReference() { tt__SourceReference::soap_default(NULL); }
	virtual ~tt__SourceReference() { }
	friend SOAP_FMAC1 tt__SourceReference * SOAP_FMAC2 soap_instantiate_tt__SourceReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2062 */
#ifndef SOAP_TYPE_tt__DateTimeRange
#define SOAP_TYPE_tt__DateTimeRange (689)
/* tt:DateTimeRange complex type: */
class SOAP_CMAC tt__DateTimeRange
{
public:
	time_t From;	/* required element of XSD type xsd:dateTime */
	time_t Until;	/* required element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DateTimeRange (689)
	virtual int soap_type(void) const { return 689; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DateTimeRange, default initialized and not managed by a soap context
	virtual tt__DateTimeRange *soap_alloc(void) const { return SOAP_NEW(tt__DateTimeRange); }
	         tt__DateTimeRange() { tt__DateTimeRange::soap_default(NULL); }
	virtual ~tt__DateTimeRange() { }
	friend SOAP_FMAC1 tt__DateTimeRange * SOAP_FMAC2 soap_instantiate_tt__DateTimeRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2065 */
#ifndef SOAP_TYPE_tt__RecordingSummary
#define SOAP_TYPE_tt__RecordingSummary (690)
/* tt:RecordingSummary complex type: */
class SOAP_CMAC tt__RecordingSummary
{
public:
	time_t DataFrom;	/* required element of XSD type xsd:dateTime */
	time_t DataUntil;	/* required element of XSD type xsd:dateTime */
	int NumberRecordings;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingSummary (690)
	virtual int soap_type(void) const { return 690; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingSummary, default initialized and not managed by a soap context
	virtual tt__RecordingSummary *soap_alloc(void) const { return SOAP_NEW(tt__RecordingSummary); }
	         tt__RecordingSummary() { tt__RecordingSummary::soap_default(NULL); }
	virtual ~tt__RecordingSummary() { }
	friend SOAP_FMAC1 tt__RecordingSummary * SOAP_FMAC2 soap_instantiate_tt__RecordingSummary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2068 */
#ifndef SOAP_TYPE_tt__SearchScope
#define SOAP_TYPE_tt__SearchScope (691)
/* tt:SearchScope complex type: */
class SOAP_CMAC tt__SearchScope
{
public:
	std::vector<tt__SourceReference *> IncludedSources;	/* optional element of XSD type tt:SourceReference */
	std::vector<std::string> IncludedRecordings;	/* optional element of XSD type tt:RecordingReference */
	std::string *RecordingInformationFilter;	/* optional element of XSD type tt:XPathExpression */
	tt__SearchScopeExtension *Extension;	/* optional element of XSD type tt:SearchScopeExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SearchScope (691)
	virtual int soap_type(void) const { return 691; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SearchScope, default initialized and not managed by a soap context
	virtual tt__SearchScope *soap_alloc(void) const { return SOAP_NEW(tt__SearchScope); }
	         tt__SearchScope() { tt__SearchScope::soap_default(NULL); }
	virtual ~tt__SearchScope() { }
	friend SOAP_FMAC1 tt__SearchScope * SOAP_FMAC2 soap_instantiate_tt__SearchScope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2071 */
#ifndef SOAP_TYPE_tt__SearchScopeExtension
#define SOAP_TYPE_tt__SearchScopeExtension (692)
/* tt:SearchScopeExtension complex type: */
class SOAP_CMAC tt__SearchScopeExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SearchScopeExtension (692)
	virtual int soap_type(void) const { return 692; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SearchScopeExtension, default initialized and not managed by a soap context
	virtual tt__SearchScopeExtension *soap_alloc(void) const { return SOAP_NEW(tt__SearchScopeExtension); }
	         tt__SearchScopeExtension() { tt__SearchScopeExtension::soap_default(NULL); }
	virtual ~tt__SearchScopeExtension() { }
	friend SOAP_FMAC1 tt__SearchScopeExtension * SOAP_FMAC2 soap_instantiate_tt__SearchScopeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2077 */
#ifndef SOAP_TYPE_tt__PTZPositionFilter
#define SOAP_TYPE_tt__PTZPositionFilter (694)
/* tt:PTZPositionFilter complex type: */
class SOAP_CMAC tt__PTZPositionFilter
{
public:
	tt__PTZVector *MinPosition;	/* required element of XSD type tt:PTZVector */
	tt__PTZVector *MaxPosition;	/* required element of XSD type tt:PTZVector */
	bool EnterOrExit;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPositionFilter (694)
	virtual int soap_type(void) const { return 694; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPositionFilter, default initialized and not managed by a soap context
	virtual tt__PTZPositionFilter *soap_alloc(void) const { return SOAP_NEW(tt__PTZPositionFilter); }
	         tt__PTZPositionFilter() { tt__PTZPositionFilter::soap_default(NULL); }
	virtual ~tt__PTZPositionFilter() { }
	friend SOAP_FMAC1 tt__PTZPositionFilter * SOAP_FMAC2 soap_instantiate_tt__PTZPositionFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2080 */
#ifndef SOAP_TYPE_tt__MetadataFilter
#define SOAP_TYPE_tt__MetadataFilter (695)
/* tt:MetadataFilter complex type: */
class SOAP_CMAC tt__MetadataFilter
{
public:
	std::string MetadataStreamFilter;	/* required element of XSD type tt:XPathExpression */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataFilter (695)
	virtual int soap_type(void) const { return 695; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataFilter, default initialized and not managed by a soap context
	virtual tt__MetadataFilter *soap_alloc(void) const { return SOAP_NEW(tt__MetadataFilter); }
	         tt__MetadataFilter() { tt__MetadataFilter::soap_default(NULL); }
	virtual ~tt__MetadataFilter() { }
	friend SOAP_FMAC1 tt__MetadataFilter * SOAP_FMAC2 soap_instantiate_tt__MetadataFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2083 */
#ifndef SOAP_TYPE_tt__FindRecordingResultList
#define SOAP_TYPE_tt__FindRecordingResultList (696)
/* tt:FindRecordingResultList complex type: */
class SOAP_CMAC tt__FindRecordingResultList
{
public:
	enum tt__SearchState SearchState;	/* required element of XSD type tt:SearchState */
	std::vector<tt__RecordingInformation *> RecordingInformation;	/* optional element of XSD type tt:RecordingInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindRecordingResultList (696)
	virtual int soap_type(void) const { return 696; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindRecordingResultList, default initialized and not managed by a soap context
	virtual tt__FindRecordingResultList *soap_alloc(void) const { return SOAP_NEW(tt__FindRecordingResultList); }
	         tt__FindRecordingResultList() { tt__FindRecordingResultList::soap_default(NULL); }
	virtual ~tt__FindRecordingResultList() { }
	friend SOAP_FMAC1 tt__FindRecordingResultList * SOAP_FMAC2 soap_instantiate_tt__FindRecordingResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2086 */
#ifndef SOAP_TYPE_tt__FindEventResultList
#define SOAP_TYPE_tt__FindEventResultList (697)
/* tt:FindEventResultList complex type: */
class SOAP_CMAC tt__FindEventResultList
{
public:
	enum tt__SearchState SearchState;	/* required element of XSD type tt:SearchState */
	std::vector<tt__FindEventResult *> Result;	/* optional element of XSD type tt:FindEventResult */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindEventResultList (697)
	virtual int soap_type(void) const { return 697; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindEventResultList, default initialized and not managed by a soap context
	virtual tt__FindEventResultList *soap_alloc(void) const { return SOAP_NEW(tt__FindEventResultList); }
	         tt__FindEventResultList() { tt__FindEventResultList::soap_default(NULL); }
	virtual ~tt__FindEventResultList() { }
	friend SOAP_FMAC1 tt__FindEventResultList * SOAP_FMAC2 soap_instantiate_tt__FindEventResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2089 */
#ifndef SOAP_TYPE_tt__FindEventResult
#define SOAP_TYPE_tt__FindEventResult (698)
/* tt:FindEventResult complex type: */
class SOAP_CMAC tt__FindEventResult
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	std::string TrackToken;	/* required element of XSD type tt:TrackReference */
	time_t Time;	/* required element of XSD type xsd:dateTime */
	wsnt__NotificationMessageHolderType *Event;	/* required element of XSD type wsnt:NotificationMessageHolderType */
	bool StartStateEvent;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindEventResult (698)
	virtual int soap_type(void) const { return 698; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindEventResult, default initialized and not managed by a soap context
	virtual tt__FindEventResult *soap_alloc(void) const { return SOAP_NEW(tt__FindEventResult); }
	         tt__FindEventResult() { tt__FindEventResult::soap_default(NULL); }
	virtual ~tt__FindEventResult() { }
	friend SOAP_FMAC1 tt__FindEventResult * SOAP_FMAC2 soap_instantiate_tt__FindEventResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2092 */
#ifndef SOAP_TYPE_tt__FindPTZPositionResultList
#define SOAP_TYPE_tt__FindPTZPositionResultList (699)
/* tt:FindPTZPositionResultList complex type: */
class SOAP_CMAC tt__FindPTZPositionResultList
{
public:
	enum tt__SearchState SearchState;	/* required element of XSD type tt:SearchState */
	std::vector<tt__FindPTZPositionResult *> Result;	/* optional element of XSD type tt:FindPTZPositionResult */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindPTZPositionResultList (699)
	virtual int soap_type(void) const { return 699; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindPTZPositionResultList, default initialized and not managed by a soap context
	virtual tt__FindPTZPositionResultList *soap_alloc(void) const { return SOAP_NEW(tt__FindPTZPositionResultList); }
	         tt__FindPTZPositionResultList() { tt__FindPTZPositionResultList::soap_default(NULL); }
	virtual ~tt__FindPTZPositionResultList() { }
	friend SOAP_FMAC1 tt__FindPTZPositionResultList * SOAP_FMAC2 soap_instantiate_tt__FindPTZPositionResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2095 */
#ifndef SOAP_TYPE_tt__FindPTZPositionResult
#define SOAP_TYPE_tt__FindPTZPositionResult (700)
/* tt:FindPTZPositionResult complex type: */
class SOAP_CMAC tt__FindPTZPositionResult
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	std::string TrackToken;	/* required element of XSD type tt:TrackReference */
	time_t Time;	/* required element of XSD type xsd:dateTime */
	tt__PTZVector *Position;	/* required element of XSD type tt:PTZVector */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindPTZPositionResult (700)
	virtual int soap_type(void) const { return 700; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindPTZPositionResult, default initialized and not managed by a soap context
	virtual tt__FindPTZPositionResult *soap_alloc(void) const { return SOAP_NEW(tt__FindPTZPositionResult); }
	         tt__FindPTZPositionResult() { tt__FindPTZPositionResult::soap_default(NULL); }
	virtual ~tt__FindPTZPositionResult() { }
	friend SOAP_FMAC1 tt__FindPTZPositionResult * SOAP_FMAC2 soap_instantiate_tt__FindPTZPositionResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2098 */
#ifndef SOAP_TYPE_tt__FindMetadataResultList
#define SOAP_TYPE_tt__FindMetadataResultList (701)
/* tt:FindMetadataResultList complex type: */
class SOAP_CMAC tt__FindMetadataResultList
{
public:
	enum tt__SearchState SearchState;	/* required element of XSD type tt:SearchState */
	std::vector<tt__FindMetadataResult *> Result;	/* optional element of XSD type tt:FindMetadataResult */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindMetadataResultList (701)
	virtual int soap_type(void) const { return 701; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindMetadataResultList, default initialized and not managed by a soap context
	virtual tt__FindMetadataResultList *soap_alloc(void) const { return SOAP_NEW(tt__FindMetadataResultList); }
	         tt__FindMetadataResultList() { tt__FindMetadataResultList::soap_default(NULL); }
	virtual ~tt__FindMetadataResultList() { }
	friend SOAP_FMAC1 tt__FindMetadataResultList * SOAP_FMAC2 soap_instantiate_tt__FindMetadataResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2101 */
#ifndef SOAP_TYPE_tt__FindMetadataResult
#define SOAP_TYPE_tt__FindMetadataResult (702)
/* tt:FindMetadataResult complex type: */
class SOAP_CMAC tt__FindMetadataResult
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	std::string TrackToken;	/* required element of XSD type tt:TrackReference */
	time_t Time;	/* required element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindMetadataResult (702)
	virtual int soap_type(void) const { return 702; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindMetadataResult, default initialized and not managed by a soap context
	virtual tt__FindMetadataResult *soap_alloc(void) const { return SOAP_NEW(tt__FindMetadataResult); }
	         tt__FindMetadataResult() { tt__FindMetadataResult::soap_default(NULL); }
	virtual ~tt__FindMetadataResult() { }
	friend SOAP_FMAC1 tt__FindMetadataResult * SOAP_FMAC2 soap_instantiate_tt__FindMetadataResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2104 */
#ifndef SOAP_TYPE_tt__RecordingInformation
#define SOAP_TYPE_tt__RecordingInformation (703)
/* tt:RecordingInformation complex type: */
class SOAP_CMAC tt__RecordingInformation
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	tt__RecordingSourceInformation *Source;	/* required element of XSD type tt:RecordingSourceInformation */
	time_t *EarliestRecording;	/* optional element of XSD type xsd:dateTime */
	time_t *LatestRecording;	/* optional element of XSD type xsd:dateTime */
	std::string Content;	/* required element of XSD type tt:Description */
	std::vector<tt__TrackInformation *> Track;	/* optional element of XSD type tt:TrackInformation */
	enum tt__RecordingStatus RecordingStatus;	/* required element of XSD type tt:RecordingStatus */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingInformation (703)
	virtual int soap_type(void) const { return 703; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingInformation, default initialized and not managed by a soap context
	virtual tt__RecordingInformation *soap_alloc(void) const { return SOAP_NEW(tt__RecordingInformation); }
	         tt__RecordingInformation() { tt__RecordingInformation::soap_default(NULL); }
	virtual ~tt__RecordingInformation() { }
	friend SOAP_FMAC1 tt__RecordingInformation * SOAP_FMAC2 soap_instantiate_tt__RecordingInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2107 */
#ifndef SOAP_TYPE_tt__RecordingSourceInformation
#define SOAP_TYPE_tt__RecordingSourceInformation (704)
/* tt:RecordingSourceInformation complex type: */
class SOAP_CMAC tt__RecordingSourceInformation
{
public:
	std::string SourceId;	/* required element of XSD type xsd:anyURI */
	std::string Name;	/* required element of XSD type tt:Name */
	std::string Location;	/* required element of XSD type tt:Description */
	std::string Description;	/* required element of XSD type tt:Description */
	std::string Address;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingSourceInformation (704)
	virtual int soap_type(void) const { return 704; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingSourceInformation, default initialized and not managed by a soap context
	virtual tt__RecordingSourceInformation *soap_alloc(void) const { return SOAP_NEW(tt__RecordingSourceInformation); }
	         tt__RecordingSourceInformation() { tt__RecordingSourceInformation::soap_default(NULL); }
	virtual ~tt__RecordingSourceInformation() { }
	friend SOAP_FMAC1 tt__RecordingSourceInformation * SOAP_FMAC2 soap_instantiate_tt__RecordingSourceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2110 */
#ifndef SOAP_TYPE_tt__TrackInformation
#define SOAP_TYPE_tt__TrackInformation (705)
/* tt:TrackInformation complex type: */
class SOAP_CMAC tt__TrackInformation
{
public:
	std::string TrackToken;	/* required element of XSD type tt:TrackReference */
	enum tt__TrackType TrackType;	/* required element of XSD type tt:TrackType */
	std::string Description;	/* required element of XSD type tt:Description */
	time_t DataFrom;	/* required element of XSD type xsd:dateTime */
	time_t DataTo;	/* required element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackInformation (705)
	virtual int soap_type(void) const { return 705; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackInformation, default initialized and not managed by a soap context
	virtual tt__TrackInformation *soap_alloc(void) const { return SOAP_NEW(tt__TrackInformation); }
	         tt__TrackInformation() { tt__TrackInformation::soap_default(NULL); }
	virtual ~tt__TrackInformation() { }
	friend SOAP_FMAC1 tt__TrackInformation * SOAP_FMAC2 soap_instantiate_tt__TrackInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2113 */
#ifndef SOAP_TYPE_tt__MediaAttributes
#define SOAP_TYPE_tt__MediaAttributes (706)
/* tt:MediaAttributes complex type: */
class SOAP_CMAC tt__MediaAttributes
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	std::vector<tt__TrackAttributes *> TrackAttributes;	/* optional element of XSD type tt:TrackAttributes */
	time_t From;	/* required element of XSD type xsd:dateTime */
	time_t Until;	/* required element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MediaAttributes (706)
	virtual int soap_type(void) const { return 706; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MediaAttributes, default initialized and not managed by a soap context
	virtual tt__MediaAttributes *soap_alloc(void) const { return SOAP_NEW(tt__MediaAttributes); }
	         tt__MediaAttributes() { tt__MediaAttributes::soap_default(NULL); }
	virtual ~tt__MediaAttributes() { }
	friend SOAP_FMAC1 tt__MediaAttributes * SOAP_FMAC2 soap_instantiate_tt__MediaAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2116 */
#ifndef SOAP_TYPE_tt__TrackAttributes
#define SOAP_TYPE_tt__TrackAttributes (707)
/* tt:TrackAttributes complex type: */
class SOAP_CMAC tt__TrackAttributes
{
public:
	tt__TrackInformation *TrackInformation;	/* required element of XSD type tt:TrackInformation */
	tt__VideoAttributes *VideoAttributes;	/* optional element of XSD type tt:VideoAttributes */
	tt__AudioAttributes *AudioAttributes;	/* optional element of XSD type tt:AudioAttributes */
	tt__MetadataAttributes *MetadataAttributes;	/* optional element of XSD type tt:MetadataAttributes */
	tt__TrackAttributesExtension *Extension;	/* optional element of XSD type tt:TrackAttributesExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackAttributes (707)
	virtual int soap_type(void) const { return 707; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackAttributes, default initialized and not managed by a soap context
	virtual tt__TrackAttributes *soap_alloc(void) const { return SOAP_NEW(tt__TrackAttributes); }
	         tt__TrackAttributes() { tt__TrackAttributes::soap_default(NULL); }
	virtual ~tt__TrackAttributes() { }
	friend SOAP_FMAC1 tt__TrackAttributes * SOAP_FMAC2 soap_instantiate_tt__TrackAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2119 */
#ifndef SOAP_TYPE_tt__TrackAttributesExtension
#define SOAP_TYPE_tt__TrackAttributesExtension (708)
/* tt:TrackAttributesExtension complex type: */
class SOAP_CMAC tt__TrackAttributesExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackAttributesExtension (708)
	virtual int soap_type(void) const { return 708; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackAttributesExtension, default initialized and not managed by a soap context
	virtual tt__TrackAttributesExtension *soap_alloc(void) const { return SOAP_NEW(tt__TrackAttributesExtension); }
	         tt__TrackAttributesExtension() { tt__TrackAttributesExtension::soap_default(NULL); }
	virtual ~tt__TrackAttributesExtension() { }
	friend SOAP_FMAC1 tt__TrackAttributesExtension * SOAP_FMAC2 soap_instantiate_tt__TrackAttributesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2122 */
#ifndef SOAP_TYPE_tt__VideoAttributes
#define SOAP_TYPE_tt__VideoAttributes (709)
/* tt:VideoAttributes complex type: */
class SOAP_CMAC tt__VideoAttributes
{
public:
	int *Bitrate;	/* optional element of XSD type xsd:int */
	int Width;	/* required element of XSD type xsd:int */
	int Height;	/* required element of XSD type xsd:int */
	std::string Encoding;	/* required element of XSD type xsd:string */
	float Framerate;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoAttributes (709)
	virtual int soap_type(void) const { return 709; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoAttributes, default initialized and not managed by a soap context
	virtual tt__VideoAttributes *soap_alloc(void) const { return SOAP_NEW(tt__VideoAttributes); }
	         tt__VideoAttributes() { tt__VideoAttributes::soap_default(NULL); }
	virtual ~tt__VideoAttributes() { }
	friend SOAP_FMAC1 tt__VideoAttributes * SOAP_FMAC2 soap_instantiate_tt__VideoAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2125 */
#ifndef SOAP_TYPE_tt__AudioAttributes
#define SOAP_TYPE_tt__AudioAttributes (710)
/* tt:AudioAttributes complex type: */
class SOAP_CMAC tt__AudioAttributes
{
public:
	int *Bitrate;	/* optional element of XSD type xsd:int */
	std::string Encoding;	/* required element of XSD type xsd:string */
	int Samplerate;	/* required element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioAttributes (710)
	virtual int soap_type(void) const { return 710; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioAttributes, default initialized and not managed by a soap context
	virtual tt__AudioAttributes *soap_alloc(void) const { return SOAP_NEW(tt__AudioAttributes); }
	         tt__AudioAttributes() { tt__AudioAttributes::soap_default(NULL); }
	virtual ~tt__AudioAttributes() { }
	friend SOAP_FMAC1 tt__AudioAttributes * SOAP_FMAC2 soap_instantiate_tt__AudioAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2128 */
#ifndef SOAP_TYPE_tt__MetadataAttributes
#define SOAP_TYPE_tt__MetadataAttributes (711)
/* tt:MetadataAttributes complex type: */
class SOAP_CMAC tt__MetadataAttributes
{
public:
	bool CanContainPTZ;	/* required element of XSD type xsd:boolean */
	bool CanContainAnalytics;	/* required element of XSD type xsd:boolean */
	bool CanContainNotifications;	/* required element of XSD type xsd:boolean */
	std::string *PtzSpaces;	/* optional attribute of XSD type tt:StringAttrList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataAttributes (711)
	virtual int soap_type(void) const { return 711; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataAttributes, default initialized and not managed by a soap context
	virtual tt__MetadataAttributes *soap_alloc(void) const { return SOAP_NEW(tt__MetadataAttributes); }
	         tt__MetadataAttributes() { tt__MetadataAttributes::soap_default(NULL); }
	virtual ~tt__MetadataAttributes() { }
	friend SOAP_FMAC1 tt__MetadataAttributes * SOAP_FMAC2 soap_instantiate_tt__MetadataAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2131 */
#ifndef SOAP_TYPE_tt__RecordingConfiguration
#define SOAP_TYPE_tt__RecordingConfiguration (712)
/* tt:RecordingConfiguration complex type: */
class SOAP_CMAC tt__RecordingConfiguration
{
public:
	tt__RecordingSourceInformation *Source;	/* required element of XSD type tt:RecordingSourceInformation */
	std::string Content;	/* required element of XSD type tt:Description */
	LONG64 MaximumRetentionTime;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingConfiguration (712)
	virtual int soap_type(void) const { return 712; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingConfiguration, default initialized and not managed by a soap context
	virtual tt__RecordingConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__RecordingConfiguration); }
	         tt__RecordingConfiguration() { tt__RecordingConfiguration::soap_default(NULL); }
	virtual ~tt__RecordingConfiguration() { }
	friend SOAP_FMAC1 tt__RecordingConfiguration * SOAP_FMAC2 soap_instantiate_tt__RecordingConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2134 */
#ifndef SOAP_TYPE_tt__TrackConfiguration
#define SOAP_TYPE_tt__TrackConfiguration (713)
/* tt:TrackConfiguration complex type: */
class SOAP_CMAC tt__TrackConfiguration
{
public:
	enum tt__TrackType TrackType;	/* required element of XSD type tt:TrackType */
	std::string Description;	/* required element of XSD type tt:Description */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackConfiguration (713)
	virtual int soap_type(void) const { return 713; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackConfiguration, default initialized and not managed by a soap context
	virtual tt__TrackConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__TrackConfiguration); }
	         tt__TrackConfiguration() { tt__TrackConfiguration::soap_default(NULL); }
	virtual ~tt__TrackConfiguration() { }
	friend SOAP_FMAC1 tt__TrackConfiguration * SOAP_FMAC2 soap_instantiate_tt__TrackConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2137 */
#ifndef SOAP_TYPE_tt__GetRecordingsResponseItem
#define SOAP_TYPE_tt__GetRecordingsResponseItem (714)
/* tt:GetRecordingsResponseItem complex type: */
class SOAP_CMAC tt__GetRecordingsResponseItem
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	tt__RecordingConfiguration *Configuration;	/* required element of XSD type tt:RecordingConfiguration */
	tt__GetTracksResponseList *Tracks;	/* required element of XSD type tt:GetTracksResponseList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GetRecordingsResponseItem (714)
	virtual int soap_type(void) const { return 714; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GetRecordingsResponseItem, default initialized and not managed by a soap context
	virtual tt__GetRecordingsResponseItem *soap_alloc(void) const { return SOAP_NEW(tt__GetRecordingsResponseItem); }
	         tt__GetRecordingsResponseItem() { tt__GetRecordingsResponseItem::soap_default(NULL); }
	virtual ~tt__GetRecordingsResponseItem() { }
	friend SOAP_FMAC1 tt__GetRecordingsResponseItem * SOAP_FMAC2 soap_instantiate_tt__GetRecordingsResponseItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2140 */
#ifndef SOAP_TYPE_tt__GetTracksResponseList
#define SOAP_TYPE_tt__GetTracksResponseList (715)
/* tt:GetTracksResponseList complex type: */
class SOAP_CMAC tt__GetTracksResponseList
{
public:
	std::vector<tt__GetTracksResponseItem *> Track;	/* optional element of XSD type tt:GetTracksResponseItem */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GetTracksResponseList (715)
	virtual int soap_type(void) const { return 715; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GetTracksResponseList, default initialized and not managed by a soap context
	virtual tt__GetTracksResponseList *soap_alloc(void) const { return SOAP_NEW(tt__GetTracksResponseList); }
	         tt__GetTracksResponseList() { tt__GetTracksResponseList::soap_default(NULL); }
	virtual ~tt__GetTracksResponseList() { }
	friend SOAP_FMAC1 tt__GetTracksResponseList * SOAP_FMAC2 soap_instantiate_tt__GetTracksResponseList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2143 */
#ifndef SOAP_TYPE_tt__GetTracksResponseItem
#define SOAP_TYPE_tt__GetTracksResponseItem (716)
/* tt:GetTracksResponseItem complex type: */
class SOAP_CMAC tt__GetTracksResponseItem
{
public:
	std::string TrackToken;	/* required element of XSD type tt:TrackReference */
	tt__TrackConfiguration *Configuration;	/* required element of XSD type tt:TrackConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GetTracksResponseItem (716)
	virtual int soap_type(void) const { return 716; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GetTracksResponseItem, default initialized and not managed by a soap context
	virtual tt__GetTracksResponseItem *soap_alloc(void) const { return SOAP_NEW(tt__GetTracksResponseItem); }
	         tt__GetTracksResponseItem() { tt__GetTracksResponseItem::soap_default(NULL); }
	virtual ~tt__GetTracksResponseItem() { }
	friend SOAP_FMAC1 tt__GetTracksResponseItem * SOAP_FMAC2 soap_instantiate_tt__GetTracksResponseItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2146 */
#ifndef SOAP_TYPE_tt__RecordingJobConfiguration
#define SOAP_TYPE_tt__RecordingJobConfiguration (717)
/* tt:RecordingJobConfiguration complex type: */
class SOAP_CMAC tt__RecordingJobConfiguration
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	std::string Mode;	/* required element of XSD type tt:RecordingJobMode */
	int Priority;	/* required element of XSD type xsd:int */
	std::vector<tt__RecordingJobSource *> Source;	/* optional element of XSD type tt:RecordingJobSource */
	tt__RecordingJobConfigurationExtension *Extension;	/* optional element of XSD type tt:RecordingJobConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobConfiguration (717)
	virtual int soap_type(void) const { return 717; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobConfiguration, default initialized and not managed by a soap context
	virtual tt__RecordingJobConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobConfiguration); }
	         tt__RecordingJobConfiguration() { tt__RecordingJobConfiguration::soap_default(NULL); }
	virtual ~tt__RecordingJobConfiguration() { }
	friend SOAP_FMAC1 tt__RecordingJobConfiguration * SOAP_FMAC2 soap_instantiate_tt__RecordingJobConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2149 */
#ifndef SOAP_TYPE_tt__RecordingJobConfigurationExtension
#define SOAP_TYPE_tt__RecordingJobConfigurationExtension (718)
/* tt:RecordingJobConfigurationExtension complex type: */
class SOAP_CMAC tt__RecordingJobConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobConfigurationExtension (718)
	virtual int soap_type(void) const { return 718; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__RecordingJobConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobConfigurationExtension); }
	         tt__RecordingJobConfigurationExtension() { tt__RecordingJobConfigurationExtension::soap_default(NULL); }
	virtual ~tt__RecordingJobConfigurationExtension() { }
	friend SOAP_FMAC1 tt__RecordingJobConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__RecordingJobConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2152 */
#ifndef SOAP_TYPE_tt__RecordingJobSource
#define SOAP_TYPE_tt__RecordingJobSource (719)
/* tt:RecordingJobSource complex type: */
class SOAP_CMAC tt__RecordingJobSource
{
public:
	tt__SourceReference *SourceToken;	/* optional element of XSD type tt:SourceReference */
	bool *AutoCreateReceiver;	/* optional element of XSD type xsd:boolean */
	std::vector<tt__RecordingJobTrack *> Tracks;	/* optional element of XSD type tt:RecordingJobTrack */
	tt__RecordingJobSourceExtension *Extension;	/* optional element of XSD type tt:RecordingJobSourceExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobSource (719)
	virtual int soap_type(void) const { return 719; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobSource, default initialized and not managed by a soap context
	virtual tt__RecordingJobSource *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobSource); }
	         tt__RecordingJobSource() { tt__RecordingJobSource::soap_default(NULL); }
	virtual ~tt__RecordingJobSource() { }
	friend SOAP_FMAC1 tt__RecordingJobSource * SOAP_FMAC2 soap_instantiate_tt__RecordingJobSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2155 */
#ifndef SOAP_TYPE_tt__RecordingJobSourceExtension
#define SOAP_TYPE_tt__RecordingJobSourceExtension (720)
/* tt:RecordingJobSourceExtension complex type: */
class SOAP_CMAC tt__RecordingJobSourceExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobSourceExtension (720)
	virtual int soap_type(void) const { return 720; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobSourceExtension, default initialized and not managed by a soap context
	virtual tt__RecordingJobSourceExtension *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobSourceExtension); }
	         tt__RecordingJobSourceExtension() { tt__RecordingJobSourceExtension::soap_default(NULL); }
	virtual ~tt__RecordingJobSourceExtension() { }
	friend SOAP_FMAC1 tt__RecordingJobSourceExtension * SOAP_FMAC2 soap_instantiate_tt__RecordingJobSourceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2158 */
#ifndef SOAP_TYPE_tt__RecordingJobTrack
#define SOAP_TYPE_tt__RecordingJobTrack (721)
/* tt:RecordingJobTrack complex type: */
class SOAP_CMAC tt__RecordingJobTrack
{
public:
	std::string SourceTag;	/* required element of XSD type xsd:string */
	std::string Destination;	/* required element of XSD type tt:TrackReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobTrack (721)
	virtual int soap_type(void) const { return 721; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobTrack, default initialized and not managed by a soap context
	virtual tt__RecordingJobTrack *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobTrack); }
	         tt__RecordingJobTrack() { tt__RecordingJobTrack::soap_default(NULL); }
	virtual ~tt__RecordingJobTrack() { }
	friend SOAP_FMAC1 tt__RecordingJobTrack * SOAP_FMAC2 soap_instantiate_tt__RecordingJobTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2161 */
#ifndef SOAP_TYPE_tt__RecordingJobStateInformation
#define SOAP_TYPE_tt__RecordingJobStateInformation (722)
/* tt:RecordingJobStateInformation complex type: */
class SOAP_CMAC tt__RecordingJobStateInformation
{
public:
	std::string RecordingToken;	/* required element of XSD type tt:RecordingReference */
	std::string State;	/* required element of XSD type tt:RecordingJobState */
	std::vector<tt__RecordingJobStateSource *> Sources;	/* optional element of XSD type tt:RecordingJobStateSource */
	tt__RecordingJobStateInformationExtension *Extension;	/* optional element of XSD type tt:RecordingJobStateInformationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateInformation (722)
	virtual int soap_type(void) const { return 722; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateInformation, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateInformation *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateInformation); }
	         tt__RecordingJobStateInformation() { tt__RecordingJobStateInformation::soap_default(NULL); }
	virtual ~tt__RecordingJobStateInformation() { }
	friend SOAP_FMAC1 tt__RecordingJobStateInformation * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2164 */
#ifndef SOAP_TYPE_tt__RecordingJobStateInformationExtension
#define SOAP_TYPE_tt__RecordingJobStateInformationExtension (723)
/* tt:RecordingJobStateInformationExtension complex type: */
class SOAP_CMAC tt__RecordingJobStateInformationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateInformationExtension (723)
	virtual int soap_type(void) const { return 723; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateInformationExtension, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateInformationExtension); }
	         tt__RecordingJobStateInformationExtension() { tt__RecordingJobStateInformationExtension::soap_default(NULL); }
	virtual ~tt__RecordingJobStateInformationExtension() { }
	friend SOAP_FMAC1 tt__RecordingJobStateInformationExtension * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2167 */
#ifndef SOAP_TYPE_tt__RecordingJobStateSource
#define SOAP_TYPE_tt__RecordingJobStateSource (724)
/* tt:RecordingJobStateSource complex type: */
class SOAP_CMAC tt__RecordingJobStateSource
{
public:
	tt__SourceReference *SourceToken;	/* required element of XSD type tt:SourceReference */
	std::string State;	/* required element of XSD type tt:RecordingJobState */
	tt__RecordingJobStateTracks *Tracks;	/* required element of XSD type tt:RecordingJobStateTracks */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateSource (724)
	virtual int soap_type(void) const { return 724; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateSource, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateSource *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateSource); }
	         tt__RecordingJobStateSource() { tt__RecordingJobStateSource::soap_default(NULL); }
	virtual ~tt__RecordingJobStateSource() { }
	friend SOAP_FMAC1 tt__RecordingJobStateSource * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2170 */
#ifndef SOAP_TYPE_tt__RecordingJobStateTracks
#define SOAP_TYPE_tt__RecordingJobStateTracks (725)
/* tt:RecordingJobStateTracks complex type: */
class SOAP_CMAC tt__RecordingJobStateTracks
{
public:
	std::vector<tt__RecordingJobStateTrack *> Track;	/* optional element of XSD type tt:RecordingJobStateTrack */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateTracks (725)
	virtual int soap_type(void) const { return 725; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateTracks, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateTracks *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateTracks); }
	         tt__RecordingJobStateTracks() { tt__RecordingJobStateTracks::soap_default(NULL); }
	virtual ~tt__RecordingJobStateTracks() { }
	friend SOAP_FMAC1 tt__RecordingJobStateTracks * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateTracks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2173 */
#ifndef SOAP_TYPE_tt__RecordingJobStateTrack
#define SOAP_TYPE_tt__RecordingJobStateTrack (726)
/* tt:RecordingJobStateTrack complex type: */
class SOAP_CMAC tt__RecordingJobStateTrack
{
public:
	std::string SourceTag;	/* required element of XSD type xsd:string */
	std::string Destination;	/* required element of XSD type tt:TrackReference */
	std::string *Error;	/* optional element of XSD type xsd:string */
	std::string State;	/* required element of XSD type tt:RecordingJobState */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateTrack (726)
	virtual int soap_type(void) const { return 726; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateTrack, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateTrack *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateTrack); }
	         tt__RecordingJobStateTrack() { tt__RecordingJobStateTrack::soap_default(NULL); }
	virtual ~tt__RecordingJobStateTrack() { }
	friend SOAP_FMAC1 tt__RecordingJobStateTrack * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2176 */
#ifndef SOAP_TYPE_tt__GetRecordingJobsResponseItem
#define SOAP_TYPE_tt__GetRecordingJobsResponseItem (727)
/* tt:GetRecordingJobsResponseItem complex type: */
class SOAP_CMAC tt__GetRecordingJobsResponseItem
{
public:
	std::string JobToken;	/* required element of XSD type tt:RecordingJobReference */
	tt__RecordingJobConfiguration *JobConfiguration;	/* required element of XSD type tt:RecordingJobConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GetRecordingJobsResponseItem (727)
	virtual int soap_type(void) const { return 727; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GetRecordingJobsResponseItem, default initialized and not managed by a soap context
	virtual tt__GetRecordingJobsResponseItem *soap_alloc(void) const { return SOAP_NEW(tt__GetRecordingJobsResponseItem); }
	         tt__GetRecordingJobsResponseItem() { tt__GetRecordingJobsResponseItem::soap_default(NULL); }
	virtual ~tt__GetRecordingJobsResponseItem() { }
	friend SOAP_FMAC1 tt__GetRecordingJobsResponseItem * SOAP_FMAC2 soap_instantiate_tt__GetRecordingJobsResponseItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2179 */
#ifndef SOAP_TYPE_tt__ReplayConfiguration
#define SOAP_TYPE_tt__ReplayConfiguration (728)
/* tt:ReplayConfiguration complex type: */
class SOAP_CMAC tt__ReplayConfiguration
{
public:
	LONG64 SessionTimeout;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReplayConfiguration (728)
	virtual int soap_type(void) const { return 728; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReplayConfiguration, default initialized and not managed by a soap context
	virtual tt__ReplayConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__ReplayConfiguration); }
	         tt__ReplayConfiguration() { tt__ReplayConfiguration::soap_default(NULL); }
	virtual ~tt__ReplayConfiguration() { }
	friend SOAP_FMAC1 tt__ReplayConfiguration * SOAP_FMAC2 soap_instantiate_tt__ReplayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2185 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration (730)
/* tt:AnalyticsDeviceEngineConfiguration complex type: */
class SOAP_CMAC tt__AnalyticsDeviceEngineConfiguration
{
public:
	std::vector<tt__EngineConfiguration *> EngineConfiguration;	/* required element of XSD type tt:EngineConfiguration */
	tt__AnalyticsDeviceEngineConfigurationExtension *Extension;	/* optional element of XSD type tt:AnalyticsDeviceEngineConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration (730)
	virtual int soap_type(void) const { return 730; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsDeviceEngineConfiguration, default initialized and not managed by a soap context
	virtual tt__AnalyticsDeviceEngineConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsDeviceEngineConfiguration); }
	         tt__AnalyticsDeviceEngineConfiguration() { tt__AnalyticsDeviceEngineConfiguration::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceEngineConfiguration() { }
	friend SOAP_FMAC1 tt__AnalyticsDeviceEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2188 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension (731)
/* tt:AnalyticsDeviceEngineConfigurationExtension complex type: */
class SOAP_CMAC tt__AnalyticsDeviceEngineConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension (731)
	virtual int soap_type(void) const { return 731; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsDeviceEngineConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__AnalyticsDeviceEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsDeviceEngineConfigurationExtension); }
	         tt__AnalyticsDeviceEngineConfigurationExtension() { tt__AnalyticsDeviceEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceEngineConfigurationExtension() { }
	friend SOAP_FMAC1 tt__AnalyticsDeviceEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2191 */
#ifndef SOAP_TYPE_tt__EngineConfiguration
#define SOAP_TYPE_tt__EngineConfiguration (732)
/* tt:EngineConfiguration complex type: */
class SOAP_CMAC tt__EngineConfiguration
{
public:
	tt__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;	/* required element of XSD type tt:VideoAnalyticsConfiguration */
	tt__AnalyticsEngineInputInfo *AnalyticsEngineInputInfo;	/* required element of XSD type tt:AnalyticsEngineInputInfo */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EngineConfiguration (732)
	virtual int soap_type(void) const { return 732; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EngineConfiguration, default initialized and not managed by a soap context
	virtual tt__EngineConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__EngineConfiguration); }
	         tt__EngineConfiguration() { tt__EngineConfiguration::soap_default(NULL); }
	virtual ~tt__EngineConfiguration() { }
	friend SOAP_FMAC1 tt__EngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__EngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2194 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineInputInfo
#define SOAP_TYPE_tt__AnalyticsEngineInputInfo (733)
/* tt:AnalyticsEngineInputInfo complex type: */
class SOAP_CMAC tt__AnalyticsEngineInputInfo
{
public:
	tt__Config *InputInfo;	/* optional element of XSD type tt:Config */
	tt__AnalyticsEngineInputInfoExtension *Extension;	/* optional element of XSD type tt:AnalyticsEngineInputInfoExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineInputInfo (733)
	virtual int soap_type(void) const { return 733; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineInputInfo, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineInputInfo *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineInputInfo); }
	         tt__AnalyticsEngineInputInfo() { tt__AnalyticsEngineInputInfo::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineInputInfo() { }
	friend SOAP_FMAC1 tt__AnalyticsEngineInputInfo * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineInputInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2197 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension
#define SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension (734)
/* tt:AnalyticsEngineInputInfoExtension complex type: */
class SOAP_CMAC tt__AnalyticsEngineInputInfoExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension (734)
	virtual int soap_type(void) const { return 734; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineInputInfoExtension, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineInputInfoExtension *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineInputInfoExtension); }
	         tt__AnalyticsEngineInputInfoExtension() { tt__AnalyticsEngineInputInfoExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineInputInfoExtension() { }
	friend SOAP_FMAC1 tt__AnalyticsEngineInputInfoExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineInputInfoExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2203 */
#ifndef SOAP_TYPE_tt__SourceIdentification
#define SOAP_TYPE_tt__SourceIdentification (736)
/* tt:SourceIdentification complex type: */
class SOAP_CMAC tt__SourceIdentification
{
public:
	std::string Name;	/* required element of XSD type xsd:string */
	std::vector<std::string> Token;	/* required element of XSD type tt:ReferenceToken */
	tt__SourceIdentificationExtension *Extension;	/* optional element of XSD type tt:SourceIdentificationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SourceIdentification (736)
	virtual int soap_type(void) const { return 736; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SourceIdentification, default initialized and not managed by a soap context
	virtual tt__SourceIdentification *soap_alloc(void) const { return SOAP_NEW(tt__SourceIdentification); }
	         tt__SourceIdentification() { tt__SourceIdentification::soap_default(NULL); }
	virtual ~tt__SourceIdentification() { }
	friend SOAP_FMAC1 tt__SourceIdentification * SOAP_FMAC2 soap_instantiate_tt__SourceIdentification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2206 */
#ifndef SOAP_TYPE_tt__SourceIdentificationExtension
#define SOAP_TYPE_tt__SourceIdentificationExtension (737)
/* tt:SourceIdentificationExtension complex type: */
class SOAP_CMAC tt__SourceIdentificationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SourceIdentificationExtension (737)
	virtual int soap_type(void) const { return 737; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SourceIdentificationExtension, default initialized and not managed by a soap context
	virtual tt__SourceIdentificationExtension *soap_alloc(void) const { return SOAP_NEW(tt__SourceIdentificationExtension); }
	         tt__SourceIdentificationExtension() { tt__SourceIdentificationExtension::soap_default(NULL); }
	virtual ~tt__SourceIdentificationExtension() { }
	friend SOAP_FMAC1 tt__SourceIdentificationExtension * SOAP_FMAC2 soap_instantiate_tt__SourceIdentificationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2209 */
#ifndef SOAP_TYPE_tt__MetadataInput
#define SOAP_TYPE_tt__MetadataInput (738)
/* tt:MetadataInput complex type: */
class SOAP_CMAC tt__MetadataInput
{
public:
	std::vector<tt__Config *> MetadataConfig;	/* optional element of XSD type tt:Config */
	tt__MetadataInputExtension *Extension;	/* optional element of XSD type tt:MetadataInputExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataInput (738)
	virtual int soap_type(void) const { return 738; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataInput, default initialized and not managed by a soap context
	virtual tt__MetadataInput *soap_alloc(void) const { return SOAP_NEW(tt__MetadataInput); }
	         tt__MetadataInput() { tt__MetadataInput::soap_default(NULL); }
	virtual ~tt__MetadataInput() { }
	friend SOAP_FMAC1 tt__MetadataInput * SOAP_FMAC2 soap_instantiate_tt__MetadataInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2212 */
#ifndef SOAP_TYPE_tt__MetadataInputExtension
#define SOAP_TYPE_tt__MetadataInputExtension (739)
/* tt:MetadataInputExtension complex type: */
class SOAP_CMAC tt__MetadataInputExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataInputExtension (739)
	virtual int soap_type(void) const { return 739; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataInputExtension, default initialized and not managed by a soap context
	virtual tt__MetadataInputExtension *soap_alloc(void) const { return SOAP_NEW(tt__MetadataInputExtension); }
	         tt__MetadataInputExtension() { tt__MetadataInputExtension::soap_default(NULL); }
	virtual ~tt__MetadataInputExtension() { }
	friend SOAP_FMAC1 tt__MetadataInputExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataInputExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2218 */
#ifndef SOAP_TYPE_tt__AnalyticsStateInformation
#define SOAP_TYPE_tt__AnalyticsStateInformation (741)
/* tt:AnalyticsStateInformation complex type: */
class SOAP_CMAC tt__AnalyticsStateInformation
{
public:
	std::string AnalyticsEngineControlToken;	/* required element of XSD type tt:ReferenceToken */
	tt__AnalyticsState *State;	/* required element of XSD type tt:AnalyticsState */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsStateInformation (741)
	virtual int soap_type(void) const { return 741; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsStateInformation, default initialized and not managed by a soap context
	virtual tt__AnalyticsStateInformation *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsStateInformation); }
	         tt__AnalyticsStateInformation() { tt__AnalyticsStateInformation::soap_default(NULL); }
	virtual ~tt__AnalyticsStateInformation() { }
	friend SOAP_FMAC1 tt__AnalyticsStateInformation * SOAP_FMAC2 soap_instantiate_tt__AnalyticsStateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2221 */
#ifndef SOAP_TYPE_tt__AnalyticsState
#define SOAP_TYPE_tt__AnalyticsState (742)
/* tt:AnalyticsState complex type: */
class SOAP_CMAC tt__AnalyticsState
{
public:
	std::string *Error;	/* optional element of XSD type xsd:string */
	std::string State;	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsState (742)
	virtual int soap_type(void) const { return 742; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsState, default initialized and not managed by a soap context
	virtual tt__AnalyticsState *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsState); }
	         tt__AnalyticsState() { tt__AnalyticsState::soap_default(NULL); }
	virtual ~tt__AnalyticsState() { }
	friend SOAP_FMAC1 tt__AnalyticsState * SOAP_FMAC2 soap_instantiate_tt__AnalyticsState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2224 */
#ifndef SOAP_TYPE_tt__ActionEngineEventPayload
#define SOAP_TYPE_tt__ActionEngineEventPayload (743)
/* tt:ActionEngineEventPayload complex type: */
class SOAP_CMAC tt__ActionEngineEventPayload
{
public:
	struct SOAP_ENV__Envelope *RequestInfo;	/* optional element of XSD type SOAP-ENV:Envelope */
	struct SOAP_ENV__Envelope *ResponseInfo;	/* optional element of XSD type SOAP-ENV:Envelope */
	struct SOAP_ENV__Fault *Fault;	/* optional element of XSD type SOAP-ENV:Fault */
	tt__ActionEngineEventPayloadExtension *Extension;	/* optional element of XSD type tt:ActionEngineEventPayloadExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ActionEngineEventPayload (743)
	virtual int soap_type(void) const { return 743; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ActionEngineEventPayload, default initialized and not managed by a soap context
	virtual tt__ActionEngineEventPayload *soap_alloc(void) const { return SOAP_NEW(tt__ActionEngineEventPayload); }
	         tt__ActionEngineEventPayload() { tt__ActionEngineEventPayload::soap_default(NULL); }
	virtual ~tt__ActionEngineEventPayload() { }
	friend SOAP_FMAC1 tt__ActionEngineEventPayload * SOAP_FMAC2 soap_instantiate_tt__ActionEngineEventPayload(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2227 */
#ifndef SOAP_TYPE_tt__ActionEngineEventPayloadExtension
#define SOAP_TYPE_tt__ActionEngineEventPayloadExtension (744)
/* tt:ActionEngineEventPayloadExtension complex type: */
class SOAP_CMAC tt__ActionEngineEventPayloadExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ActionEngineEventPayloadExtension (744)
	virtual int soap_type(void) const { return 744; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ActionEngineEventPayloadExtension, default initialized and not managed by a soap context
	virtual tt__ActionEngineEventPayloadExtension *soap_alloc(void) const { return SOAP_NEW(tt__ActionEngineEventPayloadExtension); }
	         tt__ActionEngineEventPayloadExtension() { tt__ActionEngineEventPayloadExtension::soap_default(NULL); }
	virtual ~tt__ActionEngineEventPayloadExtension() { }
	friend SOAP_FMAC1 tt__ActionEngineEventPayloadExtension * SOAP_FMAC2 soap_instantiate_tt__ActionEngineEventPayloadExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2230 */
#ifndef SOAP_TYPE_tt__AudioClassCandidate
#define SOAP_TYPE_tt__AudioClassCandidate (745)
/* tt:AudioClassCandidate complex type: */
class SOAP_CMAC tt__AudioClassCandidate
{
public:
	std::string Type;	/* required element of XSD type tt:AudioClassType */
	float Likelihood;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioClassCandidate (745)
	virtual int soap_type(void) const { return 745; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioClassCandidate, default initialized and not managed by a soap context
	virtual tt__AudioClassCandidate *soap_alloc(void) const { return SOAP_NEW(tt__AudioClassCandidate); }
	         tt__AudioClassCandidate() { tt__AudioClassCandidate::soap_default(NULL); }
	virtual ~tt__AudioClassCandidate() { }
	friend SOAP_FMAC1 tt__AudioClassCandidate * SOAP_FMAC2 soap_instantiate_tt__AudioClassCandidate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2233 */
#ifndef SOAP_TYPE_tt__AudioClassDescriptor
#define SOAP_TYPE_tt__AudioClassDescriptor (746)
/* tt:AudioClassDescriptor complex type: */
class SOAP_CMAC tt__AudioClassDescriptor
{
public:
	std::vector<tt__AudioClassCandidate *> ClassCandidate;	/* optional element of XSD type tt:AudioClassCandidate */
	tt__AudioClassDescriptorExtension *Extension;	/* optional element of XSD type tt:AudioClassDescriptorExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioClassDescriptor (746)
	virtual int soap_type(void) const { return 746; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioClassDescriptor, default initialized and not managed by a soap context
	virtual tt__AudioClassDescriptor *soap_alloc(void) const { return SOAP_NEW(tt__AudioClassDescriptor); }
	         tt__AudioClassDescriptor() { tt__AudioClassDescriptor::soap_default(NULL); }
	virtual ~tt__AudioClassDescriptor() { }
	friend SOAP_FMAC1 tt__AudioClassDescriptor * SOAP_FMAC2 soap_instantiate_tt__AudioClassDescriptor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2236 */
#ifndef SOAP_TYPE_tt__AudioClassDescriptorExtension
#define SOAP_TYPE_tt__AudioClassDescriptorExtension (747)
/* tt:AudioClassDescriptorExtension complex type: */
class SOAP_CMAC tt__AudioClassDescriptorExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioClassDescriptorExtension (747)
	virtual int soap_type(void) const { return 747; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioClassDescriptorExtension, default initialized and not managed by a soap context
	virtual tt__AudioClassDescriptorExtension *soap_alloc(void) const { return SOAP_NEW(tt__AudioClassDescriptorExtension); }
	         tt__AudioClassDescriptorExtension() { tt__AudioClassDescriptorExtension::soap_default(NULL); }
	virtual ~tt__AudioClassDescriptorExtension() { }
	friend SOAP_FMAC1 tt__AudioClassDescriptorExtension * SOAP_FMAC2 soap_instantiate_tt__AudioClassDescriptorExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2239 */
#ifndef SOAP_TYPE_tt__ActiveConnection
#define SOAP_TYPE_tt__ActiveConnection (748)
/* tt:ActiveConnection complex type: */
class SOAP_CMAC tt__ActiveConnection
{
public:
	float CurrentBitrate;	/* required element of XSD type xsd:float */
	float CurrentFps;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ActiveConnection (748)
	virtual int soap_type(void) const { return 748; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ActiveConnection, default initialized and not managed by a soap context
	virtual tt__ActiveConnection *soap_alloc(void) const { return SOAP_NEW(tt__ActiveConnection); }
	         tt__ActiveConnection() { tt__ActiveConnection::soap_default(NULL); }
	virtual ~tt__ActiveConnection() { }
	friend SOAP_FMAC1 tt__ActiveConnection * SOAP_FMAC2 soap_instantiate_tt__ActiveConnection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2242 */
#ifndef SOAP_TYPE_tt__ProfileStatus
#define SOAP_TYPE_tt__ProfileStatus (749)
/* tt:ProfileStatus complex type: */
class SOAP_CMAC tt__ProfileStatus
{
public:
	std::vector<tt__ActiveConnection *> ActiveConnections;	/* optional element of XSD type tt:ActiveConnection */
	tt__ProfileStatusExtension *Extension;	/* optional element of XSD type tt:ProfileStatusExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ProfileStatus (749)
	virtual int soap_type(void) const { return 749; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ProfileStatus, default initialized and not managed by a soap context
	virtual tt__ProfileStatus *soap_alloc(void) const { return SOAP_NEW(tt__ProfileStatus); }
	         tt__ProfileStatus() { tt__ProfileStatus::soap_default(NULL); }
	virtual ~tt__ProfileStatus() { }
	friend SOAP_FMAC1 tt__ProfileStatus * SOAP_FMAC2 soap_instantiate_tt__ProfileStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2245 */
#ifndef SOAP_TYPE_tt__ProfileStatusExtension
#define SOAP_TYPE_tt__ProfileStatusExtension (750)
/* tt:ProfileStatusExtension complex type: */
class SOAP_CMAC tt__ProfileStatusExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ProfileStatusExtension (750)
	virtual int soap_type(void) const { return 750; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ProfileStatusExtension, default initialized and not managed by a soap context
	virtual tt__ProfileStatusExtension *soap_alloc(void) const { return SOAP_NEW(tt__ProfileStatusExtension); }
	         tt__ProfileStatusExtension() { tt__ProfileStatusExtension::soap_default(NULL); }
	virtual ~tt__ProfileStatusExtension() { }
	friend SOAP_FMAC1 tt__ProfileStatusExtension * SOAP_FMAC2 soap_instantiate_tt__ProfileStatusExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2251 */
#ifndef SOAP_TYPE_tt__OSDPosConfiguration
#define SOAP_TYPE_tt__OSDPosConfiguration (752)
/* tt:OSDPosConfiguration complex type: */
class SOAP_CMAC tt__OSDPosConfiguration
{
public:
	std::string Type;	/* required element of XSD type xsd:string */
	tt__Vector *Pos;	/* optional element of XSD type tt:Vector */
	tt__OSDPosConfigurationExtension *Extension;	/* optional element of XSD type tt:OSDPosConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDPosConfiguration (752)
	virtual int soap_type(void) const { return 752; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDPosConfiguration, default initialized and not managed by a soap context
	virtual tt__OSDPosConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__OSDPosConfiguration); }
	         tt__OSDPosConfiguration() { tt__OSDPosConfiguration::soap_default(NULL); }
	virtual ~tt__OSDPosConfiguration() { }
	friend SOAP_FMAC1 tt__OSDPosConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDPosConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2254 */
#ifndef SOAP_TYPE_tt__OSDPosConfigurationExtension
#define SOAP_TYPE_tt__OSDPosConfigurationExtension (753)
/* tt:OSDPosConfigurationExtension complex type: */
class SOAP_CMAC tt__OSDPosConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDPosConfigurationExtension (753)
	virtual int soap_type(void) const { return 753; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDPosConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__OSDPosConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDPosConfigurationExtension); }
	         tt__OSDPosConfigurationExtension() { tt__OSDPosConfigurationExtension::soap_default(NULL); }
	virtual ~tt__OSDPosConfigurationExtension() { }
	friend SOAP_FMAC1 tt__OSDPosConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDPosConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2257 */
#ifndef SOAP_TYPE_tt__OSDColor
#define SOAP_TYPE_tt__OSDColor (754)
/* tt:OSDColor complex type: */
class SOAP_CMAC tt__OSDColor
{
public:
	tt__Color *Color;	/* required element of XSD type tt:Color */
	int *Transparent;	/* optional attribute of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDColor (754)
	virtual int soap_type(void) const { return 754; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDColor, default initialized and not managed by a soap context
	virtual tt__OSDColor *soap_alloc(void) const { return SOAP_NEW(tt__OSDColor); }
	         tt__OSDColor() { tt__OSDColor::soap_default(NULL); }
	virtual ~tt__OSDColor() { }
	friend SOAP_FMAC1 tt__OSDColor * SOAP_FMAC2 soap_instantiate_tt__OSDColor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2260 */
#ifndef SOAP_TYPE_tt__OSDTextConfiguration
#define SOAP_TYPE_tt__OSDTextConfiguration (755)
/* tt:OSDTextConfiguration complex type: */
class SOAP_CMAC tt__OSDTextConfiguration
{
public:
	std::string Type;	/* required element of XSD type xsd:string */
	std::string *DateFormat;	/* optional element of XSD type xsd:string */
	std::string *TimeFormat;	/* optional element of XSD type xsd:string */
	int *FontSize;	/* optional element of XSD type xsd:int */
	tt__OSDColor *FontColor;	/* optional element of XSD type tt:OSDColor */
	tt__OSDColor *BackgroundColor;	/* optional element of XSD type tt:OSDColor */
	std::string *PlainText;	/* optional element of XSD type xsd:string */
	tt__OSDTextConfigurationExtension *Extension;	/* optional element of XSD type tt:OSDTextConfigurationExtension */
	bool *IsPersistentText;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDTextConfiguration (755)
	virtual int soap_type(void) const { return 755; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDTextConfiguration, default initialized and not managed by a soap context
	virtual tt__OSDTextConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__OSDTextConfiguration); }
	         tt__OSDTextConfiguration() { tt__OSDTextConfiguration::soap_default(NULL); }
	virtual ~tt__OSDTextConfiguration() { }
	friend SOAP_FMAC1 tt__OSDTextConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDTextConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2263 */
#ifndef SOAP_TYPE_tt__OSDTextConfigurationExtension
#define SOAP_TYPE_tt__OSDTextConfigurationExtension (756)
/* tt:OSDTextConfigurationExtension complex type: */
class SOAP_CMAC tt__OSDTextConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDTextConfigurationExtension (756)
	virtual int soap_type(void) const { return 756; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDTextConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__OSDTextConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDTextConfigurationExtension); }
	         tt__OSDTextConfigurationExtension() { tt__OSDTextConfigurationExtension::soap_default(NULL); }
	virtual ~tt__OSDTextConfigurationExtension() { }
	friend SOAP_FMAC1 tt__OSDTextConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDTextConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2266 */
#ifndef SOAP_TYPE_tt__OSDImgConfiguration
#define SOAP_TYPE_tt__OSDImgConfiguration (757)
/* tt:OSDImgConfiguration complex type: */
class SOAP_CMAC tt__OSDImgConfiguration
{
public:
	std::string ImgPath;	/* required element of XSD type xsd:anyURI */
	tt__OSDImgConfigurationExtension *Extension;	/* optional element of XSD type tt:OSDImgConfigurationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDImgConfiguration (757)
	virtual int soap_type(void) const { return 757; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDImgConfiguration, default initialized and not managed by a soap context
	virtual tt__OSDImgConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__OSDImgConfiguration); }
	         tt__OSDImgConfiguration() { tt__OSDImgConfiguration::soap_default(NULL); }
	virtual ~tt__OSDImgConfiguration() { }
	friend SOAP_FMAC1 tt__OSDImgConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDImgConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2269 */
#ifndef SOAP_TYPE_tt__OSDImgConfigurationExtension
#define SOAP_TYPE_tt__OSDImgConfigurationExtension (758)
/* tt:OSDImgConfigurationExtension complex type: */
class SOAP_CMAC tt__OSDImgConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDImgConfigurationExtension (758)
	virtual int soap_type(void) const { return 758; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDImgConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__OSDImgConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDImgConfigurationExtension); }
	         tt__OSDImgConfigurationExtension() { tt__OSDImgConfigurationExtension::soap_default(NULL); }
	virtual ~tt__OSDImgConfigurationExtension() { }
	friend SOAP_FMAC1 tt__OSDImgConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDImgConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2272 */
#ifndef SOAP_TYPE_tt__ColorspaceRange
#define SOAP_TYPE_tt__ColorspaceRange (759)
/* tt:ColorspaceRange complex type: */
class SOAP_CMAC tt__ColorspaceRange
{
public:
	tt__FloatRange *X;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Y;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Z;	/* required element of XSD type tt:FloatRange */
	std::string Colorspace;	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ColorspaceRange (759)
	virtual int soap_type(void) const { return 759; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ColorspaceRange, default initialized and not managed by a soap context
	virtual tt__ColorspaceRange *soap_alloc(void) const { return SOAP_NEW(tt__ColorspaceRange); }
	         tt__ColorspaceRange() { tt__ColorspaceRange::soap_default(NULL); }
	virtual ~tt__ColorspaceRange() { }
	friend SOAP_FMAC1 tt__ColorspaceRange * SOAP_FMAC2 soap_instantiate_tt__ColorspaceRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:23986 */
#ifndef SOAP_TYPE__tt__union_ColorOptions
#define SOAP_TYPE__tt__union_ColorOptions (1492)
/* xsd:choice complex type: */
union _tt__union_ColorOptions
{
#define SOAP_UNION__tt__union_ColorOptions_ColorList	(1)
	std::vector<tt__Color *> *ColorList;
#define SOAP_UNION__tt__union_ColorOptions_ColorspaceRange	(2)
	std::vector<tt__ColorspaceRange *> *ColorspaceRange;
};
#endif

/* onvif.h:2275 */
#ifndef SOAP_TYPE_tt__ColorOptions
#define SOAP_TYPE_tt__ColorOptions (760)
/* Choice: */
class SOAP_CMAC tt__ColorOptions
{
public:
	int __union_ColorOptions;	/* union discriminant (of union defined below) */
	union _tt__union_ColorOptions union_ColorOptions;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ColorOptions (760)
	virtual int soap_type(void) const { return 760; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ColorOptions, default initialized and not managed by a soap context
	virtual tt__ColorOptions *soap_alloc(void) const { return SOAP_NEW(tt__ColorOptions); }
	         tt__ColorOptions() { tt__ColorOptions::soap_default(NULL); }
	virtual ~tt__ColorOptions() { }
	friend SOAP_FMAC1 tt__ColorOptions * SOAP_FMAC2 soap_instantiate_tt__ColorOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2278 */
#ifndef SOAP_TYPE_tt__OSDColorOptions
#define SOAP_TYPE_tt__OSDColorOptions (761)
/* tt:OSDColorOptions complex type: */
class SOAP_CMAC tt__OSDColorOptions
{
public:
	tt__ColorOptions *Color;	/* optional element of XSD type tt:ColorOptions */
	tt__IntRange *Transparent;	/* optional element of XSD type tt:IntRange */
	tt__OSDColorOptionsExtension *Extension;	/* optional element of XSD type tt:OSDColorOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDColorOptions (761)
	virtual int soap_type(void) const { return 761; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDColorOptions, default initialized and not managed by a soap context
	virtual tt__OSDColorOptions *soap_alloc(void) const { return SOAP_NEW(tt__OSDColorOptions); }
	         tt__OSDColorOptions() { tt__OSDColorOptions::soap_default(NULL); }
	virtual ~tt__OSDColorOptions() { }
	friend SOAP_FMAC1 tt__OSDColorOptions * SOAP_FMAC2 soap_instantiate_tt__OSDColorOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2281 */
#ifndef SOAP_TYPE_tt__OSDColorOptionsExtension
#define SOAP_TYPE_tt__OSDColorOptionsExtension (762)
/* tt:OSDColorOptionsExtension complex type: */
class SOAP_CMAC tt__OSDColorOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDColorOptionsExtension (762)
	virtual int soap_type(void) const { return 762; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDColorOptionsExtension, default initialized and not managed by a soap context
	virtual tt__OSDColorOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDColorOptionsExtension); }
	         tt__OSDColorOptionsExtension() { tt__OSDColorOptionsExtension::soap_default(NULL); }
	virtual ~tt__OSDColorOptionsExtension() { }
	friend SOAP_FMAC1 tt__OSDColorOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDColorOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2284 */
#ifndef SOAP_TYPE_tt__OSDTextOptions
#define SOAP_TYPE_tt__OSDTextOptions (763)
/* tt:OSDTextOptions complex type: */
class SOAP_CMAC tt__OSDTextOptions
{
public:
	std::vector<std::string> Type;	/* required element of XSD type xsd:string */
	tt__IntRange *FontSizeRange;	/* optional element of XSD type tt:IntRange */
	std::vector<std::string> DateFormat;	/* optional element of XSD type xsd:string */
	std::vector<std::string> TimeFormat;	/* optional element of XSD type xsd:string */
	tt__OSDColorOptions *FontColor;	/* optional element of XSD type tt:OSDColorOptions */
	tt__OSDColorOptions *BackgroundColor;	/* optional element of XSD type tt:OSDColorOptions */
	tt__OSDTextOptionsExtension *Extension;	/* optional element of XSD type tt:OSDTextOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDTextOptions (763)
	virtual int soap_type(void) const { return 763; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDTextOptions, default initialized and not managed by a soap context
	virtual tt__OSDTextOptions *soap_alloc(void) const { return SOAP_NEW(tt__OSDTextOptions); }
	         tt__OSDTextOptions() { tt__OSDTextOptions::soap_default(NULL); }
	virtual ~tt__OSDTextOptions() { }
	friend SOAP_FMAC1 tt__OSDTextOptions * SOAP_FMAC2 soap_instantiate_tt__OSDTextOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2287 */
#ifndef SOAP_TYPE_tt__OSDTextOptionsExtension
#define SOAP_TYPE_tt__OSDTextOptionsExtension (764)
/* tt:OSDTextOptionsExtension complex type: */
class SOAP_CMAC tt__OSDTextOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDTextOptionsExtension (764)
	virtual int soap_type(void) const { return 764; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDTextOptionsExtension, default initialized and not managed by a soap context
	virtual tt__OSDTextOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDTextOptionsExtension); }
	         tt__OSDTextOptionsExtension() { tt__OSDTextOptionsExtension::soap_default(NULL); }
	virtual ~tt__OSDTextOptionsExtension() { }
	friend SOAP_FMAC1 tt__OSDTextOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDTextOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2290 */
#ifndef SOAP_TYPE_tt__OSDImgOptions
#define SOAP_TYPE_tt__OSDImgOptions (765)
/* tt:OSDImgOptions complex type: */
class SOAP_CMAC tt__OSDImgOptions
{
public:
	std::vector<std::string> ImagePath;	/* required element of XSD type xsd:anyURI */
	tt__OSDImgOptionsExtension *Extension;	/* optional element of XSD type tt:OSDImgOptionsExtension */
	std::string *FormatsSupported;	/* optional attribute of XSD type tt:StringAttrList */
	int *MaxSize;	/* optional attribute of XSD type xsd:int */
	int *MaxWidth;	/* optional attribute of XSD type xsd:int */
	int *MaxHeight;	/* optional attribute of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDImgOptions (765)
	virtual int soap_type(void) const { return 765; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDImgOptions, default initialized and not managed by a soap context
	virtual tt__OSDImgOptions *soap_alloc(void) const { return SOAP_NEW(tt__OSDImgOptions); }
	         tt__OSDImgOptions() { tt__OSDImgOptions::soap_default(NULL); }
	virtual ~tt__OSDImgOptions() { }
	friend SOAP_FMAC1 tt__OSDImgOptions * SOAP_FMAC2 soap_instantiate_tt__OSDImgOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2293 */
#ifndef SOAP_TYPE_tt__OSDImgOptionsExtension
#define SOAP_TYPE_tt__OSDImgOptionsExtension (766)
/* tt:OSDImgOptionsExtension complex type: */
class SOAP_CMAC tt__OSDImgOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDImgOptionsExtension (766)
	virtual int soap_type(void) const { return 766; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDImgOptionsExtension, default initialized and not managed by a soap context
	virtual tt__OSDImgOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDImgOptionsExtension); }
	         tt__OSDImgOptionsExtension() { tt__OSDImgOptionsExtension::soap_default(NULL); }
	virtual ~tt__OSDImgOptionsExtension() { }
	friend SOAP_FMAC1 tt__OSDImgOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDImgOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2299 */
#ifndef SOAP_TYPE_tt__OSDConfigurationExtension
#define SOAP_TYPE_tt__OSDConfigurationExtension (768)
/* tt:OSDConfigurationExtension complex type: */
class SOAP_CMAC tt__OSDConfigurationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDConfigurationExtension (768)
	virtual int soap_type(void) const { return 768; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__OSDConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDConfigurationExtension); }
	         tt__OSDConfigurationExtension() { tt__OSDConfigurationExtension::soap_default(NULL); }
	virtual ~tt__OSDConfigurationExtension() { }
	friend SOAP_FMAC1 tt__OSDConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2302 */
#ifndef SOAP_TYPE_tt__MaximumNumberOfOSDs
#define SOAP_TYPE_tt__MaximumNumberOfOSDs (769)
/* tt:MaximumNumberOfOSDs complex type: */
class SOAP_CMAC tt__MaximumNumberOfOSDs
{
public:
	int Total;	/* required attribute of XSD type xsd:int */
	int *Image;	/* optional attribute of XSD type xsd:int */
	int *PlainText;	/* optional attribute of XSD type xsd:int */
	int *Date;	/* optional attribute of XSD type xsd:int */
	int *Time;	/* optional attribute of XSD type xsd:int */
	int *DateAndTime;	/* optional attribute of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MaximumNumberOfOSDs (769)
	virtual int soap_type(void) const { return 769; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MaximumNumberOfOSDs, default initialized and not managed by a soap context
	virtual tt__MaximumNumberOfOSDs *soap_alloc(void) const { return SOAP_NEW(tt__MaximumNumberOfOSDs); }
	         tt__MaximumNumberOfOSDs() { tt__MaximumNumberOfOSDs::soap_default(NULL); }
	virtual ~tt__MaximumNumberOfOSDs() { }
	friend SOAP_FMAC1 tt__MaximumNumberOfOSDs * SOAP_FMAC2 soap_instantiate_tt__MaximumNumberOfOSDs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2305 */
#ifndef SOAP_TYPE_tt__OSDConfigurationOptions
#define SOAP_TYPE_tt__OSDConfigurationOptions (770)
/* tt:OSDConfigurationOptions complex type: */
class SOAP_CMAC tt__OSDConfigurationOptions
{
public:
	tt__MaximumNumberOfOSDs *MaximumNumberOfOSDs;	/* required element of XSD type tt:MaximumNumberOfOSDs */
	std::vector<enum tt__OSDType> Type;	/* required element of XSD type tt:OSDType */
	std::vector<std::string> PositionOption;	/* required element of XSD type xsd:string */
	tt__OSDTextOptions *TextOption;	/* optional element of XSD type tt:OSDTextOptions */
	tt__OSDImgOptions *ImageOption;	/* optional element of XSD type tt:OSDImgOptions */
	tt__OSDConfigurationOptionsExtension *Extension;	/* optional element of XSD type tt:OSDConfigurationOptionsExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDConfigurationOptions (770)
	virtual int soap_type(void) const { return 770; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__OSDConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__OSDConfigurationOptions); }
	         tt__OSDConfigurationOptions() { tt__OSDConfigurationOptions::soap_default(NULL); }
	virtual ~tt__OSDConfigurationOptions() { }
	friend SOAP_FMAC1 tt__OSDConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__OSDConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2308 */
#ifndef SOAP_TYPE_tt__OSDConfigurationOptionsExtension
#define SOAP_TYPE_tt__OSDConfigurationOptionsExtension (771)
/* tt:OSDConfigurationOptionsExtension complex type: */
class SOAP_CMAC tt__OSDConfigurationOptionsExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDConfigurationOptionsExtension (771)
	virtual int soap_type(void) const { return 771; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDConfigurationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__OSDConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__OSDConfigurationOptionsExtension); }
	         tt__OSDConfigurationOptionsExtension() { tt__OSDConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__OSDConfigurationOptionsExtension() { }
	friend SOAP_FMAC1 tt__OSDConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2311 */
#ifndef SOAP_TYPE_tt__FileProgress
#define SOAP_TYPE_tt__FileProgress (772)
/* tt:FileProgress complex type: */
class SOAP_CMAC tt__FileProgress
{
public:
	std::string FileName;	/* required element of XSD type xsd:string */
	float Progress;	/* required element of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FileProgress (772)
	virtual int soap_type(void) const { return 772; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FileProgress, default initialized and not managed by a soap context
	virtual tt__FileProgress *soap_alloc(void) const { return SOAP_NEW(tt__FileProgress); }
	         tt__FileProgress() { tt__FileProgress::soap_default(NULL); }
	virtual ~tt__FileProgress() { }
	friend SOAP_FMAC1 tt__FileProgress * SOAP_FMAC2 soap_instantiate_tt__FileProgress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2314 */
#ifndef SOAP_TYPE_tt__ArrayOfFileProgress
#define SOAP_TYPE_tt__ArrayOfFileProgress (773)
/* tt:ArrayOfFileProgress complex type: */
class SOAP_CMAC tt__ArrayOfFileProgress
{
public:
	std::vector<tt__FileProgress *> FileProgress;	/* optional element of XSD type tt:FileProgress */
	tt__ArrayOfFileProgressExtension *Extension;	/* optional element of XSD type tt:ArrayOfFileProgressExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ArrayOfFileProgress (773)
	virtual int soap_type(void) const { return 773; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ArrayOfFileProgress, default initialized and not managed by a soap context
	virtual tt__ArrayOfFileProgress *soap_alloc(void) const { return SOAP_NEW(tt__ArrayOfFileProgress); }
	         tt__ArrayOfFileProgress() { tt__ArrayOfFileProgress::soap_default(NULL); }
	virtual ~tt__ArrayOfFileProgress() { }
	friend SOAP_FMAC1 tt__ArrayOfFileProgress * SOAP_FMAC2 soap_instantiate_tt__ArrayOfFileProgress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2317 */
#ifndef SOAP_TYPE_tt__ArrayOfFileProgressExtension
#define SOAP_TYPE_tt__ArrayOfFileProgressExtension (774)
/* tt:ArrayOfFileProgressExtension complex type: */
class SOAP_CMAC tt__ArrayOfFileProgressExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ArrayOfFileProgressExtension (774)
	virtual int soap_type(void) const { return 774; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ArrayOfFileProgressExtension, default initialized and not managed by a soap context
	virtual tt__ArrayOfFileProgressExtension *soap_alloc(void) const { return SOAP_NEW(tt__ArrayOfFileProgressExtension); }
	         tt__ArrayOfFileProgressExtension() { tt__ArrayOfFileProgressExtension::soap_default(NULL); }
	virtual ~tt__ArrayOfFileProgressExtension() { }
	friend SOAP_FMAC1 tt__ArrayOfFileProgressExtension * SOAP_FMAC2 soap_instantiate_tt__ArrayOfFileProgressExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2320 */
#ifndef SOAP_TYPE_tt__StorageReferencePath
#define SOAP_TYPE_tt__StorageReferencePath (775)
/* tt:StorageReferencePath complex type: */
class SOAP_CMAC tt__StorageReferencePath
{
public:
	std::string StorageToken;	/* required element of XSD type tt:ReferenceToken */
	std::string *RelativePath;	/* optional element of XSD type xsd:string */
	tt__StorageReferencePathExtension *Extension;	/* optional element of XSD type tt:StorageReferencePathExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__StorageReferencePath (775)
	virtual int soap_type(void) const { return 775; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__StorageReferencePath, default initialized and not managed by a soap context
	virtual tt__StorageReferencePath *soap_alloc(void) const { return SOAP_NEW(tt__StorageReferencePath); }
	         tt__StorageReferencePath() { tt__StorageReferencePath::soap_default(NULL); }
	virtual ~tt__StorageReferencePath() { }
	friend SOAP_FMAC1 tt__StorageReferencePath * SOAP_FMAC2 soap_instantiate_tt__StorageReferencePath(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2323 */
#ifndef SOAP_TYPE_tt__StorageReferencePathExtension
#define SOAP_TYPE_tt__StorageReferencePathExtension (776)
/* tt:StorageReferencePathExtension complex type: */
class SOAP_CMAC tt__StorageReferencePathExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__StorageReferencePathExtension (776)
	virtual int soap_type(void) const { return 776; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__StorageReferencePathExtension, default initialized and not managed by a soap context
	virtual tt__StorageReferencePathExtension *soap_alloc(void) const { return SOAP_NEW(tt__StorageReferencePathExtension); }
	         tt__StorageReferencePathExtension() { tt__StorageReferencePathExtension::soap_default(NULL); }
	virtual ~tt__StorageReferencePathExtension() { }
	friend SOAP_FMAC1 tt__StorageReferencePathExtension * SOAP_FMAC2 soap_instantiate_tt__StorageReferencePathExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2326 */
#ifndef SOAP_TYPE_tt__Vector2D
#define SOAP_TYPE_tt__Vector2D (777)
/* tt:Vector2D complex type: */
class SOAP_CMAC tt__Vector2D
{
public:
	float x;	/* required attribute of XSD type xsd:float */
	float y;	/* required attribute of XSD type xsd:float */
	std::string *space;	/* optional attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Vector2D (777)
	virtual int soap_type(void) const { return 777; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Vector2D, default initialized and not managed by a soap context
	virtual tt__Vector2D *soap_alloc(void) const { return SOAP_NEW(tt__Vector2D); }
	         tt__Vector2D() { tt__Vector2D::soap_default(NULL); }
	virtual ~tt__Vector2D() { }
	friend SOAP_FMAC1 tt__Vector2D * SOAP_FMAC2 soap_instantiate_tt__Vector2D(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2329 */
#ifndef SOAP_TYPE_tt__Vector1D
#define SOAP_TYPE_tt__Vector1D (778)
/* tt:Vector1D complex type: */
class SOAP_CMAC tt__Vector1D
{
public:
	float x;	/* required attribute of XSD type xsd:float */
	std::string *space;	/* optional attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Vector1D (778)
	virtual int soap_type(void) const { return 778; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Vector1D, default initialized and not managed by a soap context
	virtual tt__Vector1D *soap_alloc(void) const { return SOAP_NEW(tt__Vector1D); }
	         tt__Vector1D() { tt__Vector1D::soap_default(NULL); }
	virtual ~tt__Vector1D() { }
	friend SOAP_FMAC1 tt__Vector1D * SOAP_FMAC2 soap_instantiate_tt__Vector1D(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2332 */
#ifndef SOAP_TYPE_tt__PTZVector
#define SOAP_TYPE_tt__PTZVector (779)
/* tt:PTZVector complex type: */
class SOAP_CMAC tt__PTZVector
{
public:
	tt__Vector2D *PanTilt;	/* optional element of XSD type tt:Vector2D */
	tt__Vector1D *Zoom;	/* optional element of XSD type tt:Vector1D */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZVector (779)
	virtual int soap_type(void) const { return 779; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZVector, default initialized and not managed by a soap context
	virtual tt__PTZVector *soap_alloc(void) const { return SOAP_NEW(tt__PTZVector); }
	         tt__PTZVector() { tt__PTZVector::soap_default(NULL); }
	virtual ~tt__PTZVector() { }
	friend SOAP_FMAC1 tt__PTZVector * SOAP_FMAC2 soap_instantiate_tt__PTZVector(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2335 */
#ifndef SOAP_TYPE_tt__PTZStatus
#define SOAP_TYPE_tt__PTZStatus (780)
/* tt:PTZStatus complex type: */
class SOAP_CMAC tt__PTZStatus
{
public:
	tt__PTZVector *Position;	/* optional element of XSD type tt:PTZVector */
	tt__PTZMoveStatus *MoveStatus;	/* optional element of XSD type tt:PTZMoveStatus */
	std::string *Error;	/* optional element of XSD type xsd:string */
	time_t UtcTime;	/* required element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZStatus (780)
	virtual int soap_type(void) const { return 780; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZStatus, default initialized and not managed by a soap context
	virtual tt__PTZStatus *soap_alloc(void) const { return SOAP_NEW(tt__PTZStatus); }
	         tt__PTZStatus() { tt__PTZStatus::soap_default(NULL); }
	virtual ~tt__PTZStatus() { }
	friend SOAP_FMAC1 tt__PTZStatus * SOAP_FMAC2 soap_instantiate_tt__PTZStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2338 */
#ifndef SOAP_TYPE_tt__PTZMoveStatus
#define SOAP_TYPE_tt__PTZMoveStatus (781)
/* tt:PTZMoveStatus complex type: */
class SOAP_CMAC tt__PTZMoveStatus
{
public:
	enum tt__MoveStatus *PanTilt;	/* optional element of XSD type tt:MoveStatus */
	enum tt__MoveStatus *Zoom;	/* optional element of XSD type tt:MoveStatus */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZMoveStatus (781)
	virtual int soap_type(void) const { return 781; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZMoveStatus, default initialized and not managed by a soap context
	virtual tt__PTZMoveStatus *soap_alloc(void) const { return SOAP_NEW(tt__PTZMoveStatus); }
	         tt__PTZMoveStatus() { tt__PTZMoveStatus::soap_default(NULL); }
	virtual ~tt__PTZMoveStatus() { }
	friend SOAP_FMAC1 tt__PTZMoveStatus * SOAP_FMAC2 soap_instantiate_tt__PTZMoveStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2341 */
#ifndef SOAP_TYPE_tt__Vector
#define SOAP_TYPE_tt__Vector (782)
/* tt:Vector complex type: */
class SOAP_CMAC tt__Vector
{
public:
	float *x;	/* optional attribute of XSD type xsd:float */
	float *y;	/* optional attribute of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Vector (782)
	virtual int soap_type(void) const { return 782; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Vector, default initialized and not managed by a soap context
	virtual tt__Vector *soap_alloc(void) const { return SOAP_NEW(tt__Vector); }
	         tt__Vector() { tt__Vector::soap_default(NULL); }
	virtual ~tt__Vector() { }
	friend SOAP_FMAC1 tt__Vector * SOAP_FMAC2 soap_instantiate_tt__Vector(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2344 */
#ifndef SOAP_TYPE_tt__Rectangle
#define SOAP_TYPE_tt__Rectangle (783)
/* tt:Rectangle complex type: */
class SOAP_CMAC tt__Rectangle
{
public:
	float *bottom;	/* optional attribute of XSD type xsd:float */
	float *top;	/* optional attribute of XSD type xsd:float */
	float *right;	/* optional attribute of XSD type xsd:float */
	float *left;	/* optional attribute of XSD type xsd:float */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Rectangle (783)
	virtual int soap_type(void) const { return 783; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Rectangle, default initialized and not managed by a soap context
	virtual tt__Rectangle *soap_alloc(void) const { return SOAP_NEW(tt__Rectangle); }
	         tt__Rectangle() { tt__Rectangle::soap_default(NULL); }
	virtual ~tt__Rectangle() { }
	friend SOAP_FMAC1 tt__Rectangle * SOAP_FMAC2 soap_instantiate_tt__Rectangle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2347 */
#ifndef SOAP_TYPE_tt__Polygon
#define SOAP_TYPE_tt__Polygon (784)
/* tt:Polygon complex type: */
class SOAP_CMAC tt__Polygon
{
public:
	std::vector<tt__Vector *> Point;	/* required element of XSD type tt:Vector */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Polygon (784)
	virtual int soap_type(void) const { return 784; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Polygon, default initialized and not managed by a soap context
	virtual tt__Polygon *soap_alloc(void) const { return SOAP_NEW(tt__Polygon); }
	         tt__Polygon() { tt__Polygon::soap_default(NULL); }
	virtual ~tt__Polygon() { }
	friend SOAP_FMAC1 tt__Polygon * SOAP_FMAC2 soap_instantiate_tt__Polygon(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2350 */
#ifndef SOAP_TYPE_tt__Color
#define SOAP_TYPE_tt__Color (785)
/* tt:Color complex type: */
class SOAP_CMAC tt__Color
{
public:
	float X;	/* required attribute of XSD type xsd:float */
	float Y;	/* required attribute of XSD type xsd:float */
	float Z;	/* required attribute of XSD type xsd:float */
	std::string *Colorspace;	/* optional attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Color (785)
	virtual int soap_type(void) const { return 785; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Color, default initialized and not managed by a soap context
	virtual tt__Color *soap_alloc(void) const { return SOAP_NEW(tt__Color); }
	         tt__Color() { tt__Color::soap_default(NULL); }
	virtual ~tt__Color() { }
	friend SOAP_FMAC1 tt__Color * SOAP_FMAC2 soap_instantiate_tt__Color(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2353 */
#ifndef SOAP_TYPE_tt__ColorCovariance
#define SOAP_TYPE_tt__ColorCovariance (786)
/* tt:ColorCovariance complex type: */
class SOAP_CMAC tt__ColorCovariance
{
public:
	float XX;	/* required attribute of XSD type xsd:float */
	float YY;	/* required attribute of XSD type xsd:float */
	float ZZ;	/* required attribute of XSD type xsd:float */
	float *XY;	/* optional attribute of XSD type xsd:float */
	float *XZ;	/* optional attribute of XSD type xsd:float */
	float *YZ;	/* optional attribute of XSD type xsd:float */
	std::string *Colorspace;	/* optional attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ColorCovariance (786)
	virtual int soap_type(void) const { return 786; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ColorCovariance, default initialized and not managed by a soap context
	virtual tt__ColorCovariance *soap_alloc(void) const { return SOAP_NEW(tt__ColorCovariance); }
	         tt__ColorCovariance() { tt__ColorCovariance::soap_default(NULL); }
	virtual ~tt__ColorCovariance() { }
	friend SOAP_FMAC1 tt__ColorCovariance * SOAP_FMAC2 soap_instantiate_tt__ColorCovariance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2356 */
#ifndef SOAP_TYPE_tt__Transformation
#define SOAP_TYPE_tt__Transformation (787)
/* tt:Transformation complex type: */
class SOAP_CMAC tt__Transformation
{
public:
	tt__Vector *Translate;	/* optional element of XSD type tt:Vector */
	tt__Vector *Scale;	/* optional element of XSD type tt:Vector */
	tt__TransformationExtension *Extension;	/* optional element of XSD type tt:TransformationExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Transformation (787)
	virtual int soap_type(void) const { return 787; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Transformation, default initialized and not managed by a soap context
	virtual tt__Transformation *soap_alloc(void) const { return SOAP_NEW(tt__Transformation); }
	         tt__Transformation() { tt__Transformation::soap_default(NULL); }
	virtual ~tt__Transformation() { }
	friend SOAP_FMAC1 tt__Transformation * SOAP_FMAC2 soap_instantiate_tt__Transformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2359 */
#ifndef SOAP_TYPE_tt__TransformationExtension
#define SOAP_TYPE_tt__TransformationExtension (788)
/* tt:TransformationExtension complex type: */
class SOAP_CMAC tt__TransformationExtension
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TransformationExtension (788)
	virtual int soap_type(void) const { return 788; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TransformationExtension, default initialized and not managed by a soap context
	virtual tt__TransformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__TransformationExtension); }
	         tt__TransformationExtension() { tt__TransformationExtension::soap_default(NULL); }
	virtual ~tt__TransformationExtension() { }
	friend SOAP_FMAC1 tt__TransformationExtension * SOAP_FMAC2 soap_instantiate_tt__TransformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2362 */
#ifndef SOAP_TYPE__tt__Message
#define SOAP_TYPE__tt__Message (789)
/* tt:Message complex type: */
class SOAP_CMAC _tt__Message
{
public:
	tt__ItemList *Source;	/* optional element of XSD type tt:ItemList */
	tt__ItemList *Key;	/* optional element of XSD type tt:ItemList */
	tt__ItemList *Data;	/* optional element of XSD type tt:ItemList */
	tt__MessageExtension *Extension;	/* optional element of XSD type tt:MessageExtension */
	time_t UtcTime;	/* required attribute of XSD type xsd:dateTime */
	enum tt__PropertyOperation *PropertyOperation;	/* optional attribute of XSD type tt:PropertyOperation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__Message (789)
	virtual int soap_type(void) const { return 789; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__Message, default initialized and not managed by a soap context
	virtual _tt__Message *soap_alloc(void) const { return SOAP_NEW(_tt__Message); }
	         _tt__Message() { _tt__Message::soap_default(NULL); }
	virtual ~_tt__Message() { }
	friend SOAP_FMAC1 _tt__Message * SOAP_FMAC2 soap_instantiate__tt__Message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2365 */
#ifndef SOAP_TYPE_wsnt__QueryExpressionType
#define SOAP_TYPE_wsnt__QueryExpressionType (790)
/* wsnt:QueryExpressionType complex type: */
class SOAP_CMAC wsnt__QueryExpressionType
{
public:
	std::string Dialect;	/* required attribute of XSD type xsd:anyURI */
	char *__mixed;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__QueryExpressionType (790)
	virtual int soap_type(void) const { return 790; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__QueryExpressionType, default initialized and not managed by a soap context
	virtual wsnt__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW(wsnt__QueryExpressionType); }
	         wsnt__QueryExpressionType() { wsnt__QueryExpressionType::soap_default(NULL); }
	virtual ~wsnt__QueryExpressionType() { }
	friend SOAP_FMAC1 wsnt__QueryExpressionType * SOAP_FMAC2 soap_instantiate_wsnt__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2368 */
#ifndef SOAP_TYPE_wsnt__TopicExpressionType
#define SOAP_TYPE_wsnt__TopicExpressionType (791)
/* wsnt:TopicExpressionType complex type: */
class SOAP_CMAC wsnt__TopicExpressionType
{
public:
	std::string Dialect;	/* required attribute of XSD type xsd:anyURI */
	char *__mixed;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__TopicExpressionType (791)
	virtual int soap_type(void) const { return 791; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__TopicExpressionType, default initialized and not managed by a soap context
	virtual wsnt__TopicExpressionType *soap_alloc(void) const { return SOAP_NEW(wsnt__TopicExpressionType); }
	         wsnt__TopicExpressionType() { wsnt__TopicExpressionType::soap_default(NULL); }
	virtual ~wsnt__TopicExpressionType() { }
	friend SOAP_FMAC1 wsnt__TopicExpressionType * SOAP_FMAC2 soap_instantiate_wsnt__TopicExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2371 */
#ifndef SOAP_TYPE_wsnt__FilterType
#define SOAP_TYPE_wsnt__FilterType (792)
/* Type wsnt__FilterType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:FilterType complex type: */
class SOAP_CMAC wsnt__FilterType
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__FilterType (792)
	virtual int soap_type(void) const { return 792; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__FilterType, default initialized and not managed by a soap context
	virtual wsnt__FilterType *soap_alloc(void) const { return SOAP_NEW(wsnt__FilterType); }
	         wsnt__FilterType() { wsnt__FilterType::soap_default(NULL); }
	virtual ~wsnt__FilterType() { }
	friend SOAP_FMAC1 wsnt__FilterType * SOAP_FMAC2 soap_instantiate_wsnt__FilterType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2374 */
#ifndef SOAP_TYPE_wsnt__SubscriptionPolicyType
#define SOAP_TYPE_wsnt__SubscriptionPolicyType (793)
/* wsnt:SubscriptionPolicyType complex type: */
class SOAP_CMAC wsnt__SubscriptionPolicyType
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__SubscriptionPolicyType (793)
	virtual int soap_type(void) const { return 793; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__SubscriptionPolicyType, default initialized and not managed by a soap context
	virtual wsnt__SubscriptionPolicyType *soap_alloc(void) const { return SOAP_NEW(wsnt__SubscriptionPolicyType); }
	         wsnt__SubscriptionPolicyType() { wsnt__SubscriptionPolicyType::soap_default(NULL); }
	virtual ~wsnt__SubscriptionPolicyType() { }
	friend SOAP_FMAC1 wsnt__SubscriptionPolicyType * SOAP_FMAC2 soap_instantiate_wsnt__SubscriptionPolicyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:25056 */
#ifndef SOAP_TYPE__wsnt__NotificationMessageHolderType_Message
#define SOAP_TYPE__wsnt__NotificationMessageHolderType_Message (1514)
/* wsnt:NotificationMessageHolderType-Message complex type: */
class SOAP_CMAC _wsnt__NotificationMessageHolderType_Message
{
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__NotificationMessageHolderType_Message (1514)
	virtual int soap_type(void) const { return 1514; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__NotificationMessageHolderType_Message, default initialized and not managed by a soap context
	virtual _wsnt__NotificationMessageHolderType_Message *soap_alloc(void) const { return SOAP_NEW(_wsnt__NotificationMessageHolderType_Message); }
	         _wsnt__NotificationMessageHolderType_Message() { _wsnt__NotificationMessageHolderType_Message::soap_default(NULL); }
	virtual ~_wsnt__NotificationMessageHolderType_Message() { }
	friend SOAP_FMAC1 _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC2 soap_instantiate__wsnt__NotificationMessageHolderType_Message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2377 */
#ifndef SOAP_TYPE_wsnt__NotificationMessageHolderType
#define SOAP_TYPE_wsnt__NotificationMessageHolderType (794)
/* wsnt:NotificationMessageHolderType complex type: */
class SOAP_CMAC wsnt__NotificationMessageHolderType
{
public:
	struct wsa5__EndpointReferenceType *SubscriptionReference;	/* optional element of XSD type wsa5:EndpointReferenceType */
	wsnt__TopicExpressionType *Topic;	/* optional element of XSD type wsnt:TopicExpressionType */
	struct wsa5__EndpointReferenceType *ProducerReference;	/* optional element of XSD type wsa5:EndpointReferenceType */
	_wsnt__NotificationMessageHolderType_Message Message;	/* required element of XSD type wsnt:NotificationMessageHolderType-Message */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__NotificationMessageHolderType (794)
	virtual int soap_type(void) const { return 794; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__NotificationMessageHolderType, default initialized and not managed by a soap context
	virtual wsnt__NotificationMessageHolderType *soap_alloc(void) const { return SOAP_NEW(wsnt__NotificationMessageHolderType); }
	         wsnt__NotificationMessageHolderType() { wsnt__NotificationMessageHolderType::soap_default(NULL); }
	virtual ~wsnt__NotificationMessageHolderType() { }
	friend SOAP_FMAC1 wsnt__NotificationMessageHolderType * SOAP_FMAC2 soap_instantiate_wsnt__NotificationMessageHolderType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2440 */
#ifndef SOAP_TYPE__wsnt__NotificationProducerRP
#define SOAP_TYPE__wsnt__NotificationProducerRP (815)
/* wsnt:NotificationProducerRP complex type: */
class SOAP_CMAC _wsnt__NotificationProducerRP
{
public:
	std::vector<wsnt__TopicExpressionType *> TopicExpression;	/* optional element of XSD type wsnt:TopicExpressionType */
	bool FixedTopicSet;	/* optional element of XSD type xsd:boolean */
	std::vector<std::string> TopicExpressionDialect;	/* optional element of XSD type xsd:anyURI */
	wstop__TopicSetType *wstop__TopicSet;	/* optional element of XSD type wstop:TopicSetType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__NotificationProducerRP (815)
	virtual int soap_type(void) const { return 815; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__NotificationProducerRP, default initialized and not managed by a soap context
	virtual _wsnt__NotificationProducerRP *soap_alloc(void) const { return SOAP_NEW(_wsnt__NotificationProducerRP); }
	         _wsnt__NotificationProducerRP() { _wsnt__NotificationProducerRP::soap_default(NULL); }
	virtual ~_wsnt__NotificationProducerRP() { }
	friend SOAP_FMAC1 _wsnt__NotificationProducerRP * SOAP_FMAC2 soap_instantiate__wsnt__NotificationProducerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2443 */
#ifndef SOAP_TYPE__wsnt__SubscriptionManagerRP
#define SOAP_TYPE__wsnt__SubscriptionManagerRP (816)
/* wsnt:SubscriptionManagerRP complex type: */
class SOAP_CMAC _wsnt__SubscriptionManagerRP
{
public:
	struct wsa5__EndpointReferenceType ConsumerReference;	/* required element of XSD type wsa5:EndpointReferenceType */
	wsnt__FilterType *Filter;	/* optional element of XSD type wsnt:FilterType */
	wsnt__SubscriptionPolicyType *SubscriptionPolicy;	/* optional element of XSD type wsnt:SubscriptionPolicyType */
	time_t *CreationTime;	/* optional element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__SubscriptionManagerRP (816)
	virtual int soap_type(void) const { return 816; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__SubscriptionManagerRP, default initialized and not managed by a soap context
	virtual _wsnt__SubscriptionManagerRP *soap_alloc(void) const { return SOAP_NEW(_wsnt__SubscriptionManagerRP); }
	         _wsnt__SubscriptionManagerRP() { _wsnt__SubscriptionManagerRP::soap_default(NULL); }
	virtual ~_wsnt__SubscriptionManagerRP() { }
	friend SOAP_FMAC1 _wsnt__SubscriptionManagerRP * SOAP_FMAC2 soap_instantiate__wsnt__SubscriptionManagerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2446 */
#ifndef SOAP_TYPE__wsnt__Notify
#define SOAP_TYPE__wsnt__Notify (817)
/* wsnt:Notify complex type: */
class SOAP_CMAC _wsnt__Notify
{
public:
	std::vector<wsnt__NotificationMessageHolderType *> NotificationMessage;	/* required element of XSD type wsnt:NotificationMessageHolderType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Notify (817)
	virtual int soap_type(void) const { return 817; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Notify, default initialized and not managed by a soap context
	virtual _wsnt__Notify *soap_alloc(void) const { return SOAP_NEW(_wsnt__Notify); }
	         _wsnt__Notify() { _wsnt__Notify::soap_default(NULL); }
	virtual ~_wsnt__Notify() { }
	friend SOAP_FMAC1 _wsnt__Notify * SOAP_FMAC2 soap_instantiate__wsnt__Notify(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2449 */
#ifndef SOAP_TYPE__wsnt__UseRaw
#define SOAP_TYPE__wsnt__UseRaw (818)
/* wsnt:UseRaw complex type: */
class SOAP_CMAC _wsnt__UseRaw
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__UseRaw (818)
	virtual int soap_type(void) const { return 818; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__UseRaw, default initialized and not managed by a soap context
	virtual _wsnt__UseRaw *soap_alloc(void) const { return SOAP_NEW(_wsnt__UseRaw); }
	         _wsnt__UseRaw() { _wsnt__UseRaw::soap_default(NULL); }
	virtual ~_wsnt__UseRaw() { }
	friend SOAP_FMAC1 _wsnt__UseRaw * SOAP_FMAC2 soap_instantiate__wsnt__UseRaw(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:25200 */
#ifndef SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy (1520)
/* wsnt:Subscribe-SubscriptionPolicy complex type: */
class SOAP_CMAC _wsnt__Subscribe_SubscriptionPolicy
{
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy (1520)
	virtual int soap_type(void) const { return 1520; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Subscribe_SubscriptionPolicy, default initialized and not managed by a soap context
	virtual _wsnt__Subscribe_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW(_wsnt__Subscribe_SubscriptionPolicy); }
	         _wsnt__Subscribe_SubscriptionPolicy() { _wsnt__Subscribe_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_wsnt__Subscribe_SubscriptionPolicy() { }
	friend SOAP_FMAC1 _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__wsnt__Subscribe_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2452 */
#ifndef SOAP_TYPE__wsnt__Subscribe
#define SOAP_TYPE__wsnt__Subscribe (819)
/* wsnt:Subscribe complex type: */
class SOAP_CMAC _wsnt__Subscribe
{
public:
	struct wsa5__EndpointReferenceType ConsumerReference;	/* required element of XSD type wsa5:EndpointReferenceType */
	wsnt__FilterType *Filter;	/* optional element of XSD type wsnt:FilterType */
	std::string *InitialTerminationTime;	/* optional element of XSD type wsnt:AbsoluteOrRelativeTimeType */
	_wsnt__Subscribe_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of XSD type wsnt:Subscribe-SubscriptionPolicy */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Subscribe (819)
	virtual int soap_type(void) const { return 819; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Subscribe, default initialized and not managed by a soap context
	virtual _wsnt__Subscribe *soap_alloc(void) const { return SOAP_NEW(_wsnt__Subscribe); }
	         _wsnt__Subscribe() { _wsnt__Subscribe::soap_default(NULL); }
	virtual ~_wsnt__Subscribe() { }
	friend SOAP_FMAC1 _wsnt__Subscribe * SOAP_FMAC2 soap_instantiate__wsnt__Subscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2455 */
#ifndef SOAP_TYPE__wsnt__SubscribeResponse
#define SOAP_TYPE__wsnt__SubscribeResponse (820)
/* wsnt:SubscribeResponse complex type: */
class SOAP_CMAC _wsnt__SubscribeResponse
{
public:
	struct wsa5__EndpointReferenceType SubscriptionReference;	/* required element of XSD type wsa5:EndpointReferenceType */
	time_t *CurrentTime;	/* optional element of XSD type xsd:dateTime */
	time_t *TerminationTime;	/* optional element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__SubscribeResponse (820)
	virtual int soap_type(void) const { return 820; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__SubscribeResponse, default initialized and not managed by a soap context
	virtual _wsnt__SubscribeResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__SubscribeResponse); }
	         _wsnt__SubscribeResponse() { _wsnt__SubscribeResponse::soap_default(NULL); }
	virtual ~_wsnt__SubscribeResponse() { }
	friend SOAP_FMAC1 _wsnt__SubscribeResponse * SOAP_FMAC2 soap_instantiate__wsnt__SubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2458 */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessage
#define SOAP_TYPE__wsnt__GetCurrentMessage (821)
/* wsnt:GetCurrentMessage complex type: */
class SOAP_CMAC _wsnt__GetCurrentMessage
{
public:
	wsnt__TopicExpressionType *Topic;	/* required element of XSD type wsnt:TopicExpressionType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__GetCurrentMessage (821)
	virtual int soap_type(void) const { return 821; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__GetCurrentMessage, default initialized and not managed by a soap context
	virtual _wsnt__GetCurrentMessage *soap_alloc(void) const { return SOAP_NEW(_wsnt__GetCurrentMessage); }
	         _wsnt__GetCurrentMessage() { _wsnt__GetCurrentMessage::soap_default(NULL); }
	virtual ~_wsnt__GetCurrentMessage() { }
	friend SOAP_FMAC1 _wsnt__GetCurrentMessage * SOAP_FMAC2 soap_instantiate__wsnt__GetCurrentMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2461 */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessageResponse
#define SOAP_TYPE__wsnt__GetCurrentMessageResponse (822)
/* wsnt:GetCurrentMessageResponse complex type: */
class SOAP_CMAC _wsnt__GetCurrentMessageResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__GetCurrentMessageResponse (822)
	virtual int soap_type(void) const { return 822; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__GetCurrentMessageResponse, default initialized and not managed by a soap context
	virtual _wsnt__GetCurrentMessageResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__GetCurrentMessageResponse); }
	         _wsnt__GetCurrentMessageResponse() { _wsnt__GetCurrentMessageResponse::soap_default(NULL); }
	virtual ~_wsnt__GetCurrentMessageResponse() { }
	friend SOAP_FMAC1 _wsnt__GetCurrentMessageResponse * SOAP_FMAC2 soap_instantiate__wsnt__GetCurrentMessageResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2464 */
#ifndef SOAP_TYPE__wsnt__GetMessages
#define SOAP_TYPE__wsnt__GetMessages (823)
/* wsnt:GetMessages complex type: */
class SOAP_CMAC _wsnt__GetMessages
{
public:
	std::string *MaximumNumber;	/* optional element of XSD type xsd:nonNegativeInteger */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__GetMessages (823)
	virtual int soap_type(void) const { return 823; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__GetMessages, default initialized and not managed by a soap context
	virtual _wsnt__GetMessages *soap_alloc(void) const { return SOAP_NEW(_wsnt__GetMessages); }
	         _wsnt__GetMessages() { _wsnt__GetMessages::soap_default(NULL); }
	virtual ~_wsnt__GetMessages() { }
	friend SOAP_FMAC1 _wsnt__GetMessages * SOAP_FMAC2 soap_instantiate__wsnt__GetMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2467 */
#ifndef SOAP_TYPE__wsnt__GetMessagesResponse
#define SOAP_TYPE__wsnt__GetMessagesResponse (824)
/* wsnt:GetMessagesResponse complex type: */
class SOAP_CMAC _wsnt__GetMessagesResponse
{
public:
	std::vector<wsnt__NotificationMessageHolderType *> NotificationMessage;	/* optional element of XSD type wsnt:NotificationMessageHolderType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__GetMessagesResponse (824)
	virtual int soap_type(void) const { return 824; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__GetMessagesResponse, default initialized and not managed by a soap context
	virtual _wsnt__GetMessagesResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__GetMessagesResponse); }
	         _wsnt__GetMessagesResponse() { _wsnt__GetMessagesResponse::soap_default(NULL); }
	virtual ~_wsnt__GetMessagesResponse() { }
	friend SOAP_FMAC1 _wsnt__GetMessagesResponse * SOAP_FMAC2 soap_instantiate__wsnt__GetMessagesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2470 */
#ifndef SOAP_TYPE__wsnt__DestroyPullPoint
#define SOAP_TYPE__wsnt__DestroyPullPoint (825)
/* wsnt:DestroyPullPoint complex type: */
class SOAP_CMAC _wsnt__DestroyPullPoint
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__DestroyPullPoint (825)
	virtual int soap_type(void) const { return 825; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__DestroyPullPoint, default initialized and not managed by a soap context
	virtual _wsnt__DestroyPullPoint *soap_alloc(void) const { return SOAP_NEW(_wsnt__DestroyPullPoint); }
	         _wsnt__DestroyPullPoint() { _wsnt__DestroyPullPoint::soap_default(NULL); }
	virtual ~_wsnt__DestroyPullPoint() { }
	friend SOAP_FMAC1 _wsnt__DestroyPullPoint * SOAP_FMAC2 soap_instantiate__wsnt__DestroyPullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2473 */
#ifndef SOAP_TYPE__wsnt__DestroyPullPointResponse
#define SOAP_TYPE__wsnt__DestroyPullPointResponse (826)
/* wsnt:DestroyPullPointResponse complex type: */
class SOAP_CMAC _wsnt__DestroyPullPointResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__DestroyPullPointResponse (826)
	virtual int soap_type(void) const { return 826; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__DestroyPullPointResponse, default initialized and not managed by a soap context
	virtual _wsnt__DestroyPullPointResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__DestroyPullPointResponse); }
	         _wsnt__DestroyPullPointResponse() { _wsnt__DestroyPullPointResponse::soap_default(NULL); }
	virtual ~_wsnt__DestroyPullPointResponse() { }
	friend SOAP_FMAC1 _wsnt__DestroyPullPointResponse * SOAP_FMAC2 soap_instantiate__wsnt__DestroyPullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2476 */
#ifndef SOAP_TYPE__wsnt__CreatePullPoint
#define SOAP_TYPE__wsnt__CreatePullPoint (827)
/* wsnt:CreatePullPoint complex type: */
class SOAP_CMAC _wsnt__CreatePullPoint
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__CreatePullPoint (827)
	virtual int soap_type(void) const { return 827; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__CreatePullPoint, default initialized and not managed by a soap context
	virtual _wsnt__CreatePullPoint *soap_alloc(void) const { return SOAP_NEW(_wsnt__CreatePullPoint); }
	         _wsnt__CreatePullPoint() { _wsnt__CreatePullPoint::soap_default(NULL); }
	virtual ~_wsnt__CreatePullPoint() { }
	friend SOAP_FMAC1 _wsnt__CreatePullPoint * SOAP_FMAC2 soap_instantiate__wsnt__CreatePullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2479 */
#ifndef SOAP_TYPE__wsnt__CreatePullPointResponse
#define SOAP_TYPE__wsnt__CreatePullPointResponse (828)
/* wsnt:CreatePullPointResponse complex type: */
class SOAP_CMAC _wsnt__CreatePullPointResponse
{
public:
	struct wsa5__EndpointReferenceType PullPoint;	/* required element of XSD type wsa5:EndpointReferenceType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__CreatePullPointResponse (828)
	virtual int soap_type(void) const { return 828; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__CreatePullPointResponse, default initialized and not managed by a soap context
	virtual _wsnt__CreatePullPointResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__CreatePullPointResponse); }
	         _wsnt__CreatePullPointResponse() { _wsnt__CreatePullPointResponse::soap_default(NULL); }
	virtual ~_wsnt__CreatePullPointResponse() { }
	friend SOAP_FMAC1 _wsnt__CreatePullPointResponse * SOAP_FMAC2 soap_instantiate__wsnt__CreatePullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2482 */
#ifndef SOAP_TYPE__wsnt__Renew
#define SOAP_TYPE__wsnt__Renew (829)
/* wsnt:Renew complex type: */
class SOAP_CMAC _wsnt__Renew
{
public:
	std::string *TerminationTime;	/* required element of XSD type wsnt:AbsoluteOrRelativeTimeType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Renew (829)
	virtual int soap_type(void) const { return 829; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Renew, default initialized and not managed by a soap context
	virtual _wsnt__Renew *soap_alloc(void) const { return SOAP_NEW(_wsnt__Renew); }
	         _wsnt__Renew() { _wsnt__Renew::soap_default(NULL); }
	virtual ~_wsnt__Renew() { }
	friend SOAP_FMAC1 _wsnt__Renew * SOAP_FMAC2 soap_instantiate__wsnt__Renew(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2485 */
#ifndef SOAP_TYPE__wsnt__RenewResponse
#define SOAP_TYPE__wsnt__RenewResponse (830)
/* wsnt:RenewResponse complex type: */
class SOAP_CMAC _wsnt__RenewResponse
{
public:
	time_t TerminationTime;	/* required element of XSD type xsd:dateTime */
	time_t *CurrentTime;	/* optional element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__RenewResponse (830)
	virtual int soap_type(void) const { return 830; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__RenewResponse, default initialized and not managed by a soap context
	virtual _wsnt__RenewResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__RenewResponse); }
	         _wsnt__RenewResponse() { _wsnt__RenewResponse::soap_default(NULL); }
	virtual ~_wsnt__RenewResponse() { }
	friend SOAP_FMAC1 _wsnt__RenewResponse * SOAP_FMAC2 soap_instantiate__wsnt__RenewResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2488 */
#ifndef SOAP_TYPE__wsnt__Unsubscribe
#define SOAP_TYPE__wsnt__Unsubscribe (831)
/* wsnt:Unsubscribe complex type: */
class SOAP_CMAC _wsnt__Unsubscribe
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Unsubscribe (831)
	virtual int soap_type(void) const { return 831; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Unsubscribe, default initialized and not managed by a soap context
	virtual _wsnt__Unsubscribe *soap_alloc(void) const { return SOAP_NEW(_wsnt__Unsubscribe); }
	         _wsnt__Unsubscribe() { _wsnt__Unsubscribe::soap_default(NULL); }
	virtual ~_wsnt__Unsubscribe() { }
	friend SOAP_FMAC1 _wsnt__Unsubscribe * SOAP_FMAC2 soap_instantiate__wsnt__Unsubscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2491 */
#ifndef SOAP_TYPE__wsnt__UnsubscribeResponse
#define SOAP_TYPE__wsnt__UnsubscribeResponse (832)
/* wsnt:UnsubscribeResponse complex type: */
class SOAP_CMAC _wsnt__UnsubscribeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__UnsubscribeResponse (832)
	virtual int soap_type(void) const { return 832; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__UnsubscribeResponse, default initialized and not managed by a soap context
	virtual _wsnt__UnsubscribeResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__UnsubscribeResponse); }
	         _wsnt__UnsubscribeResponse() { _wsnt__UnsubscribeResponse::soap_default(NULL); }
	virtual ~_wsnt__UnsubscribeResponse() { }
	friend SOAP_FMAC1 _wsnt__UnsubscribeResponse * SOAP_FMAC2 soap_instantiate__wsnt__UnsubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2494 */
#ifndef SOAP_TYPE__wsnt__PauseSubscription
#define SOAP_TYPE__wsnt__PauseSubscription (833)
/* wsnt:PauseSubscription complex type: */
class SOAP_CMAC _wsnt__PauseSubscription
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__PauseSubscription (833)
	virtual int soap_type(void) const { return 833; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__PauseSubscription, default initialized and not managed by a soap context
	virtual _wsnt__PauseSubscription *soap_alloc(void) const { return SOAP_NEW(_wsnt__PauseSubscription); }
	         _wsnt__PauseSubscription() { _wsnt__PauseSubscription::soap_default(NULL); }
	virtual ~_wsnt__PauseSubscription() { }
	friend SOAP_FMAC1 _wsnt__PauseSubscription * SOAP_FMAC2 soap_instantiate__wsnt__PauseSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2497 */
#ifndef SOAP_TYPE__wsnt__PauseSubscriptionResponse
#define SOAP_TYPE__wsnt__PauseSubscriptionResponse (834)
/* wsnt:PauseSubscriptionResponse complex type: */
class SOAP_CMAC _wsnt__PauseSubscriptionResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__PauseSubscriptionResponse (834)
	virtual int soap_type(void) const { return 834; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__PauseSubscriptionResponse, default initialized and not managed by a soap context
	virtual _wsnt__PauseSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__PauseSubscriptionResponse); }
	         _wsnt__PauseSubscriptionResponse() { _wsnt__PauseSubscriptionResponse::soap_default(NULL); }
	virtual ~_wsnt__PauseSubscriptionResponse() { }
	friend SOAP_FMAC1 _wsnt__PauseSubscriptionResponse * SOAP_FMAC2 soap_instantiate__wsnt__PauseSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2500 */
#ifndef SOAP_TYPE__wsnt__ResumeSubscription
#define SOAP_TYPE__wsnt__ResumeSubscription (835)
/* wsnt:ResumeSubscription complex type: */
class SOAP_CMAC _wsnt__ResumeSubscription
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__ResumeSubscription (835)
	virtual int soap_type(void) const { return 835; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__ResumeSubscription, default initialized and not managed by a soap context
	virtual _wsnt__ResumeSubscription *soap_alloc(void) const { return SOAP_NEW(_wsnt__ResumeSubscription); }
	         _wsnt__ResumeSubscription() { _wsnt__ResumeSubscription::soap_default(NULL); }
	virtual ~_wsnt__ResumeSubscription() { }
	friend SOAP_FMAC1 _wsnt__ResumeSubscription * SOAP_FMAC2 soap_instantiate__wsnt__ResumeSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2503 */
#ifndef SOAP_TYPE__wsnt__ResumeSubscriptionResponse
#define SOAP_TYPE__wsnt__ResumeSubscriptionResponse (836)
/* wsnt:ResumeSubscriptionResponse complex type: */
class SOAP_CMAC _wsnt__ResumeSubscriptionResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__ResumeSubscriptionResponse (836)
	virtual int soap_type(void) const { return 836; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__ResumeSubscriptionResponse, default initialized and not managed by a soap context
	virtual _wsnt__ResumeSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__ResumeSubscriptionResponse); }
	         _wsnt__ResumeSubscriptionResponse() { _wsnt__ResumeSubscriptionResponse::soap_default(NULL); }
	virtual ~_wsnt__ResumeSubscriptionResponse() { }
	friend SOAP_FMAC1 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC2 soap_instantiate__wsnt__ResumeSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:25736 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode
#define SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode (1523)
/* wsrfbf:BaseFaultType-ErrorCode complex type: */
class SOAP_CMAC _wsrfbf__BaseFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute of XSD type xsd:anyURI */
	char *__mixed;
public:
	/// Return the unique type ID value SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode (1523)
	virtual int soap_type(void) const { return 1523; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsrfbf__BaseFaultType_ErrorCode, default initialized and not managed by a soap context
	virtual _wsrfbf__BaseFaultType_ErrorCode *soap_alloc(void) const { return SOAP_NEW(_wsrfbf__BaseFaultType_ErrorCode); }
	         _wsrfbf__BaseFaultType_ErrorCode() { _wsrfbf__BaseFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_wsrfbf__BaseFaultType_ErrorCode() { }
	friend SOAP_FMAC1 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_ErrorCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:25757 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_Description
#define SOAP_TYPE__wsrfbf__BaseFaultType_Description (1525)
/* wsrfbf:BaseFaultType-Description simple type: */
class SOAP_CMAC _wsrfbf__BaseFaultType_Description
{
public:
	std::string __item;	/* mixed XML content */
	std::string *xml__lang;	/* optional attribute of XSD type xml:lang */
public:
	/// Return the unique type ID value SOAP_TYPE__wsrfbf__BaseFaultType_Description (1525)
	virtual int soap_type(void) const { return 1525; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsrfbf__BaseFaultType_Description, default initialized and not managed by a soap context
	virtual _wsrfbf__BaseFaultType_Description *soap_alloc(void) const { return SOAP_NEW(_wsrfbf__BaseFaultType_Description); }
	         _wsrfbf__BaseFaultType_Description() { _wsrfbf__BaseFaultType_Description::soap_default(NULL); }
	virtual ~_wsrfbf__BaseFaultType_Description() { }
	friend SOAP_FMAC1 _wsrfbf__BaseFaultType_Description * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_Description(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:25774 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause
#define SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause (1529)
/* wsrfbf:BaseFaultType-FaultCause complex type: */
class SOAP_CMAC _wsrfbf__BaseFaultType_FaultCause
{
public:
	/// Return the unique type ID value SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause (1529)
	virtual int soap_type(void) const { return 1529; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsrfbf__BaseFaultType_FaultCause, default initialized and not managed by a soap context
	virtual _wsrfbf__BaseFaultType_FaultCause *soap_alloc(void) const { return SOAP_NEW(_wsrfbf__BaseFaultType_FaultCause); }
	         _wsrfbf__BaseFaultType_FaultCause() { _wsrfbf__BaseFaultType_FaultCause::soap_default(NULL); }
	virtual ~_wsrfbf__BaseFaultType_FaultCause() { }
	friend SOAP_FMAC1 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_FaultCause(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2506 */
#ifndef SOAP_TYPE_wsrfbf__BaseFaultType
#define SOAP_TYPE_wsrfbf__BaseFaultType (837)
/* Type wsrfbf__BaseFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsrfbf:BaseFaultType complex type: */
class SOAP_CMAC wsrfbf__BaseFaultType
{
public:
	time_t Timestamp;	/* required element of XSD type xsd:dateTime */
	struct wsa5__EndpointReferenceType *Originator;	/* optional element of XSD type wsa5:EndpointReferenceType */
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode;	/* optional element of XSD type wsrfbf:BaseFaultType-ErrorCode */
	std::vector<_wsrfbf__BaseFaultType_Description> *Description;	/* optional element of XSD type wsrfbf:BaseFaultType-Description */
	_wsrfbf__BaseFaultType_FaultCause *FaultCause;	/* optional element of XSD type wsrfbf:BaseFaultType-FaultCause */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_wsrfbf__BaseFaultType (837)
	virtual int soap_type(void) const { return 837; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsrfbf__BaseFaultType, default initialized and not managed by a soap context
	virtual wsrfbf__BaseFaultType *soap_alloc(void) const { return SOAP_NEW(wsrfbf__BaseFaultType); }
	         wsrfbf__BaseFaultType() { wsrfbf__BaseFaultType::soap_default(NULL); }
	virtual ~wsrfbf__BaseFaultType() { }
	friend SOAP_FMAC1 wsrfbf__BaseFaultType * SOAP_FMAC2 soap_instantiate_wsrfbf__BaseFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2509 */
#ifndef SOAP_TYPE_wstop__Documentation
#define SOAP_TYPE_wstop__Documentation (838)
/* wstop:Documentation complex type: */
class SOAP_CMAC wstop__Documentation
{
public:
	char *__mixed;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__Documentation (838)
	virtual int soap_type(void) const { return 838; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__Documentation, default initialized and not managed by a soap context
	virtual wstop__Documentation *soap_alloc(void) const { return SOAP_NEW(wstop__Documentation); }
	         wstop__Documentation() { wstop__Documentation::soap_default(NULL); }
	virtual ~wstop__Documentation() { }
	friend SOAP_FMAC1 wstop__Documentation * SOAP_FMAC2 soap_instantiate_wstop__Documentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2512 */
#ifndef SOAP_TYPE_wstop__ExtensibleDocumented
#define SOAP_TYPE_wstop__ExtensibleDocumented (839)
/* Type wstop__ExtensibleDocumented is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:ExtensibleDocumented complex type: */
class SOAP_CMAC wstop__ExtensibleDocumented
{
public:
	wstop__Documentation *documentation;	/* optional element of XSD type wstop:Documentation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__ExtensibleDocumented (839)
	virtual int soap_type(void) const { return 839; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__ExtensibleDocumented, default initialized and not managed by a soap context
	virtual wstop__ExtensibleDocumented *soap_alloc(void) const { return SOAP_NEW(wstop__ExtensibleDocumented); }
	         wstop__ExtensibleDocumented() { wstop__ExtensibleDocumented::soap_default(NULL); }
	virtual ~wstop__ExtensibleDocumented() { }
	friend SOAP_FMAC1 wstop__ExtensibleDocumented * SOAP_FMAC2 soap_instantiate_wstop__ExtensibleDocumented(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2515 */
#ifndef SOAP_TYPE_wstop__QueryExpressionType
#define SOAP_TYPE_wstop__QueryExpressionType (840)
/* wstop:QueryExpressionType complex type: */
class SOAP_CMAC wstop__QueryExpressionType
{
public:
	std::string Dialect;	/* required attribute of XSD type xsd:anyURI */
	char *__mixed;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__QueryExpressionType (840)
	virtual int soap_type(void) const { return 840; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__QueryExpressionType, default initialized and not managed by a soap context
	virtual wstop__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW(wstop__QueryExpressionType); }
	         wstop__QueryExpressionType() { wstop__QueryExpressionType::soap_default(NULL); }
	virtual ~wstop__QueryExpressionType() { }
	friend SOAP_FMAC1 wstop__QueryExpressionType * SOAP_FMAC2 soap_instantiate_wstop__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2527 */
#ifndef SOAP_TYPE_tls__Capabilities
#define SOAP_TYPE_tls__Capabilities (844)
/* tls:Capabilities complex type: */
class SOAP_CMAC tls__Capabilities
{
public:
	bool *FixedLayout;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tls__Capabilities (844)
	virtual int soap_type(void) const { return 844; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tls__Capabilities, default initialized and not managed by a soap context
	virtual tls__Capabilities *soap_alloc(void) const { return SOAP_NEW(tls__Capabilities); }
	         tls__Capabilities() { tls__Capabilities::soap_default(NULL); }
	virtual ~tls__Capabilities() { }
	friend SOAP_FMAC1 tls__Capabilities * SOAP_FMAC2 soap_instantiate_tls__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2530 */
#ifndef SOAP_TYPE__tls__GetServiceCapabilities
#define SOAP_TYPE__tls__GetServiceCapabilities (845)
/* tls:GetServiceCapabilities complex type: */
class SOAP_CMAC _tls__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetServiceCapabilities (845)
	virtual int soap_type(void) const { return 845; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _tls__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_tls__GetServiceCapabilities); }
	         _tls__GetServiceCapabilities() { _tls__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tls__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _tls__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tls__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2533 */
#ifndef SOAP_TYPE__tls__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tls__GetServiceCapabilitiesResponse (846)
/* tls:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _tls__GetServiceCapabilitiesResponse
{
public:
	tls__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tls:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetServiceCapabilitiesResponse (846)
	virtual int soap_type(void) const { return 846; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tls__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tls__GetServiceCapabilitiesResponse); }
	         _tls__GetServiceCapabilitiesResponse() { _tls__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tls__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _tls__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tls__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2536 */
#ifndef SOAP_TYPE__tls__GetLayout
#define SOAP_TYPE__tls__GetLayout (847)
/* tls:GetLayout complex type: */
class SOAP_CMAC _tls__GetLayout
{
public:
	std::string VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetLayout (847)
	virtual int soap_type(void) const { return 847; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetLayout, default initialized and not managed by a soap context
	virtual _tls__GetLayout *soap_alloc(void) const { return SOAP_NEW(_tls__GetLayout); }
	         _tls__GetLayout() { _tls__GetLayout::soap_default(NULL); }
	virtual ~_tls__GetLayout() { }
	friend SOAP_FMAC1 _tls__GetLayout * SOAP_FMAC2 soap_instantiate__tls__GetLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2539 */
#ifndef SOAP_TYPE__tls__GetLayoutResponse
#define SOAP_TYPE__tls__GetLayoutResponse (848)
/* tls:GetLayoutResponse complex type: */
class SOAP_CMAC _tls__GetLayoutResponse
{
public:
	tt__Layout *Layout;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Layout */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetLayoutResponse (848)
	virtual int soap_type(void) const { return 848; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetLayoutResponse, default initialized and not managed by a soap context
	virtual _tls__GetLayoutResponse *soap_alloc(void) const { return SOAP_NEW(_tls__GetLayoutResponse); }
	         _tls__GetLayoutResponse() { _tls__GetLayoutResponse::soap_default(NULL); }
	virtual ~_tls__GetLayoutResponse() { }
	friend SOAP_FMAC1 _tls__GetLayoutResponse * SOAP_FMAC2 soap_instantiate__tls__GetLayoutResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2542 */
#ifndef SOAP_TYPE__tls__SetLayout
#define SOAP_TYPE__tls__SetLayout (849)
/* tls:SetLayout complex type: */
class SOAP_CMAC _tls__SetLayout
{
public:
	std::string VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	tt__Layout *Layout;	/* required element of XSD type tt:Layout */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__SetLayout (849)
	virtual int soap_type(void) const { return 849; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__SetLayout, default initialized and not managed by a soap context
	virtual _tls__SetLayout *soap_alloc(void) const { return SOAP_NEW(_tls__SetLayout); }
	         _tls__SetLayout() { _tls__SetLayout::soap_default(NULL); }
	virtual ~_tls__SetLayout() { }
	friend SOAP_FMAC1 _tls__SetLayout * SOAP_FMAC2 soap_instantiate__tls__SetLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2545 */
#ifndef SOAP_TYPE__tls__SetLayoutResponse
#define SOAP_TYPE__tls__SetLayoutResponse (850)
/* tls:SetLayoutResponse complex type: */
class SOAP_CMAC _tls__SetLayoutResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__SetLayoutResponse (850)
	virtual int soap_type(void) const { return 850; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__SetLayoutResponse, default initialized and not managed by a soap context
	virtual _tls__SetLayoutResponse *soap_alloc(void) const { return SOAP_NEW(_tls__SetLayoutResponse); }
	         _tls__SetLayoutResponse() { _tls__SetLayoutResponse::soap_default(NULL); }
	virtual ~_tls__SetLayoutResponse() { }
	friend SOAP_FMAC1 _tls__SetLayoutResponse * SOAP_FMAC2 soap_instantiate__tls__SetLayoutResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2548 */
#ifndef SOAP_TYPE__tls__GetDisplayOptions
#define SOAP_TYPE__tls__GetDisplayOptions (851)
/* tls:GetDisplayOptions complex type: */
class SOAP_CMAC _tls__GetDisplayOptions
{
public:
	std::string VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetDisplayOptions (851)
	virtual int soap_type(void) const { return 851; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetDisplayOptions, default initialized and not managed by a soap context
	virtual _tls__GetDisplayOptions *soap_alloc(void) const { return SOAP_NEW(_tls__GetDisplayOptions); }
	         _tls__GetDisplayOptions() { _tls__GetDisplayOptions::soap_default(NULL); }
	virtual ~_tls__GetDisplayOptions() { }
	friend SOAP_FMAC1 _tls__GetDisplayOptions * SOAP_FMAC2 soap_instantiate__tls__GetDisplayOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2551 */
#ifndef SOAP_TYPE__tls__GetDisplayOptionsResponse
#define SOAP_TYPE__tls__GetDisplayOptionsResponse (852)
/* tls:GetDisplayOptionsResponse complex type: */
class SOAP_CMAC _tls__GetDisplayOptionsResponse
{
public:
	tt__LayoutOptions *LayoutOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:LayoutOptions */
	tt__CodingCapabilities *CodingCapabilities;	/* required element of XSD type tt:CodingCapabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetDisplayOptionsResponse (852)
	virtual int soap_type(void) const { return 852; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetDisplayOptionsResponse, default initialized and not managed by a soap context
	virtual _tls__GetDisplayOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tls__GetDisplayOptionsResponse); }
	         _tls__GetDisplayOptionsResponse() { _tls__GetDisplayOptionsResponse::soap_default(NULL); }
	virtual ~_tls__GetDisplayOptionsResponse() { }
	friend SOAP_FMAC1 _tls__GetDisplayOptionsResponse * SOAP_FMAC2 soap_instantiate__tls__GetDisplayOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2554 */
#ifndef SOAP_TYPE__tls__GetPaneConfigurations
#define SOAP_TYPE__tls__GetPaneConfigurations (853)
/* tls:GetPaneConfigurations complex type: */
class SOAP_CMAC _tls__GetPaneConfigurations
{
public:
	std::string VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetPaneConfigurations (853)
	virtual int soap_type(void) const { return 853; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetPaneConfigurations, default initialized and not managed by a soap context
	virtual _tls__GetPaneConfigurations *soap_alloc(void) const { return SOAP_NEW(_tls__GetPaneConfigurations); }
	         _tls__GetPaneConfigurations() { _tls__GetPaneConfigurations::soap_default(NULL); }
	virtual ~_tls__GetPaneConfigurations() { }
	friend SOAP_FMAC1 _tls__GetPaneConfigurations * SOAP_FMAC2 soap_instantiate__tls__GetPaneConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2557 */
#ifndef SOAP_TYPE__tls__GetPaneConfigurationsResponse
#define SOAP_TYPE__tls__GetPaneConfigurationsResponse (854)
/* tls:GetPaneConfigurationsResponse complex type: */
class SOAP_CMAC _tls__GetPaneConfigurationsResponse
{
public:
	std::vector<tt__PaneConfiguration *> PaneConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:PaneConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetPaneConfigurationsResponse (854)
	virtual int soap_type(void) const { return 854; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetPaneConfigurationsResponse, default initialized and not managed by a soap context
	virtual _tls__GetPaneConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_tls__GetPaneConfigurationsResponse); }
	         _tls__GetPaneConfigurationsResponse() { _tls__GetPaneConfigurationsResponse::soap_default(NULL); }
	virtual ~_tls__GetPaneConfigurationsResponse() { }
	friend SOAP_FMAC1 _tls__GetPaneConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tls__GetPaneConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2560 */
#ifndef SOAP_TYPE__tls__GetPaneConfiguration
#define SOAP_TYPE__tls__GetPaneConfiguration (855)
/* tls:GetPaneConfiguration complex type: */
class SOAP_CMAC _tls__GetPaneConfiguration
{
public:
	std::string VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	std::string Pane;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetPaneConfiguration (855)
	virtual int soap_type(void) const { return 855; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetPaneConfiguration, default initialized and not managed by a soap context
	virtual _tls__GetPaneConfiguration *soap_alloc(void) const { return SOAP_NEW(_tls__GetPaneConfiguration); }
	         _tls__GetPaneConfiguration() { _tls__GetPaneConfiguration::soap_default(NULL); }
	virtual ~_tls__GetPaneConfiguration() { }
	friend SOAP_FMAC1 _tls__GetPaneConfiguration * SOAP_FMAC2 soap_instantiate__tls__GetPaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2563 */
#ifndef SOAP_TYPE__tls__GetPaneConfigurationResponse
#define SOAP_TYPE__tls__GetPaneConfigurationResponse (856)
/* tls:GetPaneConfigurationResponse complex type: */
class SOAP_CMAC _tls__GetPaneConfigurationResponse
{
public:
	tt__PaneConfiguration *PaneConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:PaneConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetPaneConfigurationResponse (856)
	virtual int soap_type(void) const { return 856; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetPaneConfigurationResponse, default initialized and not managed by a soap context
	virtual _tls__GetPaneConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tls__GetPaneConfigurationResponse); }
	         _tls__GetPaneConfigurationResponse() { _tls__GetPaneConfigurationResponse::soap_default(NULL); }
	virtual ~_tls__GetPaneConfigurationResponse() { }
	friend SOAP_FMAC1 _tls__GetPaneConfigurationResponse * SOAP_FMAC2 soap_instantiate__tls__GetPaneConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2566 */
#ifndef SOAP_TYPE__tls__SetPaneConfigurations
#define SOAP_TYPE__tls__SetPaneConfigurations (857)
/* tls:SetPaneConfigurations complex type: */
class SOAP_CMAC _tls__SetPaneConfigurations
{
public:
	std::string VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	std::vector<tt__PaneConfiguration *> PaneConfiguration;	/* required element of XSD type tt:PaneConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__SetPaneConfigurations (857)
	virtual int soap_type(void) const { return 857; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__SetPaneConfigurations, default initialized and not managed by a soap context
	virtual _tls__SetPaneConfigurations *soap_alloc(void) const { return SOAP_NEW(_tls__SetPaneConfigurations); }
	         _tls__SetPaneConfigurations() { _tls__SetPaneConfigurations::soap_default(NULL); }
	virtual ~_tls__SetPaneConfigurations() { }
	friend SOAP_FMAC1 _tls__SetPaneConfigurations * SOAP_FMAC2 soap_instantiate__tls__SetPaneConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2569 */
#ifndef SOAP_TYPE__tls__SetPaneConfigurationsResponse
#define SOAP_TYPE__tls__SetPaneConfigurationsResponse (858)
/* tls:SetPaneConfigurationsResponse complex type: */
class SOAP_CMAC _tls__SetPaneConfigurationsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__SetPaneConfigurationsResponse (858)
	virtual int soap_type(void) const { return 858; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__SetPaneConfigurationsResponse, default initialized and not managed by a soap context
	virtual _tls__SetPaneConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_tls__SetPaneConfigurationsResponse); }
	         _tls__SetPaneConfigurationsResponse() { _tls__SetPaneConfigurationsResponse::soap_default(NULL); }
	virtual ~_tls__SetPaneConfigurationsResponse() { }
	friend SOAP_FMAC1 _tls__SetPaneConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tls__SetPaneConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2572 */
#ifndef SOAP_TYPE__tls__SetPaneConfiguration
#define SOAP_TYPE__tls__SetPaneConfiguration (859)
/* tls:SetPaneConfiguration complex type: */
class SOAP_CMAC _tls__SetPaneConfiguration
{
public:
	std::string VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	tt__PaneConfiguration *PaneConfiguration;	/* required element of XSD type tt:PaneConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__SetPaneConfiguration (859)
	virtual int soap_type(void) const { return 859; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__SetPaneConfiguration, default initialized and not managed by a soap context
	virtual _tls__SetPaneConfiguration *soap_alloc(void) const { return SOAP_NEW(_tls__SetPaneConfiguration); }
	         _tls__SetPaneConfiguration() { _tls__SetPaneConfiguration::soap_default(NULL); }
	virtual ~_tls__SetPaneConfiguration() { }
	friend SOAP_FMAC1 _tls__SetPaneConfiguration * SOAP_FMAC2 soap_instantiate__tls__SetPaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2575 */
#ifndef SOAP_TYPE__tls__SetPaneConfigurationResponse
#define SOAP_TYPE__tls__SetPaneConfigurationResponse (860)
/* tls:SetPaneConfigurationResponse complex type: */
class SOAP_CMAC _tls__SetPaneConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__SetPaneConfigurationResponse (860)
	virtual int soap_type(void) const { return 860; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__SetPaneConfigurationResponse, default initialized and not managed by a soap context
	virtual _tls__SetPaneConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tls__SetPaneConfigurationResponse); }
	         _tls__SetPaneConfigurationResponse() { _tls__SetPaneConfigurationResponse::soap_default(NULL); }
	virtual ~_tls__SetPaneConfigurationResponse() { }
	friend SOAP_FMAC1 _tls__SetPaneConfigurationResponse * SOAP_FMAC2 soap_instantiate__tls__SetPaneConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2578 */
#ifndef SOAP_TYPE__tls__CreatePaneConfiguration
#define SOAP_TYPE__tls__CreatePaneConfiguration (861)
/* tls:CreatePaneConfiguration complex type: */
class SOAP_CMAC _tls__CreatePaneConfiguration
{
public:
	std::string VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	tt__PaneConfiguration *PaneConfiguration;	/* required element of XSD type tt:PaneConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__CreatePaneConfiguration (861)
	virtual int soap_type(void) const { return 861; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__CreatePaneConfiguration, default initialized and not managed by a soap context
	virtual _tls__CreatePaneConfiguration *soap_alloc(void) const { return SOAP_NEW(_tls__CreatePaneConfiguration); }
	         _tls__CreatePaneConfiguration() { _tls__CreatePaneConfiguration::soap_default(NULL); }
	virtual ~_tls__CreatePaneConfiguration() { }
	friend SOAP_FMAC1 _tls__CreatePaneConfiguration * SOAP_FMAC2 soap_instantiate__tls__CreatePaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2581 */
#ifndef SOAP_TYPE__tls__CreatePaneConfigurationResponse
#define SOAP_TYPE__tls__CreatePaneConfigurationResponse (862)
/* tls:CreatePaneConfigurationResponse complex type: */
class SOAP_CMAC _tls__CreatePaneConfigurationResponse
{
public:
	std::string PaneToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__CreatePaneConfigurationResponse (862)
	virtual int soap_type(void) const { return 862; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__CreatePaneConfigurationResponse, default initialized and not managed by a soap context
	virtual _tls__CreatePaneConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tls__CreatePaneConfigurationResponse); }
	         _tls__CreatePaneConfigurationResponse() { _tls__CreatePaneConfigurationResponse::soap_default(NULL); }
	virtual ~_tls__CreatePaneConfigurationResponse() { }
	friend SOAP_FMAC1 _tls__CreatePaneConfigurationResponse * SOAP_FMAC2 soap_instantiate__tls__CreatePaneConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2584 */
#ifndef SOAP_TYPE__tls__DeletePaneConfiguration
#define SOAP_TYPE__tls__DeletePaneConfiguration (863)
/* tls:DeletePaneConfiguration complex type: */
class SOAP_CMAC _tls__DeletePaneConfiguration
{
public:
	std::string VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	std::string PaneToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__DeletePaneConfiguration (863)
	virtual int soap_type(void) const { return 863; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__DeletePaneConfiguration, default initialized and not managed by a soap context
	virtual _tls__DeletePaneConfiguration *soap_alloc(void) const { return SOAP_NEW(_tls__DeletePaneConfiguration); }
	         _tls__DeletePaneConfiguration() { _tls__DeletePaneConfiguration::soap_default(NULL); }
	virtual ~_tls__DeletePaneConfiguration() { }
	friend SOAP_FMAC1 _tls__DeletePaneConfiguration * SOAP_FMAC2 soap_instantiate__tls__DeletePaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2587 */
#ifndef SOAP_TYPE__tls__DeletePaneConfigurationResponse
#define SOAP_TYPE__tls__DeletePaneConfigurationResponse (864)
/* tls:DeletePaneConfigurationResponse complex type: */
class SOAP_CMAC _tls__DeletePaneConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__DeletePaneConfigurationResponse (864)
	virtual int soap_type(void) const { return 864; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__DeletePaneConfigurationResponse, default initialized and not managed by a soap context
	virtual _tls__DeletePaneConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tls__DeletePaneConfigurationResponse); }
	         _tls__DeletePaneConfigurationResponse() { _tls__DeletePaneConfigurationResponse::soap_default(NULL); }
	virtual ~_tls__DeletePaneConfigurationResponse() { }
	friend SOAP_FMAC1 _tls__DeletePaneConfigurationResponse * SOAP_FMAC2 soap_instantiate__tls__DeletePaneConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:253 */
#ifndef SOAP_TYPE_tmd__SerialPort
#define SOAP_TYPE_tmd__SerialPort (86)
/* Type tmd__SerialPort is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:SerialPort complex type: */
class SOAP_CMAC tmd__SerialPort : public tt__DeviceEntity
{
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__SerialPort (86)
	virtual int soap_type(void) const { return 86; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__SerialPort, default initialized and not managed by a soap context
	virtual tmd__SerialPort *soap_alloc(void) const { return SOAP_NEW(tmd__SerialPort); }
	         tmd__SerialPort() { tmd__SerialPort::soap_default(NULL); }
	virtual ~tmd__SerialPort() { }
	friend SOAP_FMAC1 tmd__SerialPort * SOAP_FMAC2 soap_instantiate_tmd__SerialPort(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:433 */
#ifndef SOAP_TYPE_tds__StorageConfiguration
#define SOAP_TYPE_tds__StorageConfiguration (146)
/* Type tds__StorageConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tds:StorageConfiguration complex type: */
class SOAP_CMAC tds__StorageConfiguration : public tt__DeviceEntity
{
public:
	tds__StorageConfigurationData *Data;	/* required element of XSD type tds:StorageConfigurationData */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__StorageConfiguration (146)
	virtual int soap_type(void) const { return 146; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__StorageConfiguration, default initialized and not managed by a soap context
	virtual tds__StorageConfiguration *soap_alloc(void) const { return SOAP_NEW(tds__StorageConfiguration); }
	         tds__StorageConfiguration() { tds__StorageConfiguration::soap_default(NULL); }
	virtual ~tds__StorageConfiguration() { }
	friend SOAP_FMAC1 tds__StorageConfiguration * SOAP_FMAC2 soap_instantiate_tds__StorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1003 */
#ifndef SOAP_TYPE_tt__VideoSource
#define SOAP_TYPE_tt__VideoSource (336)
/* Type tt__VideoSource is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSource complex type: */
class SOAP_CMAC tt__VideoSource : public tt__DeviceEntity
{
public:
	float Framerate;	/* required element of XSD type xsd:float */
	tt__VideoResolution *Resolution;	/* required element of XSD type tt:VideoResolution */
	tt__ImagingSettings *Imaging;	/* optional element of XSD type tt:ImagingSettings */
	tt__VideoSourceExtension *Extension;	/* optional element of XSD type tt:VideoSourceExtension */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSource (336)
	virtual int soap_type(void) const { return 336; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSource, default initialized and not managed by a soap context
	virtual tt__VideoSource *soap_alloc(void) const { return SOAP_NEW(tt__VideoSource); }
	         tt__VideoSource() { tt__VideoSource::soap_default(NULL); }
	virtual ~tt__VideoSource() { }
	friend SOAP_FMAC1 tt__VideoSource * SOAP_FMAC2 soap_instantiate_tt__VideoSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1012 */
#ifndef SOAP_TYPE_tt__AudioSource
#define SOAP_TYPE_tt__AudioSource (339)
/* Type tt__AudioSource is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioSource complex type: */
class SOAP_CMAC tt__AudioSource : public tt__DeviceEntity
{
public:
	int Channels;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioSource (339)
	virtual int soap_type(void) const { return 339; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioSource, default initialized and not managed by a soap context
	virtual tt__AudioSource *soap_alloc(void) const { return SOAP_NEW(tt__AudioSource); }
	         tt__AudioSource() { tt__AudioSource::soap_default(NULL); }
	virtual ~tt__AudioSource() { }
	friend SOAP_FMAC1 tt__AudioSource * SOAP_FMAC2 soap_instantiate_tt__AudioSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1027 */
#ifndef SOAP_TYPE_tt__VideoSourceConfiguration
#define SOAP_TYPE_tt__VideoSourceConfiguration (344)
/* Type tt__VideoSourceConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSourceConfiguration complex type: */
class SOAP_CMAC tt__VideoSourceConfiguration : public tt__ConfigurationEntity
{
public:
	std::string SourceToken;	/* required element of XSD type tt:ReferenceToken */
	tt__IntRectangle *Bounds;	/* required element of XSD type tt:IntRectangle */
	tt__VideoSourceConfigurationExtension *Extension;	/* optional element of XSD type tt:VideoSourceConfigurationExtension */
	std::string *ViewMode;	/* optional attribute of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfiguration (344)
	virtual int soap_type(void) const { return 344; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfiguration, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfiguration); }
	         tt__VideoSourceConfiguration() { tt__VideoSourceConfiguration::soap_default(NULL); }
	virtual ~tt__VideoSourceConfiguration() { }
	friend SOAP_FMAC1 tt__VideoSourceConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1069 */
#ifndef SOAP_TYPE_tt__VideoEncoderConfiguration
#define SOAP_TYPE_tt__VideoEncoderConfiguration (358)
/* Type tt__VideoEncoderConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoEncoderConfiguration complex type: */
class SOAP_CMAC tt__VideoEncoderConfiguration : public tt__ConfigurationEntity
{
public:
	enum tt__VideoEncoding Encoding;	/* required element of XSD type tt:VideoEncoding */
	tt__VideoResolution *Resolution;	/* required element of XSD type tt:VideoResolution */
	float Quality;	/* required element of XSD type xsd:float */
	tt__VideoRateControl *RateControl;	/* optional element of XSD type tt:VideoRateControl */
	tt__Mpeg4Configuration *MPEG4;	/* optional element of XSD type tt:Mpeg4Configuration */
	tt__H264Configuration *H264;	/* optional element of XSD type tt:H264Configuration */
	tt__MulticastConfiguration *Multicast;	/* required element of XSD type tt:MulticastConfiguration */
	LONG64 SessionTimeout;	/* external (custom serializer) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoderConfiguration (358)
	virtual int soap_type(void) const { return 358; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoderConfiguration, default initialized and not managed by a soap context
	virtual tt__VideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoderConfiguration); }
	         tt__VideoEncoderConfiguration() { tt__VideoEncoderConfiguration::soap_default(NULL); }
	virtual ~tt__VideoEncoderConfiguration() { }
	friend SOAP_FMAC1 tt__VideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1096 */
#ifndef SOAP_TYPE_tt__JpegOptions2
#define SOAP_TYPE_tt__JpegOptions2 (367)
/* Type tt__JpegOptions2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:JpegOptions2 complex type: */
class SOAP_CMAC tt__JpegOptions2 : public tt__JpegOptions
{
public:
	tt__IntRange *BitrateRange;	/* required element of XSD type tt:IntRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__JpegOptions2 (367)
	virtual int soap_type(void) const { return 367; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__JpegOptions2, default initialized and not managed by a soap context
	virtual tt__JpegOptions2 *soap_alloc(void) const { return SOAP_NEW(tt__JpegOptions2); }
	         tt__JpegOptions2() { tt__JpegOptions2::soap_default(NULL); }
	virtual ~tt__JpegOptions2() { }
	friend SOAP_FMAC1 tt__JpegOptions2 * SOAP_FMAC2 soap_instantiate_tt__JpegOptions2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1102 */
#ifndef SOAP_TYPE_tt__Mpeg4Options2
#define SOAP_TYPE_tt__Mpeg4Options2 (369)
/* Type tt__Mpeg4Options2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Mpeg4Options2 complex type: */
class SOAP_CMAC tt__Mpeg4Options2 : public tt__Mpeg4Options
{
public:
	tt__IntRange *BitrateRange;	/* required element of XSD type tt:IntRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Mpeg4Options2 (369)
	virtual int soap_type(void) const { return 369; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Mpeg4Options2, default initialized and not managed by a soap context
	virtual tt__Mpeg4Options2 *soap_alloc(void) const { return SOAP_NEW(tt__Mpeg4Options2); }
	         tt__Mpeg4Options2() { tt__Mpeg4Options2::soap_default(NULL); }
	virtual ~tt__Mpeg4Options2() { }
	friend SOAP_FMAC1 tt__Mpeg4Options2 * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Options2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1108 */
#ifndef SOAP_TYPE_tt__H264Options2
#define SOAP_TYPE_tt__H264Options2 (371)
/* Type tt__H264Options2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:H264Options2 complex type: */
class SOAP_CMAC tt__H264Options2 : public tt__H264Options
{
public:
	tt__IntRange *BitrateRange;	/* required element of XSD type tt:IntRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__H264Options2 (371)
	virtual int soap_type(void) const { return 371; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__H264Options2, default initialized and not managed by a soap context
	virtual tt__H264Options2 *soap_alloc(void) const { return SOAP_NEW(tt__H264Options2); }
	         tt__H264Options2() { tt__H264Options2::soap_default(NULL); }
	virtual ~tt__H264Options2() { }
	friend SOAP_FMAC1 tt__H264Options2 * SOAP_FMAC2 soap_instantiate_tt__H264Options2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1111 */
#ifndef SOAP_TYPE_tt__VideoEncoder2Configuration
#define SOAP_TYPE_tt__VideoEncoder2Configuration (372)
/* Type tt__VideoEncoder2Configuration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoEncoder2Configuration complex type: */
class SOAP_CMAC tt__VideoEncoder2Configuration : public tt__ConfigurationEntity
{
public:
	std::string Encoding;	/* required element of XSD type xsd:string */
	tt__VideoResolution2 *Resolution;	/* required element of XSD type tt:VideoResolution2 */
	tt__VideoRateControl2 *RateControl;	/* optional element of XSD type tt:VideoRateControl2 */
	tt__MulticastConfiguration *Multicast;	/* optional element of XSD type tt:MulticastConfiguration */
	float Quality;	/* required element of XSD type xsd:float */
	int *GovLength;	/* optional attribute of XSD type xsd:int */
	std::string *Profile;	/* optional attribute of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoder2Configuration (372)
	virtual int soap_type(void) const { return 372; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoder2Configuration, default initialized and not managed by a soap context
	virtual tt__VideoEncoder2Configuration *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoder2Configuration); }
	         tt__VideoEncoder2Configuration() { tt__VideoEncoder2Configuration::soap_default(NULL); }
	virtual ~tt__VideoEncoder2Configuration() { }
	friend SOAP_FMAC1 tt__VideoEncoder2Configuration * SOAP_FMAC2 soap_instantiate_tt__VideoEncoder2Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1123 */
#ifndef SOAP_TYPE_tt__AudioSourceConfiguration
#define SOAP_TYPE_tt__AudioSourceConfiguration (376)
/* Type tt__AudioSourceConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioSourceConfiguration complex type: */
class SOAP_CMAC tt__AudioSourceConfiguration : public tt__ConfigurationEntity
{
public:
	std::string SourceToken;	/* required element of XSD type tt:ReferenceToken */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioSourceConfiguration (376)
	virtual int soap_type(void) const { return 376; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioSourceConfiguration, default initialized and not managed by a soap context
	virtual tt__AudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AudioSourceConfiguration); }
	         tt__AudioSourceConfiguration() { tt__AudioSourceConfiguration::soap_default(NULL); }
	virtual ~tt__AudioSourceConfiguration() { }
	friend SOAP_FMAC1 tt__AudioSourceConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1132 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfiguration
#define SOAP_TYPE_tt__AudioEncoderConfiguration (379)
/* Type tt__AudioEncoderConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioEncoderConfiguration complex type: */
class SOAP_CMAC tt__AudioEncoderConfiguration : public tt__ConfigurationEntity
{
public:
	enum tt__AudioEncoding Encoding;	/* required element of XSD type tt:AudioEncoding */
	int Bitrate;	/* required element of XSD type xsd:int */
	int SampleRate;	/* required element of XSD type xsd:int */
	tt__MulticastConfiguration *Multicast;	/* required element of XSD type tt:MulticastConfiguration */
	LONG64 SessionTimeout;	/* external (custom serializer) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoderConfiguration (379)
	virtual int soap_type(void) const { return 379; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoderConfiguration, default initialized and not managed by a soap context
	virtual tt__AudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoderConfiguration); }
	         tt__AudioEncoderConfiguration() { tt__AudioEncoderConfiguration::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfiguration() { }
	friend SOAP_FMAC1 tt__AudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1141 */
#ifndef SOAP_TYPE_tt__AudioEncoder2Configuration
#define SOAP_TYPE_tt__AudioEncoder2Configuration (382)
/* Type tt__AudioEncoder2Configuration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioEncoder2Configuration complex type: */
class SOAP_CMAC tt__AudioEncoder2Configuration : public tt__ConfigurationEntity
{
public:
	std::string Encoding;	/* required element of XSD type xsd:string */
	tt__MulticastConfiguration *Multicast;	/* optional element of XSD type tt:MulticastConfiguration */
	int Bitrate;	/* required element of XSD type xsd:int */
	int SampleRate;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoder2Configuration (382)
	virtual int soap_type(void) const { return 382; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoder2Configuration, default initialized and not managed by a soap context
	virtual tt__AudioEncoder2Configuration *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoder2Configuration); }
	         tt__AudioEncoder2Configuration() { tt__AudioEncoder2Configuration::soap_default(NULL); }
	virtual ~tt__AudioEncoder2Configuration() { }
	friend SOAP_FMAC1 tt__AudioEncoder2Configuration * SOAP_FMAC2 soap_instantiate_tt__AudioEncoder2Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1147 */
#ifndef SOAP_TYPE_tt__VideoAnalyticsConfiguration
#define SOAP_TYPE_tt__VideoAnalyticsConfiguration (384)
/* Type tt__VideoAnalyticsConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoAnalyticsConfiguration complex type: */
class SOAP_CMAC tt__VideoAnalyticsConfiguration : public tt__ConfigurationEntity
{
public:
	tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;	/* required element of XSD type tt:AnalyticsEngineConfiguration */
	tt__RuleEngineConfiguration *RuleEngineConfiguration;	/* required element of XSD type tt:RuleEngineConfiguration */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoAnalyticsConfiguration (384)
	virtual int soap_type(void) const { return 384; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoAnalyticsConfiguration, default initialized and not managed by a soap context
	virtual tt__VideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__VideoAnalyticsConfiguration); }
	         tt__VideoAnalyticsConfiguration() { tt__VideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~tt__VideoAnalyticsConfiguration() { }
	friend SOAP_FMAC1 tt__VideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1150 */
#ifndef SOAP_TYPE_tt__MetadataConfiguration
#define SOAP_TYPE_tt__MetadataConfiguration (385)
/* Type tt__MetadataConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataConfiguration complex type: */
class SOAP_CMAC tt__MetadataConfiguration : public tt__ConfigurationEntity
{
public:
	tt__PTZFilter *PTZStatus;	/* optional element of XSD type tt:PTZFilter */
	tt__EventSubscription *Events;	/* optional element of XSD type tt:EventSubscription */
	bool *Analytics;	/* optional element of XSD type xsd:boolean */
	tt__MulticastConfiguration *Multicast;	/* required element of XSD type tt:MulticastConfiguration */
	LONG64 SessionTimeout;	/* external (custom serializer) */
	tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;	/* optional element of XSD type tt:AnalyticsEngineConfiguration */
	tt__MetadataConfigurationExtension *Extension;	/* optional element of XSD type tt:MetadataConfigurationExtension */
	std::string *CompressionType;	/* optional attribute of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataConfiguration (385)
	virtual int soap_type(void) const { return 385; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataConfiguration, default initialized and not managed by a soap context
	virtual tt__MetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__MetadataConfiguration); }
	         tt__MetadataConfiguration() { tt__MetadataConfiguration::soap_default(NULL); }
	virtual ~tt__MetadataConfiguration() { }
	friend SOAP_FMAC1 tt__MetadataConfiguration * SOAP_FMAC2 soap_instantiate_tt__MetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1177 */
#ifndef SOAP_TYPE_tt__VideoOutput
#define SOAP_TYPE_tt__VideoOutput (394)
/* Type tt__VideoOutput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoOutput complex type: */
class SOAP_CMAC tt__VideoOutput : public tt__DeviceEntity
{
public:
	tt__Layout *Layout;	/* required element of XSD type tt:Layout */
	tt__VideoResolution *Resolution;	/* optional element of XSD type tt:VideoResolution */
	float *RefreshRate;	/* optional element of XSD type xsd:float */
	float *AspectRatio;	/* optional element of XSD type xsd:float */
	tt__VideoOutputExtension *Extension;	/* optional element of XSD type tt:VideoOutputExtension */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoOutput (394)
	virtual int soap_type(void) const { return 394; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoOutput, default initialized and not managed by a soap context
	virtual tt__VideoOutput *soap_alloc(void) const { return SOAP_NEW(tt__VideoOutput); }
	         tt__VideoOutput() { tt__VideoOutput::soap_default(NULL); }
	virtual ~tt__VideoOutput() { }
	friend SOAP_FMAC1 tt__VideoOutput * SOAP_FMAC2 soap_instantiate_tt__VideoOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1183 */
#ifndef SOAP_TYPE_tt__VideoOutputConfiguration
#define SOAP_TYPE_tt__VideoOutputConfiguration (396)
/* Type tt__VideoOutputConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoOutputConfiguration complex type: */
class SOAP_CMAC tt__VideoOutputConfiguration : public tt__ConfigurationEntity
{
public:
	std::string OutputToken;	/* required element of XSD type tt:ReferenceToken */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoOutputConfiguration (396)
	virtual int soap_type(void) const { return 396; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoOutputConfiguration, default initialized and not managed by a soap context
	virtual tt__VideoOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__VideoOutputConfiguration); }
	         tt__VideoOutputConfiguration() { tt__VideoOutputConfiguration::soap_default(NULL); }
	virtual ~tt__VideoOutputConfiguration() { }
	friend SOAP_FMAC1 tt__VideoOutputConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1204 */
#ifndef SOAP_TYPE_tt__AudioOutput
#define SOAP_TYPE_tt__AudioOutput (403)
/* Type tt__AudioOutput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioOutput complex type: */
class SOAP_CMAC tt__AudioOutput : public tt__DeviceEntity
{
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioOutput (403)
	virtual int soap_type(void) const { return 403; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioOutput, default initialized and not managed by a soap context
	virtual tt__AudioOutput *soap_alloc(void) const { return SOAP_NEW(tt__AudioOutput); }
	         tt__AudioOutput() { tt__AudioOutput::soap_default(NULL); }
	virtual ~tt__AudioOutput() { }
	friend SOAP_FMAC1 tt__AudioOutput * SOAP_FMAC2 soap_instantiate_tt__AudioOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1207 */
#ifndef SOAP_TYPE_tt__AudioOutputConfiguration
#define SOAP_TYPE_tt__AudioOutputConfiguration (404)
/* Type tt__AudioOutputConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioOutputConfiguration complex type: */
class SOAP_CMAC tt__AudioOutputConfiguration : public tt__ConfigurationEntity
{
public:
	std::string OutputToken;	/* required element of XSD type tt:ReferenceToken */
	std::string *SendPrimacy;	/* optional element of XSD type xsd:anyURI */
	int OutputLevel;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioOutputConfiguration (404)
	virtual int soap_type(void) const { return 404; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioOutputConfiguration, default initialized and not managed by a soap context
	virtual tt__AudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AudioOutputConfiguration); }
	         tt__AudioOutputConfiguration() { tt__AudioOutputConfiguration::soap_default(NULL); }
	virtual ~tt__AudioOutputConfiguration() { }
	friend SOAP_FMAC1 tt__AudioOutputConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1213 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfiguration
#define SOAP_TYPE_tt__AudioDecoderConfiguration (406)
/* Type tt__AudioDecoderConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioDecoderConfiguration complex type: */
class SOAP_CMAC tt__AudioDecoderConfiguration : public tt__ConfigurationEntity
{
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioDecoderConfiguration (406)
	virtual int soap_type(void) const { return 406; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioDecoderConfiguration, default initialized and not managed by a soap context
	virtual tt__AudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AudioDecoderConfiguration); }
	         tt__AudioDecoderConfiguration() { tt__AudioDecoderConfiguration::soap_default(NULL); }
	virtual ~tt__AudioDecoderConfiguration() { }
	friend SOAP_FMAC1 tt__AudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1246 */
#ifndef SOAP_TYPE_tt__NetworkInterface
#define SOAP_TYPE_tt__NetworkInterface (417)
/* Type tt__NetworkInterface is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterface complex type: */
class SOAP_CMAC tt__NetworkInterface : public tt__DeviceEntity
{
public:
	bool Enabled;	/* required element of XSD type xsd:boolean */
	tt__NetworkInterfaceInfo *Info;	/* optional element of XSD type tt:NetworkInterfaceInfo */
	tt__NetworkInterfaceLink *Link;	/* optional element of XSD type tt:NetworkInterfaceLink */
	tt__IPv4NetworkInterface *IPv4;	/* optional element of XSD type tt:IPv4NetworkInterface */
	tt__IPv6NetworkInterface *IPv6;	/* optional element of XSD type tt:IPv6NetworkInterface */
	tt__NetworkInterfaceExtension *Extension;	/* optional element of XSD type tt:NetworkInterfaceExtension */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterface (417)
	virtual int soap_type(void) const { return 417; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterface, default initialized and not managed by a soap context
	virtual tt__NetworkInterface *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterface); }
	         tt__NetworkInterface() { tt__NetworkInterface::soap_default(NULL); }
	virtual ~tt__NetworkInterface() { }
	friend SOAP_FMAC1 tt__NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1573 */
#ifndef SOAP_TYPE_tt__CertificateUsage
#define SOAP_TYPE_tt__CertificateUsage (526)
/* tt:CertificateUsage simple type: */
class SOAP_CMAC tt__CertificateUsage
{
public:
	std::string __item;	/* mixed XML content */
	bool Critical;	/* required attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateUsage (526)
	virtual int soap_type(void) const { return 526; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateUsage, default initialized and not managed by a soap context
	virtual tt__CertificateUsage *soap_alloc(void) const { return SOAP_NEW(tt__CertificateUsage); }
	         tt__CertificateUsage() { tt__CertificateUsage::soap_default(NULL); }
	virtual ~tt__CertificateUsage() { }
	friend SOAP_FMAC1 tt__CertificateUsage * SOAP_FMAC2 soap_instantiate_tt__CertificateUsage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1600 */
#ifndef SOAP_TYPE_tt__RelayOutput
#define SOAP_TYPE_tt__RelayOutput (535)
/* Type tt__RelayOutput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RelayOutput complex type: */
class SOAP_CMAC tt__RelayOutput : public tt__DeviceEntity
{
public:
	tt__RelayOutputSettings *Properties;	/* required element of XSD type tt:RelayOutputSettings */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelayOutput (535)
	virtual int soap_type(void) const { return 535; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelayOutput, default initialized and not managed by a soap context
	virtual tt__RelayOutput *soap_alloc(void) const { return SOAP_NEW(tt__RelayOutput); }
	         tt__RelayOutput() { tt__RelayOutput::soap_default(NULL); }
	virtual ~tt__RelayOutput() { }
	friend SOAP_FMAC1 tt__RelayOutput * SOAP_FMAC2 soap_instantiate_tt__RelayOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1603 */
#ifndef SOAP_TYPE_tt__DigitalInput
#define SOAP_TYPE_tt__DigitalInput (536)
/* Type tt__DigitalInput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DigitalInput complex type: */
class SOAP_CMAC tt__DigitalInput : public tt__DeviceEntity
{
public:
	enum tt__DigitalIdleState *IdleState;	/* optional attribute of XSD type tt:DigitalIdleState */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DigitalInput (536)
	virtual int soap_type(void) const { return 536; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DigitalInput, default initialized and not managed by a soap context
	virtual tt__DigitalInput *soap_alloc(void) const { return SOAP_NEW(tt__DigitalInput); }
	         tt__DigitalInput() { tt__DigitalInput::soap_default(NULL); }
	virtual ~tt__DigitalInput() { }
	friend SOAP_FMAC1 tt__DigitalInput * SOAP_FMAC2 soap_instantiate_tt__DigitalInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1606 */
#ifndef SOAP_TYPE_tt__PTZNode
#define SOAP_TYPE_tt__PTZNode (537)
/* Type tt__PTZNode is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZNode complex type: */
class SOAP_CMAC tt__PTZNode : public tt__DeviceEntity
{
public:
	std::string *Name;	/* optional element of XSD type tt:Name */
	tt__PTZSpaces *SupportedPTZSpaces;	/* required element of XSD type tt:PTZSpaces */
	int MaximumNumberOfPresets;	/* required element of XSD type xsd:int */
	bool HomeSupported;	/* required element of XSD type xsd:boolean */
	std::vector<std::string> AuxiliaryCommands;	/* optional element of XSD type tt:AuxiliaryData */
	tt__PTZNodeExtension *Extension;	/* optional element of XSD type tt:PTZNodeExtension */
	bool *FixedHomePosition;	/* optional attribute of XSD type xsd:boolean */
	bool *GeoMove;	/* optional attribute of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZNode (537)
	virtual int soap_type(void) const { return 537; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZNode, default initialized and not managed by a soap context
	virtual tt__PTZNode *soap_alloc(void) const { return SOAP_NEW(tt__PTZNode); }
	         tt__PTZNode() { tt__PTZNode::soap_default(NULL); }
	virtual ~tt__PTZNode() { }
	friend SOAP_FMAC1 tt__PTZNode * SOAP_FMAC2 soap_instantiate_tt__PTZNode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1621 */
#ifndef SOAP_TYPE_tt__PTZConfiguration
#define SOAP_TYPE_tt__PTZConfiguration (542)
/* Type tt__PTZConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZConfiguration complex type: */
class SOAP_CMAC tt__PTZConfiguration : public tt__ConfigurationEntity
{
public:
	std::string NodeToken;	/* required element of XSD type tt:ReferenceToken */
	std::string *DefaultAbsolutePantTiltPositionSpace;	/* optional element of XSD type xsd:anyURI */
	std::string *DefaultAbsoluteZoomPositionSpace;	/* optional element of XSD type xsd:anyURI */
	std::string *DefaultRelativePanTiltTranslationSpace;	/* optional element of XSD type xsd:anyURI */
	std::string *DefaultRelativeZoomTranslationSpace;	/* optional element of XSD type xsd:anyURI */
	std::string *DefaultContinuousPanTiltVelocitySpace;	/* optional element of XSD type xsd:anyURI */
	std::string *DefaultContinuousZoomVelocitySpace;	/* optional element of XSD type xsd:anyURI */
	tt__PTZSpeed *DefaultPTZSpeed;	/* optional element of XSD type tt:PTZSpeed */
	LONG64 *DefaultPTZTimeout;	/* optional element of XSD type xsd:duration */
	tt__PanTiltLimits *PanTiltLimits;	/* optional element of XSD type tt:PanTiltLimits */
	tt__ZoomLimits *ZoomLimits;	/* optional element of XSD type tt:ZoomLimits */
	tt__PTZConfigurationExtension *Extension;	/* optional element of XSD type tt:PTZConfigurationExtension */
	int *MoveRamp;	/* optional attribute of XSD type xsd:int */
	int *PresetRamp;	/* optional attribute of XSD type xsd:int */
	int *PresetTourRamp;	/* optional attribute of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfiguration (542)
	virtual int soap_type(void) const { return 542; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfiguration, default initialized and not managed by a soap context
	virtual tt__PTZConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfiguration); }
	         tt__PTZConfiguration() { tt__PTZConfiguration::soap_default(NULL); }
	virtual ~tt__PTZConfiguration() { }
	friend SOAP_FMAC1 tt__PTZConfiguration * SOAP_FMAC2 soap_instantiate_tt__PTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2074 */
#ifndef SOAP_TYPE_tt__EventFilter
#define SOAP_TYPE_tt__EventFilter (693)
/* Type tt__EventFilter is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EventFilter complex type: */
class SOAP_CMAC tt__EventFilter : public wsnt__FilterType
{
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EventFilter (693)
	virtual int soap_type(void) const { return 693; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EventFilter, default initialized and not managed by a soap context
	virtual tt__EventFilter *soap_alloc(void) const { return SOAP_NEW(tt__EventFilter); }
	         tt__EventFilter() { tt__EventFilter::soap_default(NULL); }
	virtual ~tt__EventFilter() { }
	friend SOAP_FMAC1 tt__EventFilter * SOAP_FMAC2 soap_instantiate_tt__EventFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2182 */
#ifndef SOAP_TYPE_tt__AnalyticsEngine
#define SOAP_TYPE_tt__AnalyticsEngine (729)
/* Type tt__AnalyticsEngine is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngine complex type: */
class SOAP_CMAC tt__AnalyticsEngine : public tt__ConfigurationEntity
{
public:
	tt__AnalyticsDeviceEngineConfiguration *AnalyticsEngineConfiguration;	/* required element of XSD type tt:AnalyticsDeviceEngineConfiguration */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngine (729)
	virtual int soap_type(void) const { return 729; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngine, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngine *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngine); }
	         tt__AnalyticsEngine() { tt__AnalyticsEngine::soap_default(NULL); }
	virtual ~tt__AnalyticsEngine() { }
	friend SOAP_FMAC1 tt__AnalyticsEngine * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2200 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineInput
#define SOAP_TYPE_tt__AnalyticsEngineInput (735)
/* Type tt__AnalyticsEngineInput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngineInput complex type: */
class SOAP_CMAC tt__AnalyticsEngineInput : public tt__ConfigurationEntity
{
public:
	tt__SourceIdentification *SourceIdentification;	/* required element of XSD type tt:SourceIdentification */
	tt__VideoEncoderConfiguration *VideoInput;	/* required element of XSD type tt:VideoEncoderConfiguration */
	tt__MetadataInput *MetadataInput;	/* required element of XSD type tt:MetadataInput */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineInput (735)
	virtual int soap_type(void) const { return 735; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineInput, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineInput *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineInput); }
	         tt__AnalyticsEngineInput() { tt__AnalyticsEngineInput::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineInput() { }
	friend SOAP_FMAC1 tt__AnalyticsEngineInput * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2215 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineControl
#define SOAP_TYPE_tt__AnalyticsEngineControl (740)
/* Type tt__AnalyticsEngineControl is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngineControl complex type: */
class SOAP_CMAC tt__AnalyticsEngineControl : public tt__ConfigurationEntity
{
public:
	std::string EngineToken;	/* required element of XSD type tt:ReferenceToken */
	std::string EngineConfigToken;	/* required element of XSD type tt:ReferenceToken */
	std::vector<std::string> InputToken;	/* required element of XSD type tt:ReferenceToken */
	std::vector<std::string> ReceiverToken;	/* required element of XSD type tt:ReferenceToken */
	tt__MulticastConfiguration *Multicast;	/* optional element of XSD type tt:MulticastConfiguration */
	tt__Config *Subscription;	/* required element of XSD type tt:Config */
	enum tt__ModeOfOperation Mode;	/* required element of XSD type tt:ModeOfOperation */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineControl (740)
	virtual int soap_type(void) const { return 740; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineControl, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineControl *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineControl); }
	         tt__AnalyticsEngineControl() { tt__AnalyticsEngineControl::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineControl() { }
	friend SOAP_FMAC1 tt__AnalyticsEngineControl * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2296 */
#ifndef SOAP_TYPE_tt__OSDConfiguration
#define SOAP_TYPE_tt__OSDConfiguration (767)
/* Type tt__OSDConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OSDConfiguration complex type: */
class SOAP_CMAC tt__OSDConfiguration : public tt__DeviceEntity
{
public:
	tt__OSDReference *VideoSourceConfigurationToken;	/* required element of XSD type tt:OSDReference */
	enum tt__OSDType Type;	/* required element of XSD type tt:OSDType */
	tt__OSDPosConfiguration *Position;	/* required element of XSD type tt:OSDPosConfiguration */
	tt__OSDTextConfiguration *TextString;	/* optional element of XSD type tt:OSDTextConfiguration */
	tt__OSDImgConfiguration *Image;	/* optional element of XSD type tt:OSDImgConfiguration */
	tt__OSDConfigurationExtension *Extension;	/* optional element of XSD type tt:OSDConfigurationExtension */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDConfiguration (767)
	virtual int soap_type(void) const { return 767; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDConfiguration, default initialized and not managed by a soap context
	virtual tt__OSDConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__OSDConfiguration); }
	         tt__OSDConfiguration() { tt__OSDConfiguration::soap_default(NULL); }
	virtual ~tt__OSDConfiguration() { }
	friend SOAP_FMAC1 tt__OSDConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2380 */
#ifndef SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType
#define SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType (795)
/* Type wsnt__SubscribeCreationFailedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:SubscribeCreationFailedFaultType complex type: */
class SOAP_CMAC wsnt__SubscribeCreationFailedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType (795)
	virtual int soap_type(void) const { return 795; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__SubscribeCreationFailedFaultType, default initialized and not managed by a soap context
	virtual wsnt__SubscribeCreationFailedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__SubscribeCreationFailedFaultType); }
	         wsnt__SubscribeCreationFailedFaultType() { wsnt__SubscribeCreationFailedFaultType::soap_default(NULL); }
	virtual ~wsnt__SubscribeCreationFailedFaultType() { }
	friend SOAP_FMAC1 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__SubscribeCreationFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2383 */
#ifndef SOAP_TYPE_wsnt__InvalidFilterFaultType
#define SOAP_TYPE_wsnt__InvalidFilterFaultType (796)
/* Type wsnt__InvalidFilterFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:InvalidFilterFaultType complex type: */
class SOAP_CMAC wsnt__InvalidFilterFaultType : public wsrfbf__BaseFaultType
{
public:
	std::vector<std::string> UnknownFilter;	/* required element of XSD type xsd:QName */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__InvalidFilterFaultType (796)
	virtual int soap_type(void) const { return 796; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__InvalidFilterFaultType, default initialized and not managed by a soap context
	virtual wsnt__InvalidFilterFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__InvalidFilterFaultType); }
	         wsnt__InvalidFilterFaultType() { wsnt__InvalidFilterFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidFilterFaultType() { }
	friend SOAP_FMAC1 wsnt__InvalidFilterFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidFilterFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2386 */
#ifndef SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType (797)
/* Type wsnt__TopicExpressionDialectUnknownFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:TopicExpressionDialectUnknownFaultType complex type: */
class SOAP_CMAC wsnt__TopicExpressionDialectUnknownFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType (797)
	virtual int soap_type(void) const { return 797; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__TopicExpressionDialectUnknownFaultType, default initialized and not managed by a soap context
	virtual wsnt__TopicExpressionDialectUnknownFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__TopicExpressionDialectUnknownFaultType); }
	         wsnt__TopicExpressionDialectUnknownFaultType() { wsnt__TopicExpressionDialectUnknownFaultType::soap_default(NULL); }
	virtual ~wsnt__TopicExpressionDialectUnknownFaultType() { }
	friend SOAP_FMAC1 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC2 soap_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2389 */
#ifndef SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType (798)
/* Type wsnt__InvalidTopicExpressionFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:InvalidTopicExpressionFaultType complex type: */
class SOAP_CMAC wsnt__InvalidTopicExpressionFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType (798)
	virtual int soap_type(void) const { return 798; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__InvalidTopicExpressionFaultType, default initialized and not managed by a soap context
	virtual wsnt__InvalidTopicExpressionFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__InvalidTopicExpressionFaultType); }
	         wsnt__InvalidTopicExpressionFaultType() { wsnt__InvalidTopicExpressionFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidTopicExpressionFaultType() { }
	friend SOAP_FMAC1 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidTopicExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2392 */
#ifndef SOAP_TYPE_wsnt__TopicNotSupportedFaultType
#define SOAP_TYPE_wsnt__TopicNotSupportedFaultType (799)
/* Type wsnt__TopicNotSupportedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:TopicNotSupportedFaultType complex type: */
class SOAP_CMAC wsnt__TopicNotSupportedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__TopicNotSupportedFaultType (799)
	virtual int soap_type(void) const { return 799; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__TopicNotSupportedFaultType, default initialized and not managed by a soap context
	virtual wsnt__TopicNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__TopicNotSupportedFaultType); }
	         wsnt__TopicNotSupportedFaultType() { wsnt__TopicNotSupportedFaultType::soap_default(NULL); }
	virtual ~wsnt__TopicNotSupportedFaultType() { }
	friend SOAP_FMAC1 wsnt__TopicNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__TopicNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2395 */
#ifndef SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType (800)
/* Type wsnt__MultipleTopicsSpecifiedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:MultipleTopicsSpecifiedFaultType complex type: */
class SOAP_CMAC wsnt__MultipleTopicsSpecifiedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType (800)
	virtual int soap_type(void) const { return 800; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__MultipleTopicsSpecifiedFaultType, default initialized and not managed by a soap context
	virtual wsnt__MultipleTopicsSpecifiedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__MultipleTopicsSpecifiedFaultType); }
	         wsnt__MultipleTopicsSpecifiedFaultType() { wsnt__MultipleTopicsSpecifiedFaultType::soap_default(NULL); }
	virtual ~wsnt__MultipleTopicsSpecifiedFaultType() { }
	friend SOAP_FMAC1 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2398 */
#ifndef SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType (801)
/* Type wsnt__InvalidProducerPropertiesExpressionFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:InvalidProducerPropertiesExpressionFaultType complex type: */
class SOAP_CMAC wsnt__InvalidProducerPropertiesExpressionFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType (801)
	virtual int soap_type(void) const { return 801; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__InvalidProducerPropertiesExpressionFaultType, default initialized and not managed by a soap context
	virtual wsnt__InvalidProducerPropertiesExpressionFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__InvalidProducerPropertiesExpressionFaultType); }
	         wsnt__InvalidProducerPropertiesExpressionFaultType() { wsnt__InvalidProducerPropertiesExpressionFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidProducerPropertiesExpressionFaultType() { }
	friend SOAP_FMAC1 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2401 */
#ifndef SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType (802)
/* Type wsnt__InvalidMessageContentExpressionFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:InvalidMessageContentExpressionFaultType complex type: */
class SOAP_CMAC wsnt__InvalidMessageContentExpressionFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType (802)
	virtual int soap_type(void) const { return 802; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__InvalidMessageContentExpressionFaultType, default initialized and not managed by a soap context
	virtual wsnt__InvalidMessageContentExpressionFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__InvalidMessageContentExpressionFaultType); }
	         wsnt__InvalidMessageContentExpressionFaultType() { wsnt__InvalidMessageContentExpressionFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidMessageContentExpressionFaultType() { }
	friend SOAP_FMAC1 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidMessageContentExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2404 */
#ifndef SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType (803)
/* Type wsnt__UnrecognizedPolicyRequestFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnrecognizedPolicyRequestFaultType complex type: */
class SOAP_CMAC wsnt__UnrecognizedPolicyRequestFaultType : public wsrfbf__BaseFaultType
{
public:
	std::vector<std::string> UnrecognizedPolicy;	/* optional element of XSD type xsd:QName */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType (803)
	virtual int soap_type(void) const { return 803; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnrecognizedPolicyRequestFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnrecognizedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnrecognizedPolicyRequestFaultType); }
	         wsnt__UnrecognizedPolicyRequestFaultType() { wsnt__UnrecognizedPolicyRequestFaultType::soap_default(NULL); }
	virtual ~wsnt__UnrecognizedPolicyRequestFaultType() { }
	friend SOAP_FMAC1 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2407 */
#ifndef SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType (804)
/* Type wsnt__UnsupportedPolicyRequestFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnsupportedPolicyRequestFaultType complex type: */
class SOAP_CMAC wsnt__UnsupportedPolicyRequestFaultType : public wsrfbf__BaseFaultType
{
public:
	std::vector<std::string> UnsupportedPolicy;	/* optional element of XSD type xsd:QName */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType (804)
	virtual int soap_type(void) const { return 804; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnsupportedPolicyRequestFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnsupportedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnsupportedPolicyRequestFaultType); }
	         wsnt__UnsupportedPolicyRequestFaultType() { wsnt__UnsupportedPolicyRequestFaultType::soap_default(NULL); }
	virtual ~wsnt__UnsupportedPolicyRequestFaultType() { }
	friend SOAP_FMAC1 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnsupportedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2410 */
#ifndef SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType (805)
/* Type wsnt__NotifyMessageNotSupportedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:NotifyMessageNotSupportedFaultType complex type: */
class SOAP_CMAC wsnt__NotifyMessageNotSupportedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType (805)
	virtual int soap_type(void) const { return 805; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__NotifyMessageNotSupportedFaultType, default initialized and not managed by a soap context
	virtual wsnt__NotifyMessageNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__NotifyMessageNotSupportedFaultType); }
	         wsnt__NotifyMessageNotSupportedFaultType() { wsnt__NotifyMessageNotSupportedFaultType::soap_default(NULL); }
	virtual ~wsnt__NotifyMessageNotSupportedFaultType() { }
	friend SOAP_FMAC1 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__NotifyMessageNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2413 */
#ifndef SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType (806)
/* Type wsnt__UnacceptableInitialTerminationTimeFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnacceptableInitialTerminationTimeFaultType complex type: */
class SOAP_CMAC wsnt__UnacceptableInitialTerminationTimeFaultType : public wsrfbf__BaseFaultType
{
public:
	time_t MinimumTime;	/* required element of XSD type xsd:dateTime */
	time_t *MaximumTime;	/* optional element of XSD type xsd:dateTime */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType (806)
	virtual int soap_type(void) const { return 806; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnacceptableInitialTerminationTimeFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnacceptableInitialTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnacceptableInitialTerminationTimeFaultType); }
	         wsnt__UnacceptableInitialTerminationTimeFaultType() { wsnt__UnacceptableInitialTerminationTimeFaultType::soap_default(NULL); }
	virtual ~wsnt__UnacceptableInitialTerminationTimeFaultType() { }
	friend SOAP_FMAC1 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2416 */
#ifndef SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType (807)
/* Type wsnt__NoCurrentMessageOnTopicFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:NoCurrentMessageOnTopicFaultType complex type: */
class SOAP_CMAC wsnt__NoCurrentMessageOnTopicFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType (807)
	virtual int soap_type(void) const { return 807; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__NoCurrentMessageOnTopicFaultType, default initialized and not managed by a soap context
	virtual wsnt__NoCurrentMessageOnTopicFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__NoCurrentMessageOnTopicFaultType); }
	         wsnt__NoCurrentMessageOnTopicFaultType() { wsnt__NoCurrentMessageOnTopicFaultType::soap_default(NULL); }
	virtual ~wsnt__NoCurrentMessageOnTopicFaultType() { }
	friend SOAP_FMAC1 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC2 soap_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2419 */
#ifndef SOAP_TYPE_wsnt__UnableToGetMessagesFaultType
#define SOAP_TYPE_wsnt__UnableToGetMessagesFaultType (808)
/* Type wsnt__UnableToGetMessagesFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnableToGetMessagesFaultType complex type: */
class SOAP_CMAC wsnt__UnableToGetMessagesFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnableToGetMessagesFaultType (808)
	virtual int soap_type(void) const { return 808; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnableToGetMessagesFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnableToGetMessagesFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnableToGetMessagesFaultType); }
	         wsnt__UnableToGetMessagesFaultType() { wsnt__UnableToGetMessagesFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToGetMessagesFaultType() { }
	friend SOAP_FMAC1 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToGetMessagesFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2422 */
#ifndef SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType (809)
/* Type wsnt__UnableToDestroyPullPointFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnableToDestroyPullPointFaultType complex type: */
class SOAP_CMAC wsnt__UnableToDestroyPullPointFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType (809)
	virtual int soap_type(void) const { return 809; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnableToDestroyPullPointFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnableToDestroyPullPointFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnableToDestroyPullPointFaultType); }
	         wsnt__UnableToDestroyPullPointFaultType() { wsnt__UnableToDestroyPullPointFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToDestroyPullPointFaultType() { }
	friend SOAP_FMAC1 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToDestroyPullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2425 */
#ifndef SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType
#define SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType (810)
/* Type wsnt__UnableToCreatePullPointFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnableToCreatePullPointFaultType complex type: */
class SOAP_CMAC wsnt__UnableToCreatePullPointFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType (810)
	virtual int soap_type(void) const { return 810; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnableToCreatePullPointFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnableToCreatePullPointFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnableToCreatePullPointFaultType); }
	         wsnt__UnableToCreatePullPointFaultType() { wsnt__UnableToCreatePullPointFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToCreatePullPointFaultType() { }
	friend SOAP_FMAC1 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToCreatePullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2428 */
#ifndef SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType (811)
/* Type wsnt__UnacceptableTerminationTimeFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnacceptableTerminationTimeFaultType complex type: */
class SOAP_CMAC wsnt__UnacceptableTerminationTimeFaultType : public wsrfbf__BaseFaultType
{
public:
	time_t MinimumTime;	/* required element of XSD type xsd:dateTime */
	time_t *MaximumTime;	/* optional element of XSD type xsd:dateTime */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType (811)
	virtual int soap_type(void) const { return 811; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnacceptableTerminationTimeFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnacceptableTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnacceptableTerminationTimeFaultType); }
	         wsnt__UnacceptableTerminationTimeFaultType() { wsnt__UnacceptableTerminationTimeFaultType::soap_default(NULL); }
	virtual ~wsnt__UnacceptableTerminationTimeFaultType() { }
	friend SOAP_FMAC1 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnacceptableTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2431 */
#ifndef SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType (812)
/* Type wsnt__UnableToDestroySubscriptionFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnableToDestroySubscriptionFaultType complex type: */
class SOAP_CMAC wsnt__UnableToDestroySubscriptionFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType (812)
	virtual int soap_type(void) const { return 812; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnableToDestroySubscriptionFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnableToDestroySubscriptionFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnableToDestroySubscriptionFaultType); }
	         wsnt__UnableToDestroySubscriptionFaultType() { wsnt__UnableToDestroySubscriptionFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToDestroySubscriptionFaultType() { }
	friend SOAP_FMAC1 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToDestroySubscriptionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2434 */
#ifndef SOAP_TYPE_wsnt__PauseFailedFaultType
#define SOAP_TYPE_wsnt__PauseFailedFaultType (813)
/* Type wsnt__PauseFailedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:PauseFailedFaultType complex type: */
class SOAP_CMAC wsnt__PauseFailedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__PauseFailedFaultType (813)
	virtual int soap_type(void) const { return 813; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__PauseFailedFaultType, default initialized and not managed by a soap context
	virtual wsnt__PauseFailedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__PauseFailedFaultType); }
	         wsnt__PauseFailedFaultType() { wsnt__PauseFailedFaultType::soap_default(NULL); }
	virtual ~wsnt__PauseFailedFaultType() { }
	friend SOAP_FMAC1 wsnt__PauseFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__PauseFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2437 */
#ifndef SOAP_TYPE_wsnt__ResumeFailedFaultType
#define SOAP_TYPE_wsnt__ResumeFailedFaultType (814)
/* Type wsnt__ResumeFailedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:ResumeFailedFaultType complex type: */
class SOAP_CMAC wsnt__ResumeFailedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__ResumeFailedFaultType (814)
	virtual int soap_type(void) const { return 814; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__ResumeFailedFaultType, default initialized and not managed by a soap context
	virtual wsnt__ResumeFailedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__ResumeFailedFaultType); }
	         wsnt__ResumeFailedFaultType() { wsnt__ResumeFailedFaultType::soap_default(NULL); }
	virtual ~wsnt__ResumeFailedFaultType() { }
	friend SOAP_FMAC1 wsnt__ResumeFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__ResumeFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:30039 */
#ifndef SOAP_TYPE__wstop__TopicNamespaceType_Topic
#define SOAP_TYPE__wstop__TopicNamespaceType_Topic (1572)
/* wstop:TopicNamespaceType-Topic complex type: */
class SOAP_CMAC _wstop__TopicNamespaceType_Topic
{
public:
	wstop__Documentation *documentation;	/* optional element of XSD type wstop:Documentation */
	wstop__QueryExpressionType *MessagePattern;	/* optional element of XSD type wstop:QueryExpressionType */
	std::vector<wstop__TopicType *> Topic;	/* optional element of XSD type wstop:TopicType */
	std::string name;	/* required attribute of XSD type xsd:NCName */
	std::string *messageTypes;	/* optional attribute of XSD type xsd:QName */
	bool final_;	/* optional attribute of XSD type xsd:boolean */
	std::string *parent;	/* optional attribute of XSD type wstop:ConcreteTopicExpression */
public:
	/// Return the unique type ID value SOAP_TYPE__wstop__TopicNamespaceType_Topic (1572)
	virtual int soap_type(void) const { return 1572; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wstop__TopicNamespaceType_Topic, default initialized and not managed by a soap context
	virtual _wstop__TopicNamespaceType_Topic *soap_alloc(void) const { return SOAP_NEW(_wstop__TopicNamespaceType_Topic); }
	         _wstop__TopicNamespaceType_Topic() { _wstop__TopicNamespaceType_Topic::soap_default(NULL); }
	virtual ~_wstop__TopicNamespaceType_Topic() { }
	friend SOAP_FMAC1 _wstop__TopicNamespaceType_Topic * SOAP_FMAC2 soap_instantiate__wstop__TopicNamespaceType_Topic(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2518 */
#ifndef SOAP_TYPE_wstop__TopicNamespaceType
#define SOAP_TYPE_wstop__TopicNamespaceType (841)
/* Type wstop__TopicNamespaceType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:TopicNamespaceType complex type: */
class SOAP_CMAC wstop__TopicNamespaceType : public wstop__ExtensibleDocumented
{
public:
	std::vector<_wstop__TopicNamespaceType_Topic> *Topic;	/* optional element of XSD type wstop:TopicNamespaceType-Topic */
	std::string *name;	/* optional attribute of XSD type xsd:NCName */
	std::string targetNamespace;	/* required attribute of XSD type xsd:anyURI */
	bool final_;	/* optional attribute of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__TopicNamespaceType (841)
	virtual int soap_type(void) const { return 841; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__TopicNamespaceType, default initialized and not managed by a soap context
	virtual wstop__TopicNamespaceType *soap_alloc(void) const { return SOAP_NEW(wstop__TopicNamespaceType); }
	         wstop__TopicNamespaceType() { wstop__TopicNamespaceType::soap_default(NULL); }
	virtual ~wstop__TopicNamespaceType() { }
	friend SOAP_FMAC1 wstop__TopicNamespaceType * SOAP_FMAC2 soap_instantiate_wstop__TopicNamespaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2521 */
#ifndef SOAP_TYPE_wstop__TopicType
#define SOAP_TYPE_wstop__TopicType (842)
/* Type wstop__TopicType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:TopicType complex type: */
class SOAP_CMAC wstop__TopicType : public wstop__ExtensibleDocumented
{
public:
	wstop__QueryExpressionType *MessagePattern;	/* optional element of XSD type wstop:QueryExpressionType */
	std::vector<wstop__TopicType *> Topic;	/* optional element of XSD type wstop:TopicType */
	std::string name;	/* required attribute of XSD type xsd:NCName */
	std::string *messageTypes;	/* optional attribute of XSD type xsd:QName */
	bool final_;	/* optional attribute of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__TopicType (842)
	virtual int soap_type(void) const { return 842; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__TopicType, default initialized and not managed by a soap context
	virtual wstop__TopicType *soap_alloc(void) const { return SOAP_NEW(wstop__TopicType); }
	         wstop__TopicType() { wstop__TopicType::soap_default(NULL); }
	virtual ~wstop__TopicType() { }
	friend SOAP_FMAC1 wstop__TopicType * SOAP_FMAC2 soap_instantiate_wstop__TopicType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2524 */
#ifndef SOAP_TYPE_wstop__TopicSetType
#define SOAP_TYPE_wstop__TopicSetType (843)
/* Type wstop__TopicSetType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:TopicSetType complex type: */
class SOAP_CMAC wstop__TopicSetType : public wstop__ExtensibleDocumented
{
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__TopicSetType (843)
	virtual int soap_type(void) const { return 843; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__TopicSetType, default initialized and not managed by a soap context
	virtual wstop__TopicSetType *soap_alloc(void) const { return SOAP_NEW(wstop__TopicSetType); }
	         wstop__TopicSetType() { wstop__TopicSetType::soap_default(NULL); }
	virtual ~wstop__TopicSetType() { }
	friend SOAP_FMAC1 wstop__TopicSetType * SOAP_FMAC2 soap_instantiate_wstop__TopicSetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2248 */
#ifndef SOAP_TYPE_tt__OSDReference
#define SOAP_TYPE_tt__OSDReference (751)
/* tt:OSDReference simple type: */
class SOAP_CMAC tt__OSDReference
{
public:
	std::string __item;	/* mixed XML content */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OSDReference (751)
	virtual int soap_type(void) const { return 751; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OSDReference, default initialized and not managed by a soap context
	virtual tt__OSDReference *soap_alloc(void) const { return SOAP_NEW(tt__OSDReference); }
	         tt__OSDReference() { tt__OSDReference::soap_default(NULL); }
	virtual ~tt__OSDReference() { }
	friend SOAP_FMAC1 tt__OSDReference * SOAP_FMAC2 soap_instantiate_tt__OSDReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:30894 */
#ifndef SOAP_TYPE___tds__GetServices
#define SOAP_TYPE___tds__GetServices (1584)
/* Operation wrapper: */
struct __tds__GetServices
{
public:
	_tds__GetServices *tds__GetServices;	/* optional element of XSD type tds:GetServices */
public:
	int soap_type() const { return 1584; } /* = unique type id SOAP_TYPE___tds__GetServices */
	         __tds__GetServices();
	friend SOAP_FMAC1 __tds__GetServices * SOAP_FMAC2 soap_instantiate___tds__GetServices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:30962 */
#ifndef SOAP_TYPE___tds__GetServiceCapabilities
#define SOAP_TYPE___tds__GetServiceCapabilities (1588)
/* Operation wrapper: */
struct __tds__GetServiceCapabilities
{
public:
	_tds__GetServiceCapabilities *tds__GetServiceCapabilities;	/* optional element of XSD type tds:GetServiceCapabilities */
public:
	int soap_type() const { return 1588; } /* = unique type id SOAP_TYPE___tds__GetServiceCapabilities */
	         __tds__GetServiceCapabilities();
	friend SOAP_FMAC1 __tds__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tds__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31029 */
#ifndef SOAP_TYPE___tds__GetDeviceInformation
#define SOAP_TYPE___tds__GetDeviceInformation (1592)
/* Operation wrapper: */
struct __tds__GetDeviceInformation
{
public:
	_tds__GetDeviceInformation *tds__GetDeviceInformation;	/* optional element of XSD type tds:GetDeviceInformation */
public:
	int soap_type() const { return 1592; } /* = unique type id SOAP_TYPE___tds__GetDeviceInformation */
	         __tds__GetDeviceInformation();
	friend SOAP_FMAC1 __tds__GetDeviceInformation * SOAP_FMAC2 soap_instantiate___tds__GetDeviceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31101 */
#ifndef SOAP_TYPE___tds__SetSystemDateAndTime
#define SOAP_TYPE___tds__SetSystemDateAndTime (1596)
/* Operation wrapper: */
struct __tds__SetSystemDateAndTime
{
public:
	_tds__SetSystemDateAndTime *tds__SetSystemDateAndTime;	/* optional element of XSD type tds:SetSystemDateAndTime */
public:
	int soap_type() const { return 1596; } /* = unique type id SOAP_TYPE___tds__SetSystemDateAndTime */
	         __tds__SetSystemDateAndTime();
	friend SOAP_FMAC1 __tds__SetSystemDateAndTime * SOAP_FMAC2 soap_instantiate___tds__SetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31173 */
#ifndef SOAP_TYPE___tds__GetSystemDateAndTime
#define SOAP_TYPE___tds__GetSystemDateAndTime (1600)
/* Operation wrapper: */
struct __tds__GetSystemDateAndTime
{
public:
	_tds__GetSystemDateAndTime *tds__GetSystemDateAndTime;	/* optional element of XSD type tds:GetSystemDateAndTime */
public:
	int soap_type() const { return 1600; } /* = unique type id SOAP_TYPE___tds__GetSystemDateAndTime */
	         __tds__GetSystemDateAndTime();
	friend SOAP_FMAC1 __tds__GetSystemDateAndTime * SOAP_FMAC2 soap_instantiate___tds__GetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31240 */
#ifndef SOAP_TYPE___tds__SetSystemFactoryDefault
#define SOAP_TYPE___tds__SetSystemFactoryDefault (1604)
/* Operation wrapper: */
struct __tds__SetSystemFactoryDefault
{
public:
	_tds__SetSystemFactoryDefault *tds__SetSystemFactoryDefault;	/* optional element of XSD type tds:SetSystemFactoryDefault */
public:
	int soap_type() const { return 1604; } /* = unique type id SOAP_TYPE___tds__SetSystemFactoryDefault */
	         __tds__SetSystemFactoryDefault();
	friend SOAP_FMAC1 __tds__SetSystemFactoryDefault * SOAP_FMAC2 soap_instantiate___tds__SetSystemFactoryDefault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31313 */
#ifndef SOAP_TYPE___tds__UpgradeSystemFirmware
#define SOAP_TYPE___tds__UpgradeSystemFirmware (1608)
/* Operation wrapper: */
struct __tds__UpgradeSystemFirmware
{
public:
	_tds__UpgradeSystemFirmware *tds__UpgradeSystemFirmware;	/* optional element of XSD type tds:UpgradeSystemFirmware */
public:
	int soap_type() const { return 1608; } /* = unique type id SOAP_TYPE___tds__UpgradeSystemFirmware */
	         __tds__UpgradeSystemFirmware();
	friend SOAP_FMAC1 __tds__UpgradeSystemFirmware * SOAP_FMAC2 soap_instantiate___tds__UpgradeSystemFirmware(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31380 */
#ifndef SOAP_TYPE___tds__SystemReboot
#define SOAP_TYPE___tds__SystemReboot (1612)
/* Operation wrapper: */
struct __tds__SystemReboot
{
public:
	_tds__SystemReboot *tds__SystemReboot;	/* optional element of XSD type tds:SystemReboot */
public:
	int soap_type() const { return 1612; } /* = unique type id SOAP_TYPE___tds__SystemReboot */
	         __tds__SystemReboot();
	friend SOAP_FMAC1 __tds__SystemReboot * SOAP_FMAC2 soap_instantiate___tds__SystemReboot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31455 */
#ifndef SOAP_TYPE___tds__RestoreSystem
#define SOAP_TYPE___tds__RestoreSystem (1616)
/* Operation wrapper: */
struct __tds__RestoreSystem
{
public:
	_tds__RestoreSystem *tds__RestoreSystem;	/* optional element of XSD type tds:RestoreSystem */
public:
	int soap_type() const { return 1616; } /* = unique type id SOAP_TYPE___tds__RestoreSystem */
	         __tds__RestoreSystem();
	friend SOAP_FMAC1 __tds__RestoreSystem * SOAP_FMAC2 soap_instantiate___tds__RestoreSystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31529 */
#ifndef SOAP_TYPE___tds__GetSystemBackup
#define SOAP_TYPE___tds__GetSystemBackup (1620)
/* Operation wrapper: */
struct __tds__GetSystemBackup
{
public:
	_tds__GetSystemBackup *tds__GetSystemBackup;	/* optional element of XSD type tds:GetSystemBackup */
public:
	int soap_type() const { return 1620; } /* = unique type id SOAP_TYPE___tds__GetSystemBackup */
	         __tds__GetSystemBackup();
	friend SOAP_FMAC1 __tds__GetSystemBackup * SOAP_FMAC2 soap_instantiate___tds__GetSystemBackup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31597 */
#ifndef SOAP_TYPE___tds__GetSystemLog
#define SOAP_TYPE___tds__GetSystemLog (1624)
/* Operation wrapper: */
struct __tds__GetSystemLog
{
public:
	_tds__GetSystemLog *tds__GetSystemLog;	/* optional element of XSD type tds:GetSystemLog */
public:
	int soap_type() const { return 1624; } /* = unique type id SOAP_TYPE___tds__GetSystemLog */
	         __tds__GetSystemLog();
	friend SOAP_FMAC1 __tds__GetSystemLog * SOAP_FMAC2 soap_instantiate___tds__GetSystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31664 */
#ifndef SOAP_TYPE___tds__GetSystemSupportInformation
#define SOAP_TYPE___tds__GetSystemSupportInformation (1628)
/* Operation wrapper: */
struct __tds__GetSystemSupportInformation
{
public:
	_tds__GetSystemSupportInformation *tds__GetSystemSupportInformation;	/* optional element of XSD type tds:GetSystemSupportInformation */
public:
	int soap_type() const { return 1628; } /* = unique type id SOAP_TYPE___tds__GetSystemSupportInformation */
	         __tds__GetSystemSupportInformation();
	friend SOAP_FMAC1 __tds__GetSystemSupportInformation * SOAP_FMAC2 soap_instantiate___tds__GetSystemSupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31735 */
#ifndef SOAP_TYPE___tds__GetScopes
#define SOAP_TYPE___tds__GetScopes (1632)
/* Operation wrapper: */
struct __tds__GetScopes
{
public:
	_tds__GetScopes *tds__GetScopes;	/* optional element of XSD type tds:GetScopes */
public:
	int soap_type() const { return 1632; } /* = unique type id SOAP_TYPE___tds__GetScopes */
	         __tds__GetScopes();
	friend SOAP_FMAC1 __tds__GetScopes * SOAP_FMAC2 soap_instantiate___tds__GetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31810 */
#ifndef SOAP_TYPE___tds__SetScopes
#define SOAP_TYPE___tds__SetScopes (1636)
/* Operation wrapper: */
struct __tds__SetScopes
{
public:
	_tds__SetScopes *tds__SetScopes;	/* optional element of XSD type tds:SetScopes */
public:
	int soap_type() const { return 1636; } /* = unique type id SOAP_TYPE___tds__SetScopes */
	         __tds__SetScopes();
	friend SOAP_FMAC1 __tds__SetScopes * SOAP_FMAC2 soap_instantiate___tds__SetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31881 */
#ifndef SOAP_TYPE___tds__AddScopes
#define SOAP_TYPE___tds__AddScopes (1640)
/* Operation wrapper: */
struct __tds__AddScopes
{
public:
	_tds__AddScopes *tds__AddScopes;	/* optional element of XSD type tds:AddScopes */
public:
	int soap_type() const { return 1640; } /* = unique type id SOAP_TYPE___tds__AddScopes */
	         __tds__AddScopes();
	friend SOAP_FMAC1 __tds__AddScopes * SOAP_FMAC2 soap_instantiate___tds__AddScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31954 */
#ifndef SOAP_TYPE___tds__RemoveScopes
#define SOAP_TYPE___tds__RemoveScopes (1644)
/* Operation wrapper: */
struct __tds__RemoveScopes
{
public:
	_tds__RemoveScopes *tds__RemoveScopes;	/* optional element of XSD type tds:RemoveScopes */
public:
	int soap_type() const { return 1644; } /* = unique type id SOAP_TYPE___tds__RemoveScopes */
	         __tds__RemoveScopes();
	friend SOAP_FMAC1 __tds__RemoveScopes * SOAP_FMAC2 soap_instantiate___tds__RemoveScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32025 */
#ifndef SOAP_TYPE___tds__GetDiscoveryMode
#define SOAP_TYPE___tds__GetDiscoveryMode (1648)
/* Operation wrapper: */
struct __tds__GetDiscoveryMode
{
public:
	_tds__GetDiscoveryMode *tds__GetDiscoveryMode;	/* optional element of XSD type tds:GetDiscoveryMode */
public:
	int soap_type() const { return 1648; } /* = unique type id SOAP_TYPE___tds__GetDiscoveryMode */
	         __tds__GetDiscoveryMode();
	friend SOAP_FMAC1 __tds__GetDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__GetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32097 */
#ifndef SOAP_TYPE___tds__SetDiscoveryMode
#define SOAP_TYPE___tds__SetDiscoveryMode (1652)
/* Operation wrapper: */
struct __tds__SetDiscoveryMode
{
public:
	_tds__SetDiscoveryMode *tds__SetDiscoveryMode;	/* optional element of XSD type tds:SetDiscoveryMode */
public:
	int soap_type() const { return 1652; } /* = unique type id SOAP_TYPE___tds__SetDiscoveryMode */
	         __tds__SetDiscoveryMode();
	friend SOAP_FMAC1 __tds__SetDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__SetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32170 */
#ifndef SOAP_TYPE___tds__GetRemoteDiscoveryMode
#define SOAP_TYPE___tds__GetRemoteDiscoveryMode (1656)
/* Operation wrapper: */
struct __tds__GetRemoteDiscoveryMode
{
public:
	_tds__GetRemoteDiscoveryMode *tds__GetRemoteDiscoveryMode;	/* optional element of XSD type tds:GetRemoteDiscoveryMode */
public:
	int soap_type() const { return 1656; } /* = unique type id SOAP_TYPE___tds__GetRemoteDiscoveryMode */
	         __tds__GetRemoteDiscoveryMode();
	friend SOAP_FMAC1 __tds__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__GetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32243 */
#ifndef SOAP_TYPE___tds__SetRemoteDiscoveryMode
#define SOAP_TYPE___tds__SetRemoteDiscoveryMode (1660)
/* Operation wrapper: */
struct __tds__SetRemoteDiscoveryMode
{
public:
	_tds__SetRemoteDiscoveryMode *tds__SetRemoteDiscoveryMode;	/* optional element of XSD type tds:SetRemoteDiscoveryMode */
public:
	int soap_type() const { return 1660; } /* = unique type id SOAP_TYPE___tds__SetRemoteDiscoveryMode */
	         __tds__SetRemoteDiscoveryMode();
	friend SOAP_FMAC1 __tds__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__SetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32314 */
#ifndef SOAP_TYPE___tds__GetDPAddresses
#define SOAP_TYPE___tds__GetDPAddresses (1664)
/* Operation wrapper: */
struct __tds__GetDPAddresses
{
public:
	_tds__GetDPAddresses *tds__GetDPAddresses;	/* optional element of XSD type tds:GetDPAddresses */
public:
	int soap_type() const { return 1664; } /* = unique type id SOAP_TYPE___tds__GetDPAddresses */
	         __tds__GetDPAddresses();
	friend SOAP_FMAC1 __tds__GetDPAddresses * SOAP_FMAC2 soap_instantiate___tds__GetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32387 */
#ifndef SOAP_TYPE___tds__GetEndpointReference
#define SOAP_TYPE___tds__GetEndpointReference (1668)
/* Operation wrapper: */
struct __tds__GetEndpointReference
{
public:
	_tds__GetEndpointReference *tds__GetEndpointReference;	/* optional element of XSD type tds:GetEndpointReference */
public:
	int soap_type() const { return 1668; } /* = unique type id SOAP_TYPE___tds__GetEndpointReference */
	         __tds__GetEndpointReference();
	friend SOAP_FMAC1 __tds__GetEndpointReference * SOAP_FMAC2 soap_instantiate___tds__GetEndpointReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32458 */
#ifndef SOAP_TYPE___tds__GetRemoteUser
#define SOAP_TYPE___tds__GetRemoteUser (1672)
/* Operation wrapper: */
struct __tds__GetRemoteUser
{
public:
	_tds__GetRemoteUser *tds__GetRemoteUser;	/* optional element of XSD type tds:GetRemoteUser */
public:
	int soap_type() const { return 1672; } /* = unique type id SOAP_TYPE___tds__GetRemoteUser */
	         __tds__GetRemoteUser();
	friend SOAP_FMAC1 __tds__GetRemoteUser * SOAP_FMAC2 soap_instantiate___tds__GetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32528 */
#ifndef SOAP_TYPE___tds__SetRemoteUser
#define SOAP_TYPE___tds__SetRemoteUser (1676)
/* Operation wrapper: */
struct __tds__SetRemoteUser
{
public:
	_tds__SetRemoteUser *tds__SetRemoteUser;	/* optional element of XSD type tds:SetRemoteUser */
public:
	int soap_type() const { return 1676; } /* = unique type id SOAP_TYPE___tds__SetRemoteUser */
	         __tds__SetRemoteUser();
	friend SOAP_FMAC1 __tds__SetRemoteUser * SOAP_FMAC2 soap_instantiate___tds__SetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32599 */
#ifndef SOAP_TYPE___tds__GetUsers
#define SOAP_TYPE___tds__GetUsers (1680)
/* Operation wrapper: */
struct __tds__GetUsers
{
public:
	_tds__GetUsers *tds__GetUsers;	/* optional element of XSD type tds:GetUsers */
public:
	int soap_type() const { return 1680; } /* = unique type id SOAP_TYPE___tds__GetUsers */
	         __tds__GetUsers();
	friend SOAP_FMAC1 __tds__GetUsers * SOAP_FMAC2 soap_instantiate___tds__GetUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32672 */
#ifndef SOAP_TYPE___tds__CreateUsers
#define SOAP_TYPE___tds__CreateUsers (1684)
/* Operation wrapper: */
struct __tds__CreateUsers
{
public:
	_tds__CreateUsers *tds__CreateUsers;	/* optional element of XSD type tds:CreateUsers */
public:
	int soap_type() const { return 1684; } /* = unique type id SOAP_TYPE___tds__CreateUsers */
	         __tds__CreateUsers();
	friend SOAP_FMAC1 __tds__CreateUsers * SOAP_FMAC2 soap_instantiate___tds__CreateUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32746 */
#ifndef SOAP_TYPE___tds__DeleteUsers
#define SOAP_TYPE___tds__DeleteUsers (1688)
/* Operation wrapper: */
struct __tds__DeleteUsers
{
public:
	_tds__DeleteUsers *tds__DeleteUsers;	/* optional element of XSD type tds:DeleteUsers */
public:
	int soap_type() const { return 1688; } /* = unique type id SOAP_TYPE___tds__DeleteUsers */
	         __tds__DeleteUsers();
	friend SOAP_FMAC1 __tds__DeleteUsers * SOAP_FMAC2 soap_instantiate___tds__DeleteUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32818 */
#ifndef SOAP_TYPE___tds__SetUser
#define SOAP_TYPE___tds__SetUser (1692)
/* Operation wrapper: */
struct __tds__SetUser
{
public:
	_tds__SetUser *tds__SetUser;	/* optional element of XSD type tds:SetUser */
public:
	int soap_type() const { return 1692; } /* = unique type id SOAP_TYPE___tds__SetUser */
	         __tds__SetUser();
	friend SOAP_FMAC1 __tds__SetUser * SOAP_FMAC2 soap_instantiate___tds__SetUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32892 */
#ifndef SOAP_TYPE___tds__GetWsdlUrl
#define SOAP_TYPE___tds__GetWsdlUrl (1696)
/* Operation wrapper: */
struct __tds__GetWsdlUrl
{
public:
	_tds__GetWsdlUrl *tds__GetWsdlUrl;	/* optional element of XSD type tds:GetWsdlUrl */
public:
	int soap_type() const { return 1696; } /* = unique type id SOAP_TYPE___tds__GetWsdlUrl */
	         __tds__GetWsdlUrl();
	friend SOAP_FMAC1 __tds__GetWsdlUrl * SOAP_FMAC2 soap_instantiate___tds__GetWsdlUrl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32968 */
#ifndef SOAP_TYPE___tds__GetCapabilities
#define SOAP_TYPE___tds__GetCapabilities (1700)
/* Operation wrapper: */
struct __tds__GetCapabilities
{
public:
	_tds__GetCapabilities *tds__GetCapabilities;	/* optional element of XSD type tds:GetCapabilities */
public:
	int soap_type() const { return 1700; } /* = unique type id SOAP_TYPE___tds__GetCapabilities */
	         __tds__GetCapabilities();
	friend SOAP_FMAC1 __tds__GetCapabilities * SOAP_FMAC2 soap_instantiate___tds__GetCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33040 */
#ifndef SOAP_TYPE___tds__SetDPAddresses
#define SOAP_TYPE___tds__SetDPAddresses (1704)
/* Operation wrapper: */
struct __tds__SetDPAddresses
{
public:
	_tds__SetDPAddresses *tds__SetDPAddresses;	/* optional element of XSD type tds:SetDPAddresses */
public:
	int soap_type() const { return 1704; } /* = unique type id SOAP_TYPE___tds__SetDPAddresses */
	         __tds__SetDPAddresses();
	friend SOAP_FMAC1 __tds__SetDPAddresses * SOAP_FMAC2 soap_instantiate___tds__SetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33110 */
#ifndef SOAP_TYPE___tds__GetHostname
#define SOAP_TYPE___tds__GetHostname (1708)
/* Operation wrapper: */
struct __tds__GetHostname
{
public:
	_tds__GetHostname *tds__GetHostname;	/* optional element of XSD type tds:GetHostname */
public:
	int soap_type() const { return 1708; } /* = unique type id SOAP_TYPE___tds__GetHostname */
	         __tds__GetHostname();
	friend SOAP_FMAC1 __tds__GetHostname * SOAP_FMAC2 soap_instantiate___tds__GetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33179 */
#ifndef SOAP_TYPE___tds__SetHostname
#define SOAP_TYPE___tds__SetHostname (1712)
/* Operation wrapper: */
struct __tds__SetHostname
{
public:
	_tds__SetHostname *tds__SetHostname;	/* optional element of XSD type tds:SetHostname */
public:
	int soap_type() const { return 1712; } /* = unique type id SOAP_TYPE___tds__SetHostname */
	         __tds__SetHostname();
	friend SOAP_FMAC1 __tds__SetHostname * SOAP_FMAC2 soap_instantiate___tds__SetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33246 */
#ifndef SOAP_TYPE___tds__SetHostnameFromDHCP
#define SOAP_TYPE___tds__SetHostnameFromDHCP (1716)
/* Operation wrapper: */
struct __tds__SetHostnameFromDHCP
{
public:
	_tds__SetHostnameFromDHCP *tds__SetHostnameFromDHCP;	/* optional element of XSD type tds:SetHostnameFromDHCP */
public:
	int soap_type() const { return 1716; } /* = unique type id SOAP_TYPE___tds__SetHostnameFromDHCP */
	         __tds__SetHostnameFromDHCP();
	friend SOAP_FMAC1 __tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate___tds__SetHostnameFromDHCP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33315 */
#ifndef SOAP_TYPE___tds__GetDNS
#define SOAP_TYPE___tds__GetDNS (1720)
/* Operation wrapper: */
struct __tds__GetDNS
{
public:
	_tds__GetDNS *tds__GetDNS;	/* optional element of XSD type tds:GetDNS */
public:
	int soap_type() const { return 1720; } /* = unique type id SOAP_TYPE___tds__GetDNS */
	         __tds__GetDNS();
	friend SOAP_FMAC1 __tds__GetDNS * SOAP_FMAC2 soap_instantiate___tds__GetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33384 */
#ifndef SOAP_TYPE___tds__SetDNS
#define SOAP_TYPE___tds__SetDNS (1724)
/* Operation wrapper: */
struct __tds__SetDNS
{
public:
	_tds__SetDNS *tds__SetDNS;	/* optional element of XSD type tds:SetDNS */
public:
	int soap_type() const { return 1724; } /* = unique type id SOAP_TYPE___tds__SetDNS */
	         __tds__SetDNS();
	friend SOAP_FMAC1 __tds__SetDNS * SOAP_FMAC2 soap_instantiate___tds__SetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33454 */
#ifndef SOAP_TYPE___tds__GetNTP
#define SOAP_TYPE___tds__GetNTP (1728)
/* Operation wrapper: */
struct __tds__GetNTP
{
public:
	_tds__GetNTP *tds__GetNTP;	/* optional element of XSD type tds:GetNTP */
public:
	int soap_type() const { return 1728; } /* = unique type id SOAP_TYPE___tds__GetNTP */
	         __tds__GetNTP();
	friend SOAP_FMAC1 __tds__GetNTP * SOAP_FMAC2 soap_instantiate___tds__GetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33524 */
#ifndef SOAP_TYPE___tds__SetNTP
#define SOAP_TYPE___tds__SetNTP (1732)
/* Operation wrapper: */
struct __tds__SetNTP
{
public:
	_tds__SetNTP *tds__SetNTP;	/* optional element of XSD type tds:SetNTP */
public:
	int soap_type() const { return 1732; } /* = unique type id SOAP_TYPE___tds__SetNTP */
	         __tds__SetNTP();
	friend SOAP_FMAC1 __tds__SetNTP * SOAP_FMAC2 soap_instantiate___tds__SetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33595 */
#ifndef SOAP_TYPE___tds__GetDynamicDNS
#define SOAP_TYPE___tds__GetDynamicDNS (1736)
/* Operation wrapper: */
struct __tds__GetDynamicDNS
{
public:
	_tds__GetDynamicDNS *tds__GetDynamicDNS;	/* optional element of XSD type tds:GetDynamicDNS */
public:
	int soap_type() const { return 1736; } /* = unique type id SOAP_TYPE___tds__GetDynamicDNS */
	         __tds__GetDynamicDNS();
	friend SOAP_FMAC1 __tds__GetDynamicDNS * SOAP_FMAC2 soap_instantiate___tds__GetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33666 */
#ifndef SOAP_TYPE___tds__SetDynamicDNS
#define SOAP_TYPE___tds__SetDynamicDNS (1740)
/* Operation wrapper: */
struct __tds__SetDynamicDNS
{
public:
	_tds__SetDynamicDNS *tds__SetDynamicDNS;	/* optional element of XSD type tds:SetDynamicDNS */
public:
	int soap_type() const { return 1740; } /* = unique type id SOAP_TYPE___tds__SetDynamicDNS */
	         __tds__SetDynamicDNS();
	friend SOAP_FMAC1 __tds__SetDynamicDNS * SOAP_FMAC2 soap_instantiate___tds__SetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33737 */
#ifndef SOAP_TYPE___tds__GetNetworkInterfaces
#define SOAP_TYPE___tds__GetNetworkInterfaces (1744)
/* Operation wrapper: */
struct __tds__GetNetworkInterfaces
{
public:
	_tds__GetNetworkInterfaces *tds__GetNetworkInterfaces;	/* optional element of XSD type tds:GetNetworkInterfaces */
public:
	int soap_type() const { return 1744; } /* = unique type id SOAP_TYPE___tds__GetNetworkInterfaces */
	         __tds__GetNetworkInterfaces();
	friend SOAP_FMAC1 __tds__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate___tds__GetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33808 */
#ifndef SOAP_TYPE___tds__SetNetworkInterfaces
#define SOAP_TYPE___tds__SetNetworkInterfaces (1748)
/* Operation wrapper: */
struct __tds__SetNetworkInterfaces
{
public:
	_tds__SetNetworkInterfaces *tds__SetNetworkInterfaces;	/* optional element of XSD type tds:SetNetworkInterfaces */
public:
	int soap_type() const { return 1748; } /* = unique type id SOAP_TYPE___tds__SetNetworkInterfaces */
	         __tds__SetNetworkInterfaces();
	friend SOAP_FMAC1 __tds__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate___tds__SetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33878 */
#ifndef SOAP_TYPE___tds__GetNetworkProtocols
#define SOAP_TYPE___tds__GetNetworkProtocols (1752)
/* Operation wrapper: */
struct __tds__GetNetworkProtocols
{
public:
	_tds__GetNetworkProtocols *tds__GetNetworkProtocols;	/* optional element of XSD type tds:GetNetworkProtocols */
public:
	int soap_type() const { return 1752; } /* = unique type id SOAP_TYPE___tds__GetNetworkProtocols */
	         __tds__GetNetworkProtocols();
	friend SOAP_FMAC1 __tds__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate___tds__GetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33948 */
#ifndef SOAP_TYPE___tds__SetNetworkProtocols
#define SOAP_TYPE___tds__SetNetworkProtocols (1756)
/* Operation wrapper: */
struct __tds__SetNetworkProtocols
{
public:
	_tds__SetNetworkProtocols *tds__SetNetworkProtocols;	/* optional element of XSD type tds:SetNetworkProtocols */
public:
	int soap_type() const { return 1756; } /* = unique type id SOAP_TYPE___tds__SetNetworkProtocols */
	         __tds__SetNetworkProtocols();
	friend SOAP_FMAC1 __tds__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate___tds__SetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34018 */
#ifndef SOAP_TYPE___tds__GetNetworkDefaultGateway
#define SOAP_TYPE___tds__GetNetworkDefaultGateway (1760)
/* Operation wrapper: */
struct __tds__GetNetworkDefaultGateway
{
public:
	_tds__GetNetworkDefaultGateway *tds__GetNetworkDefaultGateway;	/* optional element of XSD type tds:GetNetworkDefaultGateway */
public:
	int soap_type() const { return 1760; } /* = unique type id SOAP_TYPE___tds__GetNetworkDefaultGateway */
	         __tds__GetNetworkDefaultGateway();
	friend SOAP_FMAC1 __tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate___tds__GetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34087 */
#ifndef SOAP_TYPE___tds__SetNetworkDefaultGateway
#define SOAP_TYPE___tds__SetNetworkDefaultGateway (1764)
/* Operation wrapper: */
struct __tds__SetNetworkDefaultGateway
{
public:
	_tds__SetNetworkDefaultGateway *tds__SetNetworkDefaultGateway;	/* optional element of XSD type tds:SetNetworkDefaultGateway */
public:
	int soap_type() const { return 1764; } /* = unique type id SOAP_TYPE___tds__SetNetworkDefaultGateway */
	         __tds__SetNetworkDefaultGateway();
	friend SOAP_FMAC1 __tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate___tds__SetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34159 */
#ifndef SOAP_TYPE___tds__GetZeroConfiguration
#define SOAP_TYPE___tds__GetZeroConfiguration (1768)
/* Operation wrapper: */
struct __tds__GetZeroConfiguration
{
public:
	_tds__GetZeroConfiguration *tds__GetZeroConfiguration;	/* optional element of XSD type tds:GetZeroConfiguration */
public:
	int soap_type() const { return 1768; } /* = unique type id SOAP_TYPE___tds__GetZeroConfiguration */
	         __tds__GetZeroConfiguration();
	friend SOAP_FMAC1 __tds__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34227 */
#ifndef SOAP_TYPE___tds__SetZeroConfiguration
#define SOAP_TYPE___tds__SetZeroConfiguration (1772)
/* Operation wrapper: */
struct __tds__SetZeroConfiguration
{
public:
	_tds__SetZeroConfiguration *tds__SetZeroConfiguration;	/* optional element of XSD type tds:SetZeroConfiguration */
public:
	int soap_type() const { return 1772; } /* = unique type id SOAP_TYPE___tds__SetZeroConfiguration */
	         __tds__SetZeroConfiguration();
	friend SOAP_FMAC1 __tds__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34298 */
#ifndef SOAP_TYPE___tds__GetIPAddressFilter
#define SOAP_TYPE___tds__GetIPAddressFilter (1776)
/* Operation wrapper: */
struct __tds__GetIPAddressFilter
{
public:
	_tds__GetIPAddressFilter *tds__GetIPAddressFilter;	/* optional element of XSD type tds:GetIPAddressFilter */
public:
	int soap_type() const { return 1776; } /* = unique type id SOAP_TYPE___tds__GetIPAddressFilter */
	         __tds__GetIPAddressFilter();
	friend SOAP_FMAC1 __tds__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__GetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34371 */
#ifndef SOAP_TYPE___tds__SetIPAddressFilter
#define SOAP_TYPE___tds__SetIPAddressFilter (1780)
/* Operation wrapper: */
struct __tds__SetIPAddressFilter
{
public:
	_tds__SetIPAddressFilter *tds__SetIPAddressFilter;	/* optional element of XSD type tds:SetIPAddressFilter */
public:
	int soap_type() const { return 1780; } /* = unique type id SOAP_TYPE___tds__SetIPAddressFilter */
	         __tds__SetIPAddressFilter();
	friend SOAP_FMAC1 __tds__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__SetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34443 */
#ifndef SOAP_TYPE___tds__AddIPAddressFilter
#define SOAP_TYPE___tds__AddIPAddressFilter (1784)
/* Operation wrapper: */
struct __tds__AddIPAddressFilter
{
public:
	_tds__AddIPAddressFilter *tds__AddIPAddressFilter;	/* optional element of XSD type tds:AddIPAddressFilter */
public:
	int soap_type() const { return 1784; } /* = unique type id SOAP_TYPE___tds__AddIPAddressFilter */
	         __tds__AddIPAddressFilter();
	friend SOAP_FMAC1 __tds__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__AddIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34515 */
#ifndef SOAP_TYPE___tds__RemoveIPAddressFilter
#define SOAP_TYPE___tds__RemoveIPAddressFilter (1788)
/* Operation wrapper: */
struct __tds__RemoveIPAddressFilter
{
public:
	_tds__RemoveIPAddressFilter *tds__RemoveIPAddressFilter;	/* optional element of XSD type tds:RemoveIPAddressFilter */
public:
	int soap_type() const { return 1788; } /* = unique type id SOAP_TYPE___tds__RemoveIPAddressFilter */
	         __tds__RemoveIPAddressFilter();
	friend SOAP_FMAC1 __tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__RemoveIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34596 */
#ifndef SOAP_TYPE___tds__GetAccessPolicy
#define SOAP_TYPE___tds__GetAccessPolicy (1792)
/* Operation wrapper: */
struct __tds__GetAccessPolicy
{
public:
	_tds__GetAccessPolicy *tds__GetAccessPolicy;	/* optional element of XSD type tds:GetAccessPolicy */
public:
	int soap_type() const { return 1792; } /* = unique type id SOAP_TYPE___tds__GetAccessPolicy */
	         __tds__GetAccessPolicy();
	friend SOAP_FMAC1 __tds__GetAccessPolicy * SOAP_FMAC2 soap_instantiate___tds__GetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34668 */
#ifndef SOAP_TYPE___tds__SetAccessPolicy
#define SOAP_TYPE___tds__SetAccessPolicy (1796)
/* Operation wrapper: */
struct __tds__SetAccessPolicy
{
public:
	_tds__SetAccessPolicy *tds__SetAccessPolicy;	/* optional element of XSD type tds:SetAccessPolicy */
public:
	int soap_type() const { return 1796; } /* = unique type id SOAP_TYPE___tds__SetAccessPolicy */
	         __tds__SetAccessPolicy();
	friend SOAP_FMAC1 __tds__SetAccessPolicy * SOAP_FMAC2 soap_instantiate___tds__SetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34739 */
#ifndef SOAP_TYPE___tds__CreateCertificate
#define SOAP_TYPE___tds__CreateCertificate (1800)
/* Operation wrapper: */
struct __tds__CreateCertificate
{
public:
	_tds__CreateCertificate *tds__CreateCertificate;	/* optional element of XSD type tds:CreateCertificate */
public:
	int soap_type() const { return 1800; } /* = unique type id SOAP_TYPE___tds__CreateCertificate */
	         __tds__CreateCertificate();
	friend SOAP_FMAC1 __tds__CreateCertificate * SOAP_FMAC2 soap_instantiate___tds__CreateCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34818 */
#ifndef SOAP_TYPE___tds__GetCertificates
#define SOAP_TYPE___tds__GetCertificates (1804)
/* Operation wrapper: */
struct __tds__GetCertificates
{
public:
	_tds__GetCertificates *tds__GetCertificates;	/* optional element of XSD type tds:GetCertificates */
public:
	int soap_type() const { return 1804; } /* = unique type id SOAP_TYPE___tds__GetCertificates */
	         __tds__GetCertificates();
	friend SOAP_FMAC1 __tds__GetCertificates * SOAP_FMAC2 soap_instantiate___tds__GetCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34888 */
#ifndef SOAP_TYPE___tds__GetCertificatesStatus
#define SOAP_TYPE___tds__GetCertificatesStatus (1808)
/* Operation wrapper: */
struct __tds__GetCertificatesStatus
{
public:
	_tds__GetCertificatesStatus *tds__GetCertificatesStatus;	/* optional element of XSD type tds:GetCertificatesStatus */
public:
	int soap_type() const { return 1808; } /* = unique type id SOAP_TYPE___tds__GetCertificatesStatus */
	         __tds__GetCertificatesStatus();
	friend SOAP_FMAC1 __tds__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate___tds__GetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34960 */
#ifndef SOAP_TYPE___tds__SetCertificatesStatus
#define SOAP_TYPE___tds__SetCertificatesStatus (1812)
/* Operation wrapper: */
struct __tds__SetCertificatesStatus
{
public:
	_tds__SetCertificatesStatus *tds__SetCertificatesStatus;	/* optional element of XSD type tds:SetCertificatesStatus */
public:
	int soap_type() const { return 1812; } /* = unique type id SOAP_TYPE___tds__SetCertificatesStatus */
	         __tds__SetCertificatesStatus();
	friend SOAP_FMAC1 __tds__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate___tds__SetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35035 */
#ifndef SOAP_TYPE___tds__DeleteCertificates
#define SOAP_TYPE___tds__DeleteCertificates (1816)
/* Operation wrapper: */
struct __tds__DeleteCertificates
{
public:
	_tds__DeleteCertificates *tds__DeleteCertificates;	/* optional element of XSD type tds:DeleteCertificates */
public:
	int soap_type() const { return 1816; } /* = unique type id SOAP_TYPE___tds__DeleteCertificates */
	         __tds__DeleteCertificates();
	friend SOAP_FMAC1 __tds__DeleteCertificates * SOAP_FMAC2 soap_instantiate___tds__DeleteCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35112 */
#ifndef SOAP_TYPE___tds__GetPkcs10Request
#define SOAP_TYPE___tds__GetPkcs10Request (1820)
/* Operation wrapper: */
struct __tds__GetPkcs10Request
{
public:
	_tds__GetPkcs10Request *tds__GetPkcs10Request;	/* optional element of XSD type tds:GetPkcs10Request */
public:
	int soap_type() const { return 1820; } /* = unique type id SOAP_TYPE___tds__GetPkcs10Request */
	         __tds__GetPkcs10Request();
	friend SOAP_FMAC1 __tds__GetPkcs10Request * SOAP_FMAC2 soap_instantiate___tds__GetPkcs10Request(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35193 */
#ifndef SOAP_TYPE___tds__LoadCertificates
#define SOAP_TYPE___tds__LoadCertificates (1824)
/* Operation wrapper: */
struct __tds__LoadCertificates
{
public:
	_tds__LoadCertificates *tds__LoadCertificates;	/* optional element of XSD type tds:LoadCertificates */
public:
	int soap_type() const { return 1824; } /* = unique type id SOAP_TYPE___tds__LoadCertificates */
	         __tds__LoadCertificates();
	friend SOAP_FMAC1 __tds__LoadCertificates * SOAP_FMAC2 soap_instantiate___tds__LoadCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35263 */
#ifndef SOAP_TYPE___tds__GetClientCertificateMode
#define SOAP_TYPE___tds__GetClientCertificateMode (1828)
/* Operation wrapper: */
struct __tds__GetClientCertificateMode
{
public:
	_tds__GetClientCertificateMode *tds__GetClientCertificateMode;	/* optional element of XSD type tds:GetClientCertificateMode */
public:
	int soap_type() const { return 1828; } /* = unique type id SOAP_TYPE___tds__GetClientCertificateMode */
	         __tds__GetClientCertificateMode();
	friend SOAP_FMAC1 __tds__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate___tds__GetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35333 */
#ifndef SOAP_TYPE___tds__SetClientCertificateMode
#define SOAP_TYPE___tds__SetClientCertificateMode (1832)
/* Operation wrapper: */
struct __tds__SetClientCertificateMode
{
public:
	_tds__SetClientCertificateMode *tds__SetClientCertificateMode;	/* optional element of XSD type tds:SetClientCertificateMode */
public:
	int soap_type() const { return 1832; } /* = unique type id SOAP_TYPE___tds__SetClientCertificateMode */
	         __tds__SetClientCertificateMode();
	friend SOAP_FMAC1 __tds__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate___tds__SetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35400 */
#ifndef SOAP_TYPE___tds__GetRelayOutputs
#define SOAP_TYPE___tds__GetRelayOutputs (1836)
/* Operation wrapper: */
struct __tds__GetRelayOutputs
{
public:
	_tds__GetRelayOutputs *tds__GetRelayOutputs;	/* optional element of XSD type tds:GetRelayOutputs */
public:
	int soap_type() const { return 1836; } /* = unique type id SOAP_TYPE___tds__GetRelayOutputs */
	         __tds__GetRelayOutputs();
	friend SOAP_FMAC1 __tds__GetRelayOutputs * SOAP_FMAC2 soap_instantiate___tds__GetRelayOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35468 */
#ifndef SOAP_TYPE___tds__SetRelayOutputSettings
#define SOAP_TYPE___tds__SetRelayOutputSettings (1840)
/* Operation wrapper: */
struct __tds__SetRelayOutputSettings
{
public:
	_tds__SetRelayOutputSettings *tds__SetRelayOutputSettings;	/* optional element of XSD type tds:SetRelayOutputSettings */
public:
	int soap_type() const { return 1840; } /* = unique type id SOAP_TYPE___tds__SetRelayOutputSettings */
	         __tds__SetRelayOutputSettings();
	friend SOAP_FMAC1 __tds__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate___tds__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35536 */
#ifndef SOAP_TYPE___tds__SetRelayOutputState
#define SOAP_TYPE___tds__SetRelayOutputState (1844)
/* Operation wrapper: */
struct __tds__SetRelayOutputState
{
public:
	_tds__SetRelayOutputState *tds__SetRelayOutputState;	/* optional element of XSD type tds:SetRelayOutputState */
public:
	int soap_type() const { return 1844; } /* = unique type id SOAP_TYPE___tds__SetRelayOutputState */
	         __tds__SetRelayOutputState();
	friend SOAP_FMAC1 __tds__SetRelayOutputState * SOAP_FMAC2 soap_instantiate___tds__SetRelayOutputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35606 */
#ifndef SOAP_TYPE___tds__SendAuxiliaryCommand
#define SOAP_TYPE___tds__SendAuxiliaryCommand (1848)
/* Operation wrapper: */
struct __tds__SendAuxiliaryCommand
{
public:
	_tds__SendAuxiliaryCommand *tds__SendAuxiliaryCommand;	/* optional element of XSD type tds:SendAuxiliaryCommand */
public:
	int soap_type() const { return 1848; } /* = unique type id SOAP_TYPE___tds__SendAuxiliaryCommand */
	         __tds__SendAuxiliaryCommand();
	friend SOAP_FMAC1 __tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate___tds__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35684 */
#ifndef SOAP_TYPE___tds__GetCACertificates
#define SOAP_TYPE___tds__GetCACertificates (1852)
/* Operation wrapper: */
struct __tds__GetCACertificates
{
public:
	_tds__GetCACertificates *tds__GetCACertificates;	/* optional element of XSD type tds:GetCACertificates */
public:
	int soap_type() const { return 1852; } /* = unique type id SOAP_TYPE___tds__GetCACertificates */
	         __tds__GetCACertificates();
	friend SOAP_FMAC1 __tds__GetCACertificates * SOAP_FMAC2 soap_instantiate___tds__GetCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35761 */
#ifndef SOAP_TYPE___tds__LoadCertificateWithPrivateKey
#define SOAP_TYPE___tds__LoadCertificateWithPrivateKey (1856)
/* Operation wrapper: */
struct __tds__LoadCertificateWithPrivateKey
{
public:
	_tds__LoadCertificateWithPrivateKey *tds__LoadCertificateWithPrivateKey;	/* optional element of XSD type tds:LoadCertificateWithPrivateKey */
public:
	int soap_type() const { return 1856; } /* = unique type id SOAP_TYPE___tds__LoadCertificateWithPrivateKey */
	         __tds__LoadCertificateWithPrivateKey();
	friend SOAP_FMAC1 __tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate___tds__LoadCertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35836 */
#ifndef SOAP_TYPE___tds__GetCertificateInformation
#define SOAP_TYPE___tds__GetCertificateInformation (1860)
/* Operation wrapper: */
struct __tds__GetCertificateInformation
{
public:
	_tds__GetCertificateInformation *tds__GetCertificateInformation;	/* optional element of XSD type tds:GetCertificateInformation */
public:
	int soap_type() const { return 1860; } /* = unique type id SOAP_TYPE___tds__GetCertificateInformation */
	         __tds__GetCertificateInformation();
	friend SOAP_FMAC1 __tds__GetCertificateInformation * SOAP_FMAC2 soap_instantiate___tds__GetCertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35908 */
#ifndef SOAP_TYPE___tds__LoadCACertificates
#define SOAP_TYPE___tds__LoadCACertificates (1864)
/* Operation wrapper: */
struct __tds__LoadCACertificates
{
public:
	_tds__LoadCACertificates *tds__LoadCACertificates;	/* optional element of XSD type tds:LoadCACertificates */
public:
	int soap_type() const { return 1864; } /* = unique type id SOAP_TYPE___tds__LoadCACertificates */
	         __tds__LoadCACertificates();
	friend SOAP_FMAC1 __tds__LoadCACertificates * SOAP_FMAC2 soap_instantiate___tds__LoadCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35983 */
#ifndef SOAP_TYPE___tds__CreateDot1XConfiguration
#define SOAP_TYPE___tds__CreateDot1XConfiguration (1868)
/* Operation wrapper: */
struct __tds__CreateDot1XConfiguration
{
public:
	_tds__CreateDot1XConfiguration *tds__CreateDot1XConfiguration;	/* optional element of XSD type tds:CreateDot1XConfiguration */
public:
	int soap_type() const { return 1868; } /* = unique type id SOAP_TYPE___tds__CreateDot1XConfiguration */
	         __tds__CreateDot1XConfiguration();
	friend SOAP_FMAC1 __tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__CreateDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36054 */
#ifndef SOAP_TYPE___tds__SetDot1XConfiguration
#define SOAP_TYPE___tds__SetDot1XConfiguration (1872)
/* Operation wrapper: */
struct __tds__SetDot1XConfiguration
{
public:
	_tds__SetDot1XConfiguration *tds__SetDot1XConfiguration;	/* optional element of XSD type tds:SetDot1XConfiguration */
public:
	int soap_type() const { return 1872; } /* = unique type id SOAP_TYPE___tds__SetDot1XConfiguration */
	         __tds__SetDot1XConfiguration();
	friend SOAP_FMAC1 __tds__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36123 */
#ifndef SOAP_TYPE___tds__GetDot1XConfiguration
#define SOAP_TYPE___tds__GetDot1XConfiguration (1876)
/* Operation wrapper: */
struct __tds__GetDot1XConfiguration
{
public:
	_tds__GetDot1XConfiguration *tds__GetDot1XConfiguration;	/* optional element of XSD type tds:GetDot1XConfiguration */
public:
	int soap_type() const { return 1876; } /* = unique type id SOAP_TYPE___tds__GetDot1XConfiguration */
	         __tds__GetDot1XConfiguration();
	friend SOAP_FMAC1 __tds__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36195 */
#ifndef SOAP_TYPE___tds__GetDot1XConfigurations
#define SOAP_TYPE___tds__GetDot1XConfigurations (1880)
/* Operation wrapper: */
struct __tds__GetDot1XConfigurations
{
public:
	_tds__GetDot1XConfigurations *tds__GetDot1XConfigurations;	/* optional element of XSD type tds:GetDot1XConfigurations */
public:
	int soap_type() const { return 1880; } /* = unique type id SOAP_TYPE___tds__GetDot1XConfigurations */
	         __tds__GetDot1XConfigurations();
	friend SOAP_FMAC1 __tds__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate___tds__GetDot1XConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36267 */
#ifndef SOAP_TYPE___tds__DeleteDot1XConfiguration
#define SOAP_TYPE___tds__DeleteDot1XConfiguration (1884)
/* Operation wrapper: */
struct __tds__DeleteDot1XConfiguration
{
public:
	_tds__DeleteDot1XConfiguration *tds__DeleteDot1XConfiguration;	/* optional element of XSD type tds:DeleteDot1XConfiguration */
public:
	int soap_type() const { return 1884; } /* = unique type id SOAP_TYPE___tds__DeleteDot1XConfiguration */
	         __tds__DeleteDot1XConfiguration();
	friend SOAP_FMAC1 __tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__DeleteDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36335 */
#ifndef SOAP_TYPE___tds__GetDot11Capabilities
#define SOAP_TYPE___tds__GetDot11Capabilities (1888)
/* Operation wrapper: */
struct __tds__GetDot11Capabilities
{
public:
	_tds__GetDot11Capabilities *tds__GetDot11Capabilities;	/* optional element of XSD type tds:GetDot11Capabilities */
public:
	int soap_type() const { return 1888; } /* = unique type id SOAP_TYPE___tds__GetDot11Capabilities */
	         __tds__GetDot11Capabilities();
	friend SOAP_FMAC1 __tds__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate___tds__GetDot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36404 */
#ifndef SOAP_TYPE___tds__GetDot11Status
#define SOAP_TYPE___tds__GetDot11Status (1892)
/* Operation wrapper: */
struct __tds__GetDot11Status
{
public:
	_tds__GetDot11Status *tds__GetDot11Status;	/* optional element of XSD type tds:GetDot11Status */
public:
	int soap_type() const { return 1892; } /* = unique type id SOAP_TYPE___tds__GetDot11Status */
	         __tds__GetDot11Status();
	friend SOAP_FMAC1 __tds__GetDot11Status * SOAP_FMAC2 soap_instantiate___tds__GetDot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36473 */
#ifndef SOAP_TYPE___tds__ScanAvailableDot11Networks
#define SOAP_TYPE___tds__ScanAvailableDot11Networks (1896)
/* Operation wrapper: */
struct __tds__ScanAvailableDot11Networks
{
public:
	_tds__ScanAvailableDot11Networks *tds__ScanAvailableDot11Networks;	/* optional element of XSD type tds:ScanAvailableDot11Networks */
public:
	int soap_type() const { return 1896; } /* = unique type id SOAP_TYPE___tds__ScanAvailableDot11Networks */
	         __tds__ScanAvailableDot11Networks();
	friend SOAP_FMAC1 __tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate___tds__ScanAvailableDot11Networks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36542 */
#ifndef SOAP_TYPE___tds__GetSystemUris
#define SOAP_TYPE___tds__GetSystemUris (1900)
/* Operation wrapper: */
struct __tds__GetSystemUris
{
public:
	_tds__GetSystemUris *tds__GetSystemUris;	/* optional element of XSD type tds:GetSystemUris */
public:
	int soap_type() const { return 1900; } /* = unique type id SOAP_TYPE___tds__GetSystemUris */
	         __tds__GetSystemUris();
	friend SOAP_FMAC1 __tds__GetSystemUris * SOAP_FMAC2 soap_instantiate___tds__GetSystemUris(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36619 */
#ifndef SOAP_TYPE___tds__StartFirmwareUpgrade
#define SOAP_TYPE___tds__StartFirmwareUpgrade (1904)
/* Operation wrapper: */
struct __tds__StartFirmwareUpgrade
{
public:
	_tds__StartFirmwareUpgrade *tds__StartFirmwareUpgrade;	/* optional element of XSD type tds:StartFirmwareUpgrade */
public:
	int soap_type() const { return 1904; } /* = unique type id SOAP_TYPE___tds__StartFirmwareUpgrade */
	         __tds__StartFirmwareUpgrade();
	friend SOAP_FMAC1 __tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate___tds__StartFirmwareUpgrade(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36696 */
#ifndef SOAP_TYPE___tds__StartSystemRestore
#define SOAP_TYPE___tds__StartSystemRestore (1908)
/* Operation wrapper: */
struct __tds__StartSystemRestore
{
public:
	_tds__StartSystemRestore *tds__StartSystemRestore;	/* optional element of XSD type tds:StartSystemRestore */
public:
	int soap_type() const { return 1908; } /* = unique type id SOAP_TYPE___tds__StartSystemRestore */
	         __tds__StartSystemRestore();
	friend SOAP_FMAC1 __tds__StartSystemRestore * SOAP_FMAC2 soap_instantiate___tds__StartSystemRestore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36766 */
#ifndef SOAP_TYPE___tds__GetStorageConfigurations
#define SOAP_TYPE___tds__GetStorageConfigurations (1912)
/* Operation wrapper: */
struct __tds__GetStorageConfigurations
{
public:
	_tds__GetStorageConfigurations *tds__GetStorageConfigurations;	/* optional element of XSD type tds:GetStorageConfigurations */
public:
	int soap_type() const { return 1912; } /* = unique type id SOAP_TYPE___tds__GetStorageConfigurations */
	         __tds__GetStorageConfigurations();
	friend SOAP_FMAC1 __tds__GetStorageConfigurations * SOAP_FMAC2 soap_instantiate___tds__GetStorageConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36837 */
#ifndef SOAP_TYPE___tds__CreateStorageConfiguration
#define SOAP_TYPE___tds__CreateStorageConfiguration (1916)
/* Operation wrapper: */
struct __tds__CreateStorageConfiguration
{
public:
	_tds__CreateStorageConfiguration *tds__CreateStorageConfiguration;	/* optional element of XSD type tds:CreateStorageConfiguration */
public:
	int soap_type() const { return 1916; } /* = unique type id SOAP_TYPE___tds__CreateStorageConfiguration */
	         __tds__CreateStorageConfiguration();
	friend SOAP_FMAC1 __tds__CreateStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__CreateStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36907 */
#ifndef SOAP_TYPE___tds__GetStorageConfiguration
#define SOAP_TYPE___tds__GetStorageConfiguration (1920)
/* Operation wrapper: */
struct __tds__GetStorageConfiguration
{
public:
	_tds__GetStorageConfiguration *tds__GetStorageConfiguration;	/* optional element of XSD type tds:GetStorageConfiguration */
public:
	int soap_type() const { return 1920; } /* = unique type id SOAP_TYPE___tds__GetStorageConfiguration */
	         __tds__GetStorageConfiguration();
	friend SOAP_FMAC1 __tds__GetStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36976 */
#ifndef SOAP_TYPE___tds__SetStorageConfiguration
#define SOAP_TYPE___tds__SetStorageConfiguration (1924)
/* Operation wrapper: */
struct __tds__SetStorageConfiguration
{
public:
	_tds__SetStorageConfiguration *tds__SetStorageConfiguration;	/* optional element of XSD type tds:SetStorageConfiguration */
public:
	int soap_type() const { return 1924; } /* = unique type id SOAP_TYPE___tds__SetStorageConfiguration */
	         __tds__SetStorageConfiguration();
	friend SOAP_FMAC1 __tds__SetStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37046 */
#ifndef SOAP_TYPE___tds__DeleteStorageConfiguration
#define SOAP_TYPE___tds__DeleteStorageConfiguration (1928)
/* Operation wrapper: */
struct __tds__DeleteStorageConfiguration
{
public:
	_tds__DeleteStorageConfiguration *tds__DeleteStorageConfiguration;	/* optional element of XSD type tds:DeleteStorageConfiguration */
public:
	int soap_type() const { return 1928; } /* = unique type id SOAP_TYPE___tds__DeleteStorageConfiguration */
	         __tds__DeleteStorageConfiguration();
	friend SOAP_FMAC1 __tds__DeleteStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__DeleteStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37116 */
#ifndef SOAP_TYPE___tds__GetGeoLocation
#define SOAP_TYPE___tds__GetGeoLocation (1932)
/* Operation wrapper: */
struct __tds__GetGeoLocation
{
public:
	_tds__GetGeoLocation *tds__GetGeoLocation;	/* optional element of XSD type tds:GetGeoLocation */
public:
	int soap_type() const { return 1932; } /* = unique type id SOAP_TYPE___tds__GetGeoLocation */
	         __tds__GetGeoLocation();
	friend SOAP_FMAC1 __tds__GetGeoLocation * SOAP_FMAC2 soap_instantiate___tds__GetGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37186 */
#ifndef SOAP_TYPE___tds__SetGeoLocation
#define SOAP_TYPE___tds__SetGeoLocation (1936)
/* Operation wrapper: */
struct __tds__SetGeoLocation
{
public:
	_tds__SetGeoLocation *tds__SetGeoLocation;	/* optional element of XSD type tds:SetGeoLocation */
public:
	int soap_type() const { return 1936; } /* = unique type id SOAP_TYPE___tds__SetGeoLocation */
	         __tds__SetGeoLocation();
	friend SOAP_FMAC1 __tds__SetGeoLocation * SOAP_FMAC2 soap_instantiate___tds__SetGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37255 */
#ifndef SOAP_TYPE___tds__DeleteGeoLocation
#define SOAP_TYPE___tds__DeleteGeoLocation (1940)
/* Operation wrapper: */
struct __tds__DeleteGeoLocation
{
public:
	_tds__DeleteGeoLocation *tds__DeleteGeoLocation;	/* optional element of XSD type tds:DeleteGeoLocation */
public:
	int soap_type() const { return 1940; } /* = unique type id SOAP_TYPE___tds__DeleteGeoLocation */
	         __tds__DeleteGeoLocation();
	friend SOAP_FMAC1 __tds__DeleteGeoLocation * SOAP_FMAC2 soap_instantiate___tds__DeleteGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37341 */
#ifndef SOAP_TYPE___tls__GetServiceCapabilities
#define SOAP_TYPE___tls__GetServiceCapabilities (1944)
/* Operation wrapper: */
struct __tls__GetServiceCapabilities
{
public:
	_tls__GetServiceCapabilities *tls__GetServiceCapabilities;	/* optional element of XSD type tls:GetServiceCapabilities */
public:
	int soap_type() const { return 1944; } /* = unique type id SOAP_TYPE___tls__GetServiceCapabilities */
	         __tls__GetServiceCapabilities();
	friend SOAP_FMAC1 __tls__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tls__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37412 */
#ifndef SOAP_TYPE___tls__GetLayout
#define SOAP_TYPE___tls__GetLayout (1948)
/* Operation wrapper: */
struct __tls__GetLayout
{
public:
	_tls__GetLayout *tls__GetLayout;	/* optional element of XSD type tls:GetLayout */
public:
	int soap_type() const { return 1948; } /* = unique type id SOAP_TYPE___tls__GetLayout */
	         __tls__GetLayout();
	friend SOAP_FMAC1 __tls__GetLayout * SOAP_FMAC2 soap_instantiate___tls__GetLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37484 */
#ifndef SOAP_TYPE___tls__SetLayout
#define SOAP_TYPE___tls__SetLayout (1952)
/* Operation wrapper: */
struct __tls__SetLayout
{
public:
	_tls__SetLayout *tls__SetLayout;	/* optional element of XSD type tls:SetLayout */
public:
	int soap_type() const { return 1952; } /* = unique type id SOAP_TYPE___tls__SetLayout */
	         __tls__SetLayout();
	friend SOAP_FMAC1 __tls__SetLayout * SOAP_FMAC2 soap_instantiate___tls__SetLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37555 */
#ifndef SOAP_TYPE___tls__GetDisplayOptions
#define SOAP_TYPE___tls__GetDisplayOptions (1956)
/* Operation wrapper: */
struct __tls__GetDisplayOptions
{
public:
	_tls__GetDisplayOptions *tls__GetDisplayOptions;	/* optional element of XSD type tls:GetDisplayOptions */
public:
	int soap_type() const { return 1956; } /* = unique type id SOAP_TYPE___tls__GetDisplayOptions */
	         __tls__GetDisplayOptions();
	friend SOAP_FMAC1 __tls__GetDisplayOptions * SOAP_FMAC2 soap_instantiate___tls__GetDisplayOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37630 */
#ifndef SOAP_TYPE___tls__GetPaneConfigurations
#define SOAP_TYPE___tls__GetPaneConfigurations (1960)
/* Operation wrapper: */
struct __tls__GetPaneConfigurations
{
public:
	_tls__GetPaneConfigurations *tls__GetPaneConfigurations;	/* optional element of XSD type tls:GetPaneConfigurations */
public:
	int soap_type() const { return 1960; } /* = unique type id SOAP_TYPE___tls__GetPaneConfigurations */
	         __tls__GetPaneConfigurations();
	friend SOAP_FMAC1 __tls__GetPaneConfigurations * SOAP_FMAC2 soap_instantiate___tls__GetPaneConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37697 */
#ifndef SOAP_TYPE___tls__GetPaneConfiguration
#define SOAP_TYPE___tls__GetPaneConfiguration (1964)
/* Operation wrapper: */
struct __tls__GetPaneConfiguration
{
public:
	_tls__GetPaneConfiguration *tls__GetPaneConfiguration;	/* optional element of XSD type tls:GetPaneConfiguration */
public:
	int soap_type() const { return 1964; } /* = unique type id SOAP_TYPE___tls__GetPaneConfiguration */
	         __tls__GetPaneConfiguration();
	friend SOAP_FMAC1 __tls__GetPaneConfiguration * SOAP_FMAC2 soap_instantiate___tls__GetPaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37767 */
#ifndef SOAP_TYPE___tls__SetPaneConfigurations
#define SOAP_TYPE___tls__SetPaneConfigurations (1968)
/* Operation wrapper: */
struct __tls__SetPaneConfigurations
{
public:
	_tls__SetPaneConfigurations *tls__SetPaneConfigurations;	/* optional element of XSD type tls:SetPaneConfigurations */
public:
	int soap_type() const { return 1968; } /* = unique type id SOAP_TYPE___tls__SetPaneConfigurations */
	         __tls__SetPaneConfigurations();
	friend SOAP_FMAC1 __tls__SetPaneConfigurations * SOAP_FMAC2 soap_instantiate___tls__SetPaneConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37834 */
#ifndef SOAP_TYPE___tls__SetPaneConfiguration
#define SOAP_TYPE___tls__SetPaneConfiguration (1972)
/* Operation wrapper: */
struct __tls__SetPaneConfiguration
{
public:
	_tls__SetPaneConfiguration *tls__SetPaneConfiguration;	/* optional element of XSD type tls:SetPaneConfiguration */
public:
	int soap_type() const { return 1972; } /* = unique type id SOAP_TYPE___tls__SetPaneConfiguration */
	         __tls__SetPaneConfiguration();
	friend SOAP_FMAC1 __tls__SetPaneConfiguration * SOAP_FMAC2 soap_instantiate___tls__SetPaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37902 */
#ifndef SOAP_TYPE___tls__CreatePaneConfiguration
#define SOAP_TYPE___tls__CreatePaneConfiguration (1976)
/* Operation wrapper: */
struct __tls__CreatePaneConfiguration
{
public:
	_tls__CreatePaneConfiguration *tls__CreatePaneConfiguration;	/* optional element of XSD type tls:CreatePaneConfiguration */
public:
	int soap_type() const { return 1976; } /* = unique type id SOAP_TYPE___tls__CreatePaneConfiguration */
	         __tls__CreatePaneConfiguration();
	friend SOAP_FMAC1 __tls__CreatePaneConfiguration * SOAP_FMAC2 soap_instantiate___tls__CreatePaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37970 */
#ifndef SOAP_TYPE___tls__DeletePaneConfiguration
#define SOAP_TYPE___tls__DeletePaneConfiguration (1980)
/* Operation wrapper: */
struct __tls__DeletePaneConfiguration
{
public:
	_tls__DeletePaneConfiguration *tls__DeletePaneConfiguration;	/* optional element of XSD type tls:DeletePaneConfiguration */
public:
	int soap_type() const { return 1980; } /* = unique type id SOAP_TYPE___tls__DeletePaneConfiguration */
	         __tls__DeletePaneConfiguration();
	friend SOAP_FMAC1 __tls__DeletePaneConfiguration * SOAP_FMAC2 soap_instantiate___tls__DeletePaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38056 */
#ifndef SOAP_TYPE___tmd__GetServiceCapabilities
#define SOAP_TYPE___tmd__GetServiceCapabilities (1984)
/* Operation wrapper: */
struct __tmd__GetServiceCapabilities
{
public:
	_tmd__GetServiceCapabilities *tmd__GetServiceCapabilities;	/* optional element of XSD type tmd:GetServiceCapabilities */
public:
	int soap_type() const { return 1984; } /* = unique type id SOAP_TYPE___tmd__GetServiceCapabilities */
	         __tmd__GetServiceCapabilities();
	friend SOAP_FMAC1 __tmd__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tmd__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38124 */
#ifndef SOAP_TYPE___tmd__GetRelayOutputOptions
#define SOAP_TYPE___tmd__GetRelayOutputOptions (1988)
/* Operation wrapper: */
struct __tmd__GetRelayOutputOptions
{
public:
	_tmd__GetRelayOutputOptions *tmd__GetRelayOutputOptions;	/* optional element of XSD type tmd:GetRelayOutputOptions */
public:
	int soap_type() const { return 1988; } /* = unique type id SOAP_TYPE___tmd__GetRelayOutputOptions */
	         __tmd__GetRelayOutputOptions();
	friend SOAP_FMAC1 __tmd__GetRelayOutputOptions * SOAP_FMAC2 soap_instantiate___tmd__GetRelayOutputOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38193 */
#ifndef SOAP_TYPE___tmd__GetAudioSources
#define SOAP_TYPE___tmd__GetAudioSources (1992)
/* Operation wrapper: */
struct __tmd__GetAudioSources
{
public:
	tmd__Get *tmd__GetAudioSources;	/* optional element of XSD type tmd:Get */
public:
	int soap_type() const { return 1992; } /* = unique type id SOAP_TYPE___tmd__GetAudioSources */
	         __tmd__GetAudioSources();
	friend SOAP_FMAC1 __tmd__GetAudioSources * SOAP_FMAC2 soap_instantiate___tmd__GetAudioSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38262 */
#ifndef SOAP_TYPE___tmd__GetAudioOutputs
#define SOAP_TYPE___tmd__GetAudioOutputs (1994)
/* Operation wrapper: */
struct __tmd__GetAudioOutputs
{
public:
	tmd__Get *tmd__GetAudioOutputs;	/* optional element of XSD type tmd:Get */
public:
	int soap_type() const { return 1994; } /* = unique type id SOAP_TYPE___tmd__GetAudioOutputs */
	         __tmd__GetAudioOutputs();
	friend SOAP_FMAC1 __tmd__GetAudioOutputs * SOAP_FMAC2 soap_instantiate___tmd__GetAudioOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38331 */
#ifndef SOAP_TYPE___tmd__GetVideoSources
#define SOAP_TYPE___tmd__GetVideoSources (1996)
/* Operation wrapper: */
struct __tmd__GetVideoSources
{
public:
	tmd__Get *tmd__GetVideoSources;	/* optional element of XSD type tmd:Get */
public:
	int soap_type() const { return 1996; } /* = unique type id SOAP_TYPE___tmd__GetVideoSources */
	         __tmd__GetVideoSources();
	friend SOAP_FMAC1 __tmd__GetVideoSources * SOAP_FMAC2 soap_instantiate___tmd__GetVideoSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38400 */
#ifndef SOAP_TYPE___tmd__GetVideoOutputs
#define SOAP_TYPE___tmd__GetVideoOutputs (2000)
/* Operation wrapper: */
struct __tmd__GetVideoOutputs
{
public:
	_tmd__GetVideoOutputs *tmd__GetVideoOutputs;	/* optional element of XSD type tmd:GetVideoOutputs */
public:
	int soap_type() const { return 2000; } /* = unique type id SOAP_TYPE___tmd__GetVideoOutputs */
	         __tmd__GetVideoOutputs();
	friend SOAP_FMAC1 __tmd__GetVideoOutputs * SOAP_FMAC2 soap_instantiate___tmd__GetVideoOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38468 */
#ifndef SOAP_TYPE___tmd__GetVideoSourceConfiguration
#define SOAP_TYPE___tmd__GetVideoSourceConfiguration (2004)
/* Operation wrapper: */
struct __tmd__GetVideoSourceConfiguration
{
public:
	_tmd__GetVideoSourceConfiguration *tmd__GetVideoSourceConfiguration;	/* optional element of XSD type tmd:GetVideoSourceConfiguration */
public:
	int soap_type() const { return 2004; } /* = unique type id SOAP_TYPE___tmd__GetVideoSourceConfiguration */
	         __tmd__GetVideoSourceConfiguration();
	friend SOAP_FMAC1 __tmd__GetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___tmd__GetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38536 */
#ifndef SOAP_TYPE___tmd__GetVideoOutputConfiguration
#define SOAP_TYPE___tmd__GetVideoOutputConfiguration (2008)
/* Operation wrapper: */
struct __tmd__GetVideoOutputConfiguration
{
public:
	_tmd__GetVideoOutputConfiguration *tmd__GetVideoOutputConfiguration;	/* optional element of XSD type tmd:GetVideoOutputConfiguration */
public:
	int soap_type() const { return 2008; } /* = unique type id SOAP_TYPE___tmd__GetVideoOutputConfiguration */
	         __tmd__GetVideoOutputConfiguration();
	friend SOAP_FMAC1 __tmd__GetVideoOutputConfiguration * SOAP_FMAC2 soap_instantiate___tmd__GetVideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38604 */
#ifndef SOAP_TYPE___tmd__GetAudioSourceConfiguration
#define SOAP_TYPE___tmd__GetAudioSourceConfiguration (2012)
/* Operation wrapper: */
struct __tmd__GetAudioSourceConfiguration
{
public:
	_tmd__GetAudioSourceConfiguration *tmd__GetAudioSourceConfiguration;	/* optional element of XSD type tmd:GetAudioSourceConfiguration */
public:
	int soap_type() const { return 2012; } /* = unique type id SOAP_TYPE___tmd__GetAudioSourceConfiguration */
	         __tmd__GetAudioSourceConfiguration();
	friend SOAP_FMAC1 __tmd__GetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___tmd__GetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38673 */
#ifndef SOAP_TYPE___tmd__GetAudioOutputConfiguration
#define SOAP_TYPE___tmd__GetAudioOutputConfiguration (2016)
/* Operation wrapper: */
struct __tmd__GetAudioOutputConfiguration
{
public:
	_tmd__GetAudioOutputConfiguration *tmd__GetAudioOutputConfiguration;	/* optional element of XSD type tmd:GetAudioOutputConfiguration */
public:
	int soap_type() const { return 2016; } /* = unique type id SOAP_TYPE___tmd__GetAudioOutputConfiguration */
	         __tmd__GetAudioOutputConfiguration();
	friend SOAP_FMAC1 __tmd__GetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___tmd__GetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38741 */
#ifndef SOAP_TYPE___tmd__SetVideoSourceConfiguration
#define SOAP_TYPE___tmd__SetVideoSourceConfiguration (2020)
/* Operation wrapper: */
struct __tmd__SetVideoSourceConfiguration
{
public:
	_tmd__SetVideoSourceConfiguration *tmd__SetVideoSourceConfiguration;	/* optional element of XSD type tmd:SetVideoSourceConfiguration */
public:
	int soap_type() const { return 2020; } /* = unique type id SOAP_TYPE___tmd__SetVideoSourceConfiguration */
	         __tmd__SetVideoSourceConfiguration();
	friend SOAP_FMAC1 __tmd__SetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___tmd__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38809 */
#ifndef SOAP_TYPE___tmd__SetVideoOutputConfiguration
#define SOAP_TYPE___tmd__SetVideoOutputConfiguration (2024)
/* Operation wrapper: */
struct __tmd__SetVideoOutputConfiguration
{
public:
	_tmd__SetVideoOutputConfiguration *tmd__SetVideoOutputConfiguration;	/* optional element of XSD type tmd:SetVideoOutputConfiguration */
public:
	int soap_type() const { return 2024; } /* = unique type id SOAP_TYPE___tmd__SetVideoOutputConfiguration */
	         __tmd__SetVideoOutputConfiguration();
	friend SOAP_FMAC1 __tmd__SetVideoOutputConfiguration * SOAP_FMAC2 soap_instantiate___tmd__SetVideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38877 */
#ifndef SOAP_TYPE___tmd__SetAudioSourceConfiguration
#define SOAP_TYPE___tmd__SetAudioSourceConfiguration (2028)
/* Operation wrapper: */
struct __tmd__SetAudioSourceConfiguration
{
public:
	_tmd__SetAudioSourceConfiguration *tmd__SetAudioSourceConfiguration;	/* optional element of XSD type tmd:SetAudioSourceConfiguration */
public:
	int soap_type() const { return 2028; } /* = unique type id SOAP_TYPE___tmd__SetAudioSourceConfiguration */
	         __tmd__SetAudioSourceConfiguration();
	friend SOAP_FMAC1 __tmd__SetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___tmd__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38945 */
#ifndef SOAP_TYPE___tmd__SetAudioOutputConfiguration
#define SOAP_TYPE___tmd__SetAudioOutputConfiguration (2032)
/* Operation wrapper: */
struct __tmd__SetAudioOutputConfiguration
{
public:
	_tmd__SetAudioOutputConfiguration *tmd__SetAudioOutputConfiguration;	/* optional element of XSD type tmd:SetAudioOutputConfiguration */
public:
	int soap_type() const { return 2032; } /* = unique type id SOAP_TYPE___tmd__SetAudioOutputConfiguration */
	         __tmd__SetAudioOutputConfiguration();
	friend SOAP_FMAC1 __tmd__SetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___tmd__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39013 */
#ifndef SOAP_TYPE___tmd__GetVideoSourceConfigurationOptions
#define SOAP_TYPE___tmd__GetVideoSourceConfigurationOptions (2036)
/* Operation wrapper: */
struct __tmd__GetVideoSourceConfigurationOptions
{
public:
	_tmd__GetVideoSourceConfigurationOptions *tmd__GetVideoSourceConfigurationOptions;	/* optional element of XSD type tmd:GetVideoSourceConfigurationOptions */
public:
	int soap_type() const { return 2036; } /* = unique type id SOAP_TYPE___tmd__GetVideoSourceConfigurationOptions */
	         __tmd__GetVideoSourceConfigurationOptions();
	friend SOAP_FMAC1 __tmd__GetVideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___tmd__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39082 */
#ifndef SOAP_TYPE___tmd__GetVideoOutputConfigurationOptions
#define SOAP_TYPE___tmd__GetVideoOutputConfigurationOptions (2040)
/* Operation wrapper: */
struct __tmd__GetVideoOutputConfigurationOptions
{
public:
	_tmd__GetVideoOutputConfigurationOptions *tmd__GetVideoOutputConfigurationOptions;	/* optional element of XSD type tmd:GetVideoOutputConfigurationOptions */
public:
	int soap_type() const { return 2040; } /* = unique type id SOAP_TYPE___tmd__GetVideoOutputConfigurationOptions */
	         __tmd__GetVideoOutputConfigurationOptions();
	friend SOAP_FMAC1 __tmd__GetVideoOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate___tmd__GetVideoOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39150 */
#ifndef SOAP_TYPE___tmd__GetAudioSourceConfigurationOptions
#define SOAP_TYPE___tmd__GetAudioSourceConfigurationOptions (2044)
/* Operation wrapper: */
struct __tmd__GetAudioSourceConfigurationOptions
{
public:
	_tmd__GetAudioSourceConfigurationOptions *tmd__GetAudioSourceConfigurationOptions;	/* optional element of XSD type tmd:GetAudioSourceConfigurationOptions */
public:
	int soap_type() const { return 2044; } /* = unique type id SOAP_TYPE___tmd__GetAudioSourceConfigurationOptions */
	         __tmd__GetAudioSourceConfigurationOptions();
	friend SOAP_FMAC1 __tmd__GetAudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___tmd__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39218 */
#ifndef SOAP_TYPE___tmd__GetAudioOutputConfigurationOptions
#define SOAP_TYPE___tmd__GetAudioOutputConfigurationOptions (2048)
/* Operation wrapper: */
struct __tmd__GetAudioOutputConfigurationOptions
{
public:
	_tmd__GetAudioOutputConfigurationOptions *tmd__GetAudioOutputConfigurationOptions;	/* optional element of XSD type tmd:GetAudioOutputConfigurationOptions */
public:
	int soap_type() const { return 2048; } /* = unique type id SOAP_TYPE___tmd__GetAudioOutputConfigurationOptions */
	         __tmd__GetAudioOutputConfigurationOptions();
	friend SOAP_FMAC1 __tmd__GetAudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate___tmd__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39285 */
#ifndef SOAP_TYPE___tmd__GetRelayOutputs
#define SOAP_TYPE___tmd__GetRelayOutputs (2050)
/* Operation wrapper: */
struct __tmd__GetRelayOutputs
{
public:
	_tds__GetRelayOutputs *tds__GetRelayOutputs;	/* optional element of XSD type tds:GetRelayOutputs */
public:
	int soap_type() const { return 2050; } /* = unique type id SOAP_TYPE___tmd__GetRelayOutputs */
	         __tmd__GetRelayOutputs();
	friend SOAP_FMAC1 __tmd__GetRelayOutputs * SOAP_FMAC2 soap_instantiate___tmd__GetRelayOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39353 */
#ifndef SOAP_TYPE___tmd__SetRelayOutputSettings
#define SOAP_TYPE___tmd__SetRelayOutputSettings (2054)
/* Operation wrapper: */
struct __tmd__SetRelayOutputSettings
{
public:
	_tmd__SetRelayOutputSettings *tmd__SetRelayOutputSettings;	/* optional element of XSD type tmd:SetRelayOutputSettings */
public:
	int soap_type() const { return 2054; } /* = unique type id SOAP_TYPE___tmd__SetRelayOutputSettings */
	         __tmd__SetRelayOutputSettings();
	friend SOAP_FMAC1 __tmd__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate___tmd__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39420 */
#ifndef SOAP_TYPE___tmd__SetRelayOutputState
#define SOAP_TYPE___tmd__SetRelayOutputState (2056)
/* Operation wrapper: */
struct __tmd__SetRelayOutputState
{
public:
	_tds__SetRelayOutputState *tds__SetRelayOutputState;	/* optional element of XSD type tds:SetRelayOutputState */
public:
	int soap_type() const { return 2056; } /* = unique type id SOAP_TYPE___tmd__SetRelayOutputState */
	         __tmd__SetRelayOutputState();
	friend SOAP_FMAC1 __tmd__SetRelayOutputState * SOAP_FMAC2 soap_instantiate___tmd__SetRelayOutputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39487 */
#ifndef SOAP_TYPE___tmd__GetDigitalInputs
#define SOAP_TYPE___tmd__GetDigitalInputs (2060)
/* Operation wrapper: */
struct __tmd__GetDigitalInputs
{
public:
	_tmd__GetDigitalInputs *tmd__GetDigitalInputs;	/* optional element of XSD type tmd:GetDigitalInputs */
public:
	int soap_type() const { return 2060; } /* = unique type id SOAP_TYPE___tmd__GetDigitalInputs */
	         __tmd__GetDigitalInputs();
	friend SOAP_FMAC1 __tmd__GetDigitalInputs * SOAP_FMAC2 soap_instantiate___tmd__GetDigitalInputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39554 */
#ifndef SOAP_TYPE___tmd__GetDigitalInputConfigurationOptions
#define SOAP_TYPE___tmd__GetDigitalInputConfigurationOptions (2064)
/* Operation wrapper: */
struct __tmd__GetDigitalInputConfigurationOptions
{
public:
	_tmd__GetDigitalInputConfigurationOptions *tmd__GetDigitalInputConfigurationOptions;	/* optional element of XSD type tmd:GetDigitalInputConfigurationOptions */
public:
	int soap_type() const { return 2064; } /* = unique type id SOAP_TYPE___tmd__GetDigitalInputConfigurationOptions */
	         __tmd__GetDigitalInputConfigurationOptions();
	friend SOAP_FMAC1 __tmd__GetDigitalInputConfigurationOptions * SOAP_FMAC2 soap_instantiate___tmd__GetDigitalInputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39621 */
#ifndef SOAP_TYPE___tmd__SetDigitalInputConfigurations
#define SOAP_TYPE___tmd__SetDigitalInputConfigurations (2068)
/* Operation wrapper: */
struct __tmd__SetDigitalInputConfigurations
{
public:
	_tmd__SetDigitalInputConfigurations *tmd__SetDigitalInputConfigurations;	/* optional element of XSD type tmd:SetDigitalInputConfigurations */
public:
	int soap_type() const { return 2068; } /* = unique type id SOAP_TYPE___tmd__SetDigitalInputConfigurations */
	         __tmd__SetDigitalInputConfigurations();
	friend SOAP_FMAC1 __tmd__SetDigitalInputConfigurations * SOAP_FMAC2 soap_instantiate___tmd__SetDigitalInputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39687 */
#ifndef SOAP_TYPE___tmd__GetSerialPorts
#define SOAP_TYPE___tmd__GetSerialPorts (2072)
/* Operation wrapper: */
struct __tmd__GetSerialPorts
{
public:
	_tmd__GetSerialPorts *tmd__GetSerialPorts;	/* optional element of XSD type tmd:GetSerialPorts */
public:
	int soap_type() const { return 2072; } /* = unique type id SOAP_TYPE___tmd__GetSerialPorts */
	         __tmd__GetSerialPorts();
	friend SOAP_FMAC1 __tmd__GetSerialPorts * SOAP_FMAC2 soap_instantiate___tmd__GetSerialPorts(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39753 */
#ifndef SOAP_TYPE___tmd__GetSerialPortConfiguration
#define SOAP_TYPE___tmd__GetSerialPortConfiguration (2076)
/* Operation wrapper: */
struct __tmd__GetSerialPortConfiguration
{
public:
	_tmd__GetSerialPortConfiguration *tmd__GetSerialPortConfiguration;	/* optional element of XSD type tmd:GetSerialPortConfiguration */
public:
	int soap_type() const { return 2076; } /* = unique type id SOAP_TYPE___tmd__GetSerialPortConfiguration */
	         __tmd__GetSerialPortConfiguration();
	friend SOAP_FMAC1 __tmd__GetSerialPortConfiguration * SOAP_FMAC2 soap_instantiate___tmd__GetSerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39819 */
#ifndef SOAP_TYPE___tmd__SetSerialPortConfiguration
#define SOAP_TYPE___tmd__SetSerialPortConfiguration (2080)
/* Operation wrapper: */
struct __tmd__SetSerialPortConfiguration
{
public:
	_tmd__SetSerialPortConfiguration *tmd__SetSerialPortConfiguration;	/* optional element of XSD type tmd:SetSerialPortConfiguration */
public:
	int soap_type() const { return 2080; } /* = unique type id SOAP_TYPE___tmd__SetSerialPortConfiguration */
	         __tmd__SetSerialPortConfiguration();
	friend SOAP_FMAC1 __tmd__SetSerialPortConfiguration * SOAP_FMAC2 soap_instantiate___tmd__SetSerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39885 */
#ifndef SOAP_TYPE___tmd__GetSerialPortConfigurationOptions
#define SOAP_TYPE___tmd__GetSerialPortConfigurationOptions (2084)
/* Operation wrapper: */
struct __tmd__GetSerialPortConfigurationOptions
{
public:
	_tmd__GetSerialPortConfigurationOptions *tmd__GetSerialPortConfigurationOptions;	/* optional element of XSD type tmd:GetSerialPortConfigurationOptions */
public:
	int soap_type() const { return 2084; } /* = unique type id SOAP_TYPE___tmd__GetSerialPortConfigurationOptions */
	         __tmd__GetSerialPortConfigurationOptions();
	friend SOAP_FMAC1 __tmd__GetSerialPortConfigurationOptions * SOAP_FMAC2 soap_instantiate___tmd__GetSerialPortConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39951 */
#ifndef SOAP_TYPE___tmd__SendReceiveSerialCommand
#define SOAP_TYPE___tmd__SendReceiveSerialCommand (2088)
/* Operation wrapper: */
struct __tmd__SendReceiveSerialCommand
{
public:
	_tmd__SendReceiveSerialCommand *tmd__SendReceiveSerialCommand;	/* optional element of XSD type tmd:SendReceiveSerialCommand */
public:
	int soap_type() const { return 2088; } /* = unique type id SOAP_TYPE___tmd__SendReceiveSerialCommand */
	         __tmd__SendReceiveSerialCommand();
	friend SOAP_FMAC1 __tmd__SendReceiveSerialCommand * SOAP_FMAC2 soap_instantiate___tmd__SendReceiveSerialCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* onvif.h:101 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* onvif.h:101 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* wsa5.h:87 */
#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (20)
typedef char *wsa5__RelationshipTypeOpenEnum;
#endif

/* wsa5.h:90 */
#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (21)
typedef char *wsa5__FaultCodesOpenEnumType;
#endif

/* wsa5.h:209 */
#ifndef SOAP_TYPE__wsa5__EndpointReference
#define SOAP_TYPE__wsa5__EndpointReference (28)
typedef struct wsa5__EndpointReferenceType _wsa5__EndpointReference;
#endif

/* wsa5.h:212 */
#ifndef SOAP_TYPE__wsa5__ReferenceParameters
#define SOAP_TYPE__wsa5__ReferenceParameters (29)
typedef struct wsa5__ReferenceParametersType _wsa5__ReferenceParameters;
#endif

/* wsa5.h:215 */
#ifndef SOAP_TYPE__wsa5__Metadata
#define SOAP_TYPE__wsa5__Metadata (30)
typedef struct wsa5__MetadataType _wsa5__Metadata;
#endif

/* wsa5.h:218 */
#ifndef SOAP_TYPE__wsa5__MessageID
#define SOAP_TYPE__wsa5__MessageID (31)
typedef char *_wsa5__MessageID;
#endif

/* wsa5.h:221 */
#ifndef SOAP_TYPE__wsa5__RelatesTo
#define SOAP_TYPE__wsa5__RelatesTo (32)
typedef struct wsa5__RelatesToType _wsa5__RelatesTo;
#endif

/* wsa5.h:224 */
#ifndef SOAP_TYPE__wsa5__ReplyTo
#define SOAP_TYPE__wsa5__ReplyTo (33)
typedef struct wsa5__EndpointReferenceType _wsa5__ReplyTo;
#endif

/* wsa5.h:227 */
#ifndef SOAP_TYPE__wsa5__From
#define SOAP_TYPE__wsa5__From (34)
typedef struct wsa5__EndpointReferenceType _wsa5__From;
#endif

/* wsa5.h:230 */
#ifndef SOAP_TYPE__wsa5__FaultTo
#define SOAP_TYPE__wsa5__FaultTo (35)
typedef struct wsa5__EndpointReferenceType _wsa5__FaultTo;
#endif

/* wsa5.h:233 */
#ifndef SOAP_TYPE__wsa5__To
#define SOAP_TYPE__wsa5__To (36)
typedef char *_wsa5__To;
#endif

/* wsa5.h:236 */
#ifndef SOAP_TYPE__wsa5__Action
#define SOAP_TYPE__wsa5__Action (37)
typedef char *_wsa5__Action;
#endif

/* wsa5.h:239 */
#ifndef SOAP_TYPE__wsa5__RetryAfter
#define SOAP_TYPE__wsa5__RetryAfter (39)
typedef ULONG64 _wsa5__RetryAfter;
#endif

/* wsa5.h:242 */
#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName
#define SOAP_TYPE__wsa5__ProblemHeaderQName (40)
typedef _QName _wsa5__ProblemHeaderQName;
#endif

/* wsa5.h:245 */
#ifndef SOAP_TYPE__wsa5__ProblemIRI
#define SOAP_TYPE__wsa5__ProblemIRI (41)
typedef char *_wsa5__ProblemIRI;
#endif

/* wsa5.h:248 */
#ifndef SOAP_TYPE__wsa5__ProblemAction
#define SOAP_TYPE__wsa5__ProblemAction (42)
typedef struct wsa5__ProblemActionType _wsa5__ProblemAction;
#endif

/* onvif.h:202 */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (72)
typedef std::string xsd__NCName;
#endif

/* onvif.h:205 */
#ifndef SOAP_TYPE_xsd__anySimpleType
#define SOAP_TYPE_xsd__anySimpleType (73)
typedef std::string xsd__anySimpleType;
#endif

/* onvif.h:208 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (74)
typedef std::string xsd__anyURI;
#endif

/* onvif.h:211 */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (75)
typedef std::string xsd__integer;
#endif

/* onvif.h:214 */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (76)
typedef std::string xsd__nonNegativeInteger;
#endif

/* onvif.h:217 */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (77)
typedef std::string xsd__token;
#endif

/* onvif.h:221 */
#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (78)
typedef std::string _xml__lang;
#endif

/* onvif.h:2599 */
#ifndef SOAP_TYPE_tmd__DelayTimes
#define SOAP_TYPE_tmd__DelayTimes (865)
typedef std::string tmd__DelayTimes;
#endif

/* onvif.h:2611 */
#ifndef SOAP_TYPE_tds__EAPMethodTypes
#define SOAP_TYPE_tds__EAPMethodTypes (866)
typedef std::string tds__EAPMethodTypes;
#endif

/* onvif.h:2623 */
#ifndef SOAP_TYPE_tt__IntAttrList
#define SOAP_TYPE_tt__IntAttrList (867)
typedef std::string tt__IntAttrList;
#endif

/* onvif.h:2627 */
#ifndef SOAP_TYPE_tt__FloatAttrList
#define SOAP_TYPE_tt__FloatAttrList (868)
typedef std::string tt__FloatAttrList;
#endif

/* onvif.h:2631 */
#ifndef SOAP_TYPE_tt__StringAttrList
#define SOAP_TYPE_tt__StringAttrList (869)
typedef std::string tt__StringAttrList;
#endif

/* onvif.h:2635 */
#ifndef SOAP_TYPE_tt__ReferenceTokenList
#define SOAP_TYPE_tt__ReferenceTokenList (870)
typedef std::string tt__ReferenceTokenList;
#endif

/* onvif.h:2646 */
#ifndef SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType (871)
typedef std::string wsnt__AbsoluteOrRelativeTimeType;
#endif

/* onvif.h:2770 */
#ifndef SOAP_TYPE_tt__ReferenceToken
#define SOAP_TYPE_tt__ReferenceToken (876)
typedef std::string tt__ReferenceToken;
#endif

/* onvif.h:2778 */
#ifndef SOAP_TYPE_tt__Name
#define SOAP_TYPE_tt__Name (877)
typedef std::string tt__Name;
#endif

/* onvif.h:2998 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConfigPriority
#define SOAP_TYPE_tt__NetworkInterfaceConfigPriority (894)
typedef xsd__integer tt__NetworkInterfaceConfigPriority;
#endif

/* onvif.h:3014 */
#ifndef SOAP_TYPE_tt__IANA_IfTypes
#define SOAP_TYPE_tt__IANA_IfTypes (896)
typedef int tt__IANA_IfTypes;
#endif

/* onvif.h:3049 */
#ifndef SOAP_TYPE_tt__IPv4Address
#define SOAP_TYPE_tt__IPv4Address (900)
typedef xsd__token tt__IPv4Address;
#endif

/* onvif.h:3053 */
#ifndef SOAP_TYPE_tt__IPv6Address
#define SOAP_TYPE_tt__IPv6Address (901)
typedef xsd__token tt__IPv6Address;
#endif

/* onvif.h:3057 */
#ifndef SOAP_TYPE_tt__HwAddress
#define SOAP_TYPE_tt__HwAddress (902)
typedef xsd__token tt__HwAddress;
#endif

/* onvif.h:3070 */
#ifndef SOAP_TYPE_tt__DNSName
#define SOAP_TYPE_tt__DNSName (904)
typedef xsd__token tt__DNSName;
#endif

/* onvif.h:3074 */
#ifndef SOAP_TYPE_tt__Domain
#define SOAP_TYPE_tt__Domain (905)
typedef xsd__token tt__Domain;
#endif

/* onvif.h:3098 */
#ifndef SOAP_TYPE_tt__Dot11SSIDType
#define SOAP_TYPE_tt__Dot11SSIDType (908)
typedef xsd__hexBinary tt__Dot11SSIDType;
#endif

/* onvif.h:3136 */
#ifndef SOAP_TYPE_tt__Dot11PSK
#define SOAP_TYPE_tt__Dot11PSK (912)
typedef xsd__hexBinary tt__Dot11PSK;
#endif

/* onvif.h:3141 */
#ifndef SOAP_TYPE_tt__Dot11PSKPassphrase
#define SOAP_TYPE_tt__Dot11PSKPassphrase (913)
typedef std::string tt__Dot11PSKPassphrase;
#endif

/* onvif.h:3314 */
#ifndef SOAP_TYPE_tt__AuxiliaryData
#define SOAP_TYPE_tt__AuxiliaryData (928)
typedef std::string tt__AuxiliaryData;
#endif

/* onvif.h:3474 */
#ifndef SOAP_TYPE_tt__TopicNamespaceLocation
#define SOAP_TYPE_tt__TopicNamespaceLocation (944)
typedef xsd__anyURI tt__TopicNamespaceLocation;
#endif

/* onvif.h:3550 */
#ifndef SOAP_TYPE_tt__Description
#define SOAP_TYPE_tt__Description (949)
typedef std::string tt__Description;
#endif

/* onvif.h:3554 */
#ifndef SOAP_TYPE_tt__XPathExpression
#define SOAP_TYPE_tt__XPathExpression (950)
typedef std::string tt__XPathExpression;
#endif

/* onvif.h:3611 */
#ifndef SOAP_TYPE_tt__RecordingJobMode
#define SOAP_TYPE_tt__RecordingJobMode (954)
typedef std::string tt__RecordingJobMode;
#endif

/* onvif.h:3615 */
#ifndef SOAP_TYPE_tt__RecordingJobState
#define SOAP_TYPE_tt__RecordingJobState (955)
typedef std::string tt__RecordingJobState;
#endif

/* onvif.h:3636 */
#ifndef SOAP_TYPE_tt__AudioClassType
#define SOAP_TYPE_tt__AudioClassType (957)
typedef std::string tt__AudioClassType;
#endif

/* onvif.h:3688 */
#ifndef SOAP_TYPE_wstop__FullTopicExpression
#define SOAP_TYPE_wstop__FullTopicExpression (960)
typedef std::string wstop__FullTopicExpression;
#endif

/* onvif.h:3697 */
#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression
#define SOAP_TYPE_wstop__ConcreteTopicExpression (961)
typedef std::string wstop__ConcreteTopicExpression;
#endif

/* onvif.h:3705 */
#ifndef SOAP_TYPE_wstop__SimpleTopicExpression
#define SOAP_TYPE_wstop__SimpleTopicExpression (962)
typedef xsd__QName wstop__SimpleTopicExpression;
#endif

/* onvif.h:3717 */
#ifndef SOAP_TYPE_tt__ReceiverReference
#define SOAP_TYPE_tt__ReceiverReference (963)
typedef tt__ReferenceToken tt__ReceiverReference;
#endif

/* onvif.h:3721 */
#ifndef SOAP_TYPE_tt__RecordingReference
#define SOAP_TYPE_tt__RecordingReference (964)
typedef tt__ReferenceToken tt__RecordingReference;
#endif

/* onvif.h:3725 */
#ifndef SOAP_TYPE_tt__TrackReference
#define SOAP_TYPE_tt__TrackReference (965)
typedef tt__ReferenceToken tt__TrackReference;
#endif

/* onvif.h:3729 */
#ifndef SOAP_TYPE_tt__JobToken
#define SOAP_TYPE_tt__JobToken (966)
typedef tt__ReferenceToken tt__JobToken;
#endif

/* onvif.h:3733 */
#ifndef SOAP_TYPE_tt__RecordingJobReference
#define SOAP_TYPE_tt__RecordingJobReference (967)
typedef tt__ReferenceToken tt__RecordingJobReference;
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
